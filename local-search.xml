<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>梯度下降法</title>
    <link href="/2024/02/01/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/"/>
    <url>/2024/02/01/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><h2 id="数学意义"><a href="#数学意义" class="headerlink" title="数学意义"></a>数学意义</h2><p>梯度就是方向向量最大。那么梯度下降就是根据方向导数最大的方向寻找局部最优解。</p><p><img src="/../images/v2-0f23b351799a1cb70f9a1f71f743d160_720w.webp" alt="img"></p><p>通过更新x来寻找局部最小值，梯度下降的公式即为：<br>$$<br>x=x-\alpha*\frac{df(x)}{dx}<br>$$<br>其中的$\alpha$成为学习率，越小则下降的幅度越小，反之越大。</p><p><strong>注意：</strong>$\alpha$不能够太大，因为当遍历到最小值的时候，可能会导致越过了最小值。</p><h2 id="二元函数的梯度下降"><a href="#二元函数的梯度下降" class="headerlink" title="二元函数的梯度下降"></a><strong>二元函数的梯度下降</strong></h2><p><img src="/../images/v2-fd9647e3aa2038c05a04e024fdb40a7c_720w.webp" alt="img"></p><p>多元函数的梯度就是对每一个坐标的偏导。<img src="/../images/image-20240202081000240.png" alt="image-20240202081000240"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>梯度下降法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目idea</title>
    <link href="/2024/02/01/%E9%A1%B9%E7%9B%AEidea/"/>
    <url>/2024/02/01/%E9%A1%B9%E7%9B%AEidea/</url>
    
    <content type="html"><![CDATA[<h1 id="project"><a href="#project" class="headerlink" title="project"></a>project</h1><h1 id="component"><a href="#component" class="headerlink" title="component"></a>component</h1><ul><li>  mybatisplus运行时显示sql语句</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>idea</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务学习（二）——Docker</title>
    <link href="/2024/02/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Docker/"/>
    <url>/2024/02/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210731142219735.png?lastModify=1706766540" alt="image-20210731142219735"></p><p><strong>操作系统版本也会有差异，怎么解决这些问题呢？</strong></p><ul><li><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>  Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>  Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul></li></ul><h2 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h2><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>总结：镜像就是只读，容器是运行时加载到内存中形成进程。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210731155649535.png?lastModify=1706767599" alt="image-20210731155649535"></p><h3 id="案例1-拉取、查看镜像"><a href="#案例1-拉取、查看镜像" class="headerlink" title="案例1-拉取、查看镜像"></a>案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="/../images/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="/../images/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="/../images/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="案例2-保存、导入镜像"><a href="#案例2-保存、导入镜像" class="headerlink" title="案例2-保存、导入镜像"></a>案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../images/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o [保存的目标文件名称] [镜像名称]<br></code></pre></td></tr></table></figure><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o nginx.tar nginx:latest<br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="/../images/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker rmi nginx:latest<br></code></pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load -i nginx.tar<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../images/image-20210731161746245.png" alt="image-20210731161746245"></p><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210731161950495.png?lastModify=1706767777" alt="image-20210731161950495"></p><h3 id="创建并运行一个容器"><a href="#创建并运行一个容器" class="headerlink" title="创建并运行一个容器"></a>创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name containerName -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口，容器时隔离环境，如果配置端口映射访问不到容器。</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><h3 id="进入容器，修改文件"><a href="#进入容器，修改文件" class="headerlink" title="进入容器，修改文件"></a>进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it mn bash<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/../images/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/share/nginx/html<br></code></pre></td></tr></table></figure><p> 查看目录下文件：</p><p><img src="/../images/image-20210731164455818.png" alt="image-20210731164455818"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="hljs-string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html<br></code></pre></td></tr></table></figure><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="/../images/image-20210731164717604.png" alt="image-20210731164717604"></p><h2 id="数据卷（容器数据管理）"><a href="#数据卷（容器数据管理）" class="headerlink" title="数据卷（容器数据管理）"></a>数据卷（容器数据管理）</h2><p>上面我们修改nginx文件需要进入nginx内部，否则无法修改，这个原因是容器和数据是耦合的，要解决这个问题，必须将数据和容器解耦，这就用到了数据卷。</p><h3 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210731173541846.png?lastModify=1706768114" alt="image-20210731173541846"></p><p>也就是将容器与宿主机进行挂载。</p><h3 id="数据集操作"><a href="#数据集操作" class="headerlink" title="数据集操作"></a>数据集操作</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><p><strong>创建和查看数据卷</strong></p><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume create html<br></code></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../images/image-20210731173746910.png" alt="image-20210731173746910"></p><p>③ 查看数据卷详细信息卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume inspect html<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../images/image-20210731173809877.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><h3 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run \<br>  --name mn \<br>  -v html:/root/html \<br>  -p 8080:80<br>  nginx \<br></code></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li></ul><h3 id="案例-给nginx挂载数据卷"><a href="#案例-给nginx挂载数据卷" class="headerlink" title="案例-给nginx挂载数据卷"></a>案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>② 进入html数据卷所在位置，并修改HTML内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-comment"># 进入该目录</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/html/_data<br><span class="hljs-comment"># 修改文件</span><br>vi index.html<br></code></pre></td></tr></table></figure><h3 id="案例-给MySQL挂载本地目录"><a href="#案例-给MySQL挂载本地目录" class="headerlink" title="案例-给MySQL挂载本地目录"></a>案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="/../images/image-20210731175155453.png" alt="image-20210731175155453"></p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><h2 id="Dockerfile自定义镜像"><a href="#Dockerfile自定义镜像" class="headerlink" title="Dockerfile自定义镜像"></a>Dockerfile自定义镜像</h2><h3 id="Dockerfile语法"><a href="#Dockerfile语法" class="headerlink" title="Dockerfile语法"></a>Dockerfile语法</h3><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="/../images/image-20210731180321133.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h2><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">version<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.8&quot;</span><br> services<span class="hljs-punctuation">:</span><br>  mysql<span class="hljs-punctuation">:</span><br>    image<span class="hljs-punctuation">:</span> mysql<span class="hljs-punctuation">:</span><span class="hljs-number">5.7</span><span class="hljs-number">.25</span><br>    environment<span class="hljs-punctuation">:</span><br>     MYSQL_ROOT_PASSWORD<span class="hljs-punctuation">:</span> <span class="hljs-number">123</span> <br>    volumes<span class="hljs-punctuation">:</span><br>     - <span class="hljs-string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br>     - <span class="hljs-string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br>  web<span class="hljs-punctuation">:</span><br>    build<span class="hljs-punctuation">:</span> .<br>    ports<span class="hljs-punctuation">:</span><br>     - <span class="hljs-string">&quot;8090:8090&quot;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="/2024/02/01/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2024/02/01/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式锁——Redis实现方式"><a href="#分布式锁——Redis实现方式" class="headerlink" title="分布式锁——Redis实现方式"></a>分布式锁——Redis实现方式</h1><h2 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h2><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间（必须添加）</li></ul></li></ul><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><strong>锁的基本接口</strong></p><p><img src="/../images/1656079017728.png" alt="1656079017728"></p><p><strong>SimpleRedisLock</strong></p><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_PREFIX=<span class="hljs-string">&quot;lock:&quot;</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId()<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>释放锁逻辑</li></ul><p>SimpleRedisLock</p><p>释放锁，防止删除别人的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//通过del删除锁</span><br>    stringRedisTemplate.delete(KEY_PREFIX + name);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改业务代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>      <span class="hljs-comment">// 1.查询优惠券</span><br>      <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>      <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>      <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>          <span class="hljs-comment">// 尚未开始</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>      <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>          <span class="hljs-comment">// 尚未开始</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 4.判断库存是否充足</span><br>      <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">// 库存不足</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>      &#125;<br>      <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>      <span class="hljs-comment">//创建锁对象(新增代码)</span><br>      <span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br>      <span class="hljs-comment">//获取锁对象</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1200</span>);<br><span class="hljs-comment">//加锁失败</span><br>      <span class="hljs-keyword">if</span> (!isLock) &#123;<br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//获取代理对象(事务)</span><br>          <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>          <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-comment">//释放锁</span><br>          lock.unlock();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="分布式锁常出现的问题"><a href="#分布式锁常出现的问题" class="headerlink" title="分布式锁常出现的问题"></a>分布式锁常出现的问题</h2><p>（1）执行时间大于过期时间，导致另外线程占用锁（拉屎的时候别人冲进来）（续期）</p><p>（2）接上面的场景，执行完后处理删除线程时误删除别人的锁，导致后来线程又加锁。（在释放锁的时候判断是不是自己的锁）</p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/1653385920025.png?lastModify=1706753347" alt="1653385920025"></p><p>（3）在进行释放锁代码的时候已经通过了是不是自己的锁的验证，这时候别的线程又进来了加锁，导致当前线程把新线程的锁删除。</p><p>（4）Redis如果时集群怎么保证数据一致性。</p><h2 id="解决分布式锁的误删除问题"><a href="#解决分布式锁的误删除问题" class="headerlink" title="解决分布式锁的误删除问题"></a>解决分布式锁的误删除问题</h2><p>在获取锁时存入线程标示（可以用UUID表示）在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p><img src="file://D:/Codefield/projects/selfBlog/source/images/1653387398820.png?lastModify=1706753347" alt="1653387398820"></p><p>具体代码如下：加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>   <span class="hljs-comment">// 获取线程标示</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>   <span class="hljs-comment">// 获取锁</span><br>   <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>   <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br></code></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标示是否一致</span><br>    <span class="hljs-keyword">if</span>(threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p>也就上面我们提到的第三个问题</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/1653387764938.png?lastModify=1706753347" alt="1653387764938"></p><p> Lua脚本解决多条命令原子性问题（了解即可）<a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><h1 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h1><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>Redission提供了许多分布式锁的功能：</p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/1653546736063.png?lastModify=1706753347" alt="1653546736063"></p><h2 id="Redission快速入门"><a href="#Redission快速入门" class="headerlink" title="Redission快速入门"></a>Redission快速入门</h2><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>&lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>&lt;artifactId&gt;redisson&lt;/artifactId&gt;<br>&lt;version&gt;<span class="hljs-number">3.13</span><span class="hljs-number">.6</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 配置</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.150.101:6379&quot;</span>)<br>            .setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如何使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissionClient redissonClient;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//获取锁(可重入)，指定锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//判断获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);          <br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>        <br>    &#125;<br>    <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">// 1.查询优惠券</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>        <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>        <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>        <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 4.判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 库存不足</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span><br>        <span class="hljs-comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>        <span class="hljs-comment">//获取锁对象</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>       <br><span class="hljs-comment">//加锁失败</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取代理对象(事务)</span><br>            <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>            <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="redission可重入锁"><a href="#redission可重入锁" class="headerlink" title="redission可重入锁"></a>redission可重入锁</h2><p><img src="file://D:/Codefield/projects/selfBlog/source/images/1653548087334.png?lastModify=1706753347" alt="1653548087334"></p><h2 id="redission锁重试和WatchDog机制"><a href="#redission锁重试和WatchDog机制" class="headerlink" title="redission锁重试和WatchDog机制"></a>redission锁重试和WatchDog机制</h2><p>Redisson提供的分布式锁是支持锁自动续期的，</p><h2 id="redission锁的MutiLock原理"><a href="#redission锁的MutiLock原理" class="headerlink" title="redission锁的MutiLock原理"></a>redission锁的MutiLock原理</h2><p><img src="file://D:/Codefield/projects/selfBlog/source/images/1653553093967.png?lastModify=1706753347" alt="1653553093967"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制单元的功能</title>
    <link href="/2024/02/01/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <url>/2024/02/01/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="控制单元的功能"><a href="#控制单元的功能" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h1><h2 id="微操作命令的分析"><a href="#微操作命令的分析" class="headerlink" title="微操作命令的分析"></a>微操作命令的分析</h2><p>这一篇主要就是讲指令周期的4个阶段的具体操作过程。</p><h3 id="取值周期"><a href="#取值周期" class="headerlink" title="取值周期"></a>取值周期</h3><p><img src="/../images/image-20230403124609095.png" alt="image-20230403124609095"></p><h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p><img src="/../images/image-20230403124624969.png" alt="image-20230403124624969"></p><h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p><img src="/../images/image-20230403124647369.png" alt="image-20230403124647369"></p><p><img src="/../images/image-20230403124656707.png" alt="image-20230403124656707"></p><p><img src="/../images/image-20230403124702769.png" alt="image-20230403124702769"></p><p><img src="/../images/image-20230403124710644.png" alt="image-20230403124710644"></p><p><img src="/../images/image-20230403124718257.png" alt="image-20230403124718257"></p><h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p><img src="/../images/image-20230403124731895.png" alt="image-20230403124731895"></p><h2 id="控制单元的功能-1"><a href="#控制单元的功能-1" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h2><h3 id="外特性"><a href="#外特性" class="headerlink" title="外特性"></a>外特性</h3><p><img src="/../images/image-20230403124807457.png" alt="image-20230403124807457"></p><h4 id="1、输入信号"><a href="#1、输入信号" class="headerlink" title="1、输入信号"></a>1、输入信号</h4><p>（1）时钟</p><p>（2）指令寄存器</p><p>（3）标志</p><p>（4）外来信号</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU的结构和功能</title>
    <link href="/2024/02/01/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
    <url>/2024/02/01/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU的结构和功能"><a href="#CPU的结构和功能" class="headerlink" title="CPU的结构和功能"></a>CPU的结构和功能</h1><h2 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><p>CPU是实质上是包括了运算器和控制器两部分，前面讲解了运算器的硬件配置这里我们重点介绍控制器的功能：</p><ul><li>  取指令</li></ul><p>自动形成指令地址；自动发出取指令的命令。</p><ul><li>  分析指令</li></ul><p>操作码译码</p><ul><li>  执行指令</li></ul><p>根据分析指令得到的“操作命令”和“操作数地址”，操作各种器件。</p><h3 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h3><p>通过功能，要想实现取指令，必须要有一个寄存器专用于存放当前指令的地址，要分析指令就需要译码元件，要执行指令，就需要一个能够发出各种操作命令的CU，要完成算术逻辑运算就需要实现运算的ALU部件。</p><p><img src="/../images/image-20230328100242681.png" alt="image-20230328100242681"></p><p>各部件和其功能的对比图如下：</p><p><img src="/../images/image-20230328100321892.png" alt="image-20230328100321892"></p><h3 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h3><h4 id="1、用户可见寄存器"><a href="#1、用户可见寄存器" class="headerlink" title="1、用户可见寄存器"></a>1、用户可见寄存器</h4><p>通常CPU执行语言访问的寄存器就是用户可见寄存器。</p><p>可以分为下列几种：</p><p><strong>（1）通用寄存器</strong></p><p>可用于存放操作数又可以满足某种寻址方式。</p><p><strong>（2）数据寄存器</strong></p><p>存放操作数，位数满足多数数据数据类型的数值范围、有些机器循序使用两个连续的寄存器存放双倍字长的值。</p><p><strong>（3）地址寄存器</strong></p><p>存放地址，位数要满足最大的地址范围。用于特殊寻址方式（基址寻址、堆栈寻址）。</p><p><strong>（4）条件码寄存器</strong></p><p>存放条件码，可作程序分支的依据，如 正、负、零、溢出、进位等</p><h4 id="2、控制和状态寄存器"><a href="#2、控制和状态寄存器" class="headerlink" title="2、控制和状态寄存器"></a>2、控制和状态寄存器</h4><p>（1）控制寄存器</p><p>MAR（存储器地址寄存器）、MDR（存储器数据寄存器）、PC（程序计数器）、IR（指令寄存器）。</p><p>（2）状态寄存器</p><p>状态寄存器：存放条件码；PSW寄存器：存放程序状态字。</p><h3 id="控制单元和中断系统"><a href="#控制单元和中断系统" class="headerlink" title="控制单元和中断系统"></a>控制单元和中断系统</h3><p>控制单元（CU）提供完成计算机全部指令的微操作命令序列部件。有两种操作命令形成的方式：</p><ul><li>  组合逻辑设计方法：硬连线逻辑</li><li>  微程序设计：存储逻辑</li></ul><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>指令周期指的是取出并且执行一条指令所需要的全部时间。</p><p><img src="/../images/image-20230328104418752.png" alt="image-20230328104418752"></p><p>每条指令的指令周期都不同。</p><p>具有间接寻址的指令周期：</p><p><img src="/../images/image-20230328104637541.png" alt="image-20230328104637541"></p><p>带有中断周期的指令周期：</p><p><img src="/../images/image-20230328104659428.png" alt="image-20230328104659428"></p><p>指令周期流程：</p><p><img src="/../images/image-20230328104808480.png" alt="image-20230328104808480"></p><p>上面4个周期都有CPU访存操作，为了区别它们，在CPU中可以设置4个标志触发器。</p><p>FE-取、IND-间址、EX-执行、INT-中断。</p><p><img src="/../images/image-20230328105033179.png" alt="image-20230328105033179"></p><h3 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h3><h4 id="1、取指周期的数据流"><a href="#1、取指周期的数据流" class="headerlink" title="1、取指周期的数据流"></a>1、取指周期的数据流</h4><p><img src="/../images/image-20230328105556595.png" alt="image-20230328105556595"></p><p>取指周期的流程如下：PC中存放的是现行程序的地址，将该地址传送至MAR中传送至地址总线中，CU通知存储器读命令，将MAR地址数据从数据总线中传送到MDR中，再传到IR，最后CU控制PC加1。</p><h4 id="2、间址周期数据流"><a href="#2、间址周期数据流" class="headerlink" title="2、间址周期数据流"></a>2、间址周期数据流</h4><p><img src="/../images/image-20230328110257236.png" alt="image-20230328110257236"></p><p>一旦周期结束，CU检查IR内容，如果有间址操作，则MAR中指示的右N位送到MAR中，有送到地址总线中，此后CU向存储器发出读操作。</p><h4 id="3、执行周期数据流"><a href="#3、执行周期数据流" class="headerlink" title="3、执行周期数据流"></a>3、执行周期数据流</h4><p>不同指令的执行周期数据流不同</p><h4 id="4、中断周期数据流"><a href="#4、中断周期数据流" class="headerlink" title="4、中断周期数据流"></a>4、中断周期数据流</h4><p><img src="/../images/image-20230328110545099.png" alt="image-20230328110545099"></p><p>CU把用于保存断点的存储器特殊地址送往MAR，CU发出写命令，PC内容写到MDR中，断电数据通过数据总线送到存储器中。</p><h2 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h2><p>根据之前我们讲的内容，如果要提高访存速度，可以提高存储芯片的性能，或者可以采用Cache、多体并行；如果要提高主机和IO设备的交换信息的速度，可以采用DMA方式、多总线结构；为了提高运算器的速度，可以采用高速芯片和快速进位链。</p><p>为了进一步提高处理器的速度，可以通过两个方面来实现：</p><p>1、提高器件的性能</p><p>2、改进系统的结构，开发系统的并行性</p><h3 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h3><p>并发：两个或两个以上事件在 <strong>同一时间段</strong> 发生</p><p>同时：两个或者两个以上事件在同一时刻发生。</p><h3 id="指令流水的原理"><a href="#指令流水的原理" class="headerlink" title="指令流水的原理"></a>指令流水的原理</h3><p>首先什么是流水？这个词其实就是流水线的意思，在工厂中，我们经常用到并行工序，也就是工作研究中讨论的如何让等待时间最低。</p><h4 id="指令二级流水"><a href="#指令二级流水" class="headerlink" title="指令二级流水"></a>指令二级流水</h4><p><img src="/../images/image-20230329102142660.png" alt="image-20230329102142660"></p><p>也就是取下一条指令操作和执行当前指令的操作同时进行。执行和取值阶段时间上完全重叠。速度提高一倍。</p><h4 id="影响指令效率的因素"><a href="#影响指令效率的因素" class="headerlink" title="影响指令效率的因素"></a>影响指令效率的因素</h4><p>上面的这种提高效率的做法其实并不可行，因为：</p><ul><li>  一般来说执行的时间大于取值时间。</li><li>  条件转移指令对指令流水的影响。</li></ul><p>通过猜测法，减少时间损失。</p><h4 id="指令的六级流水"><a href="#指令的六级流水" class="headerlink" title="指令的六级流水"></a>指令的六级流水</h4><p>六级流水就是把指令的处理过程分的更加细致：取指、指令译码、计算操作数地址、去操作数、执行指令、写操作数。</p><p><img src="/../images/image-20230329103207312.png" alt="image-20230329103207312"></p><h4 id="影响指令流水性能的因素"><a href="#影响指令流水性能的因素" class="headerlink" title="影响指令流水性能的因素"></a>影响指令流水性能的因素</h4><p>假设以下的指令都是由5部分组成：取指令（IF）、指令译码/都寄存器（ID）、执行/访存有效地址计算（EX）、存储器访问（MEM）、结构返回寄存器（WB）。</p><h5 id="1、结构相关"><a href="#1、结构相关" class="headerlink" title="1、结构相关"></a>1、结构相关</h5><p>结构相关是指当多条指令进入流水线后，硬件资源满足不了指令重叠的要求。也就是不同指令争用同一部分的功能部件。</p><p><img src="/../images/image-20230329103425114.png" alt="image-20230329103425114"></p><p>如IF和MEM会发生访存冲突，解决方法如下：</p><ul><li>  暂停一个时钟周期</li><li>  设置两个独立的存储器分别存放在操作数和指令。</li></ul><h5 id="2、数据相关"><a href="#2、数据相关" class="headerlink" title="2、数据相关"></a>2、数据相关</h5><p>数据相关是流水线的各条指令因重叠操作，可能改变对操作数的读写访问顺序。</p><p><img src="/../images/image-20230329104730171.png" alt="image-20230329104730171"></p><p>以上的就是几种数据相关的情况，解决办法：</p><ul><li>  后推法：把相关指令延迟到所需操作数被写回寄存器后再执行。</li><li>  定向技术（旁路技术或者相关专用通路技术）：将执行结果直接送到其他指令需要的地方。</li></ul><h5 id="3、控制相关"><a href="#3、控制相关" class="headerlink" title="3、控制相关"></a>3、控制相关</h5><p>控制相关主要是由转移指令引起的。</p><p><img src="/../images/image-20230329120718607.png" alt="image-20230329120718607"></p><h3 id="流水线性能"><a href="#流水线性能" class="headerlink" title="流水线性能"></a>流水线性能</h3><h4 id="1、吞吐量"><a href="#1、吞吐量" class="headerlink" title="1、吞吐量"></a>1、吞吐量</h4><p>吞吐量：单位时间内流水线所完成指令或输出结果的数量</p><p> 最大吞吐率：<img src="../../../../../相册/typora/image-20230329121152971.png" alt="image-20230329121152971" style="zoom: 50%;" /></p><p> 实际吞吐率：连续处理 n 条指令的吞吐率为<img src="../../../../../相册/typora/image-20230329121220047.png" alt="image-20230329121220047" style="zoom:50%;" /></p><h4 id="2、加速比"><a href="#2、加速比" class="headerlink" title="2、加速比"></a>2、加速比</h4><p>m段的流水线的速度与等功能的非流水线的速度之比</p><p>完成 n 条指令在 m 段流水线上共需：<img src="../../../../../相册/typora/image-20230329121410586.png" alt="image-20230329121410586" style="zoom:50%;" /></p><p>完成 n 条指令在等效的非流水线上共需：<img src="../../../../../相册/typora/image-20230329121432411.png" alt="image-20230329121432411" style="zoom:67%;" /></p><p>则：<img src="/../images/image-20230329121456324.png" alt="image-20230329121456324"></p><h4 id="3、效率"><a href="#3、效率" class="headerlink" title="3、效率"></a>3、效率</h4><p>流水线中各功能段的利用率，由于流水线有建立时间和排空时间 因此各功能段的设备不可能一直处于工作状态</p><p><img src="/../images/image-20230329121609212.png" alt="image-20230329121609212"></p><h3 id="流水线中的多发技术"><a href="#流水线中的多发技术" class="headerlink" title="流水线中的多发技术"></a>流水线中的多发技术</h3><h4 id="1、超标量技术"><a href="#1、超标量技术" class="headerlink" title="1、超标量技术"></a>1、超标量技术</h4><ul><li><p>  每个时钟周期内可并发多条独立指令配置多个功能部件。</p></li><li><p>  不能调整指令的执行顺序， 通过编译优化技术，把可并行执行的指令搭配起来。</p></li></ul><h4 id="2、超流水线技术"><a href="#2、超流水线技术" class="headerlink" title="2、超流水线技术"></a>2、超流水线技术</h4><ul><li>  在 一个时钟周期 内 再分段 （ 3 段） </li><li>  在一个时钟周期内 一个功能部件使用多次（ 3 次）</li><li>  不能调整 指令的 执行顺序  靠编译程序解决优化问题</li></ul><p>流水线速度是原来的3倍。</p><h4 id="3、超长指令字技术（待补充）"><a href="#3、超长指令字技术（待补充）" class="headerlink" title="3、超长指令字技术（待补充）"></a>3、超长指令字技术（待补充）</h4><p><img src="/../images/image-20230329121932103.png" alt="image-20230329121932103"></p><p><img src="/../images/image-20230329121939430.png" alt="image-20230329121939430"></p><p><img src="/../images/image-20230329121945766.png" alt="image-20230329121945766"></p><h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>引发中断请求的因素：</p><ul><li>  人为设置的中断：例如“转管指令”</li><li>  程序性事故</li><li>  硬件故障</li><li>  IO设备</li><li>  外部事件</li></ul><p>那么中断系统需要做到哪些要求：</p><ul><li>  各中断源如何向CPU发出中断请求。</li><li>  当多个中断源同时发出中断请求，中断系统如何确认优先级。</li><li>  CPU在什么条件、什么时间、什么方式来响应中断。</li><li>  CPU响应中断后如何保护现场</li><li>  CPU响应中断后，如何停止源程序的执行并且转入中断服务程序的入口地址。</li><li>  中断处理结束，怎么恢复现场，如何返回源程序的间断点。</li><li>  在中断处理过程中又出现中断怎么处理。</li></ul><p>下面就是对以上的问题进行解答：</p><h3 id="中断请求标志和中断判优逻辑"><a href="#中断请求标志和中断判优逻辑" class="headerlink" title="中断请求标志和中断判优逻辑"></a>中断请求标志和中断判优逻辑</h3><h4 id="1、中断请求标记"><a href="#1、中断请求标记" class="headerlink" title="1、中断请求标记"></a>1、中断请求标记</h4><p>中断请求标记就是用来判断中断源是哪个，中断请求触发器（INTR）。当其状态为1时，就是说这个中断源有请求。中断请求触发器越多，表明计算机处理能力越强。但是这些中断触发器既可以集成在CPU中又可以分散到各个中断源中。</p><h4 id="2、中断判优逻辑"><a href="#2、中断判优逻辑" class="headerlink" title="2、中断判优逻辑"></a>2、中断判优逻辑</h4><p>当两个以上的中断源同时进行请求，怎么选择哪个中断源呢？中断判优可以使用硬件实现也可以使用软件实现。</p><p>（1）硬件排队</p><p>硬件排队又分为两种：链式排队器和CPU内的排队器。</p><p>链式排队器就是之前讲过的方式。CPU内的排队器如果有请求INTR=1，就可以封住比它级别低的中断源的请求。</p><p>（2）软件排队</p><p>软件排队是通过编写查询程序实现的。</p><h3 id="中断服务程序的入口地址的寻找"><a href="#中断服务程序的入口地址的寻找" class="headerlink" title="中断服务程序的入口地址的寻找"></a>中断服务程序的入口地址的寻找</h3><p>通过硬件向量法和软件查询法。</p><h4 id="1、硬件向量法"><a href="#1、硬件向量法" class="headerlink" title="1、硬件向量法"></a>1、硬件向量法</h4><p>硬件向量法就是通过向量地址寻找。向量地址由中断向量地址形成部件产生。</p><p>向量地址寻址方法有两种：在向量地址内存中放一条无条件转移指令。二是设置向量地址表。</p><h4 id="2、软件查询法"><a href="#2、软件查询法" class="headerlink" title="2、软件查询法"></a>2、软件查询法</h4><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><h4 id="1、中断响应条件"><a href="#1、中断响应条件" class="headerlink" title="1、中断响应条件"></a>1、中断响应条件</h4><p>当允许中断触发器EINT为1时，CPU允许响应中断源的请求，当其为0时，意味着CPU禁止响应中断。</p><h4 id="2、响应中断的时间"><a href="#2、响应中断的时间" class="headerlink" title="2、响应中断的时间"></a>2、响应中断的时间</h4><p>CPU是在指令执行周期结束以后才响应中断源的请求。但是一些指令执行时间过长，所以可以在指令执行中设置若干个查询断点。</p><h4 id="3、中断隐指令"><a href="#3、中断隐指令" class="headerlink" title="3、中断隐指令"></a>3、中断隐指令</h4><p>当进入中断周器，CPU要完成一系列的操作：</p><p>（1）保护程序断点</p><p>也就是将当前的PC保存在存储器中，可以存入特定单元或者堆栈。</p><p>（2）寻找中断服务程序的入口地址</p><p>硬件向量法和软件查询法</p><p>（3）关中断</p><p>也就是保证CPU在响应中断的过程中不会受新的中断请求干扰。当进入中断周期时，INT为1，经过一个正跳变和反相，使得EINT置为0。</p><p><img src="/../images/image-20230403104040787.png" alt="image-20230403104040787"></p><p>中断隐指令，就是机器指令系统中没有的指令，它是CPU在中断周期内由硬件自动完成的。</p><h3 id="保护现场和恢复现场"><a href="#保护现场和恢复现场" class="headerlink" title="保护现场和恢复现场"></a>保护现场和恢复现场</h3><p>保护现场包括保护程序断点和保护CPU内部个寄存器的内容。断点通过中断隐指令完成，寄存器内容可以通过中断服务程序完成。</p><h3 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h3><p>中断屏蔽技术主要用于多重中断。</p><h4 id="多重中断的概念"><a href="#多重中断的概念" class="headerlink" title="多重中断的概念"></a>多重中断的概念</h4><p>多重中断就是在一个中断服务程序正在执行时，另一个中断请求提出了中断。</p><h4 id="实现多重中断的条件"><a href="#实现多重中断的条件" class="headerlink" title="实现多重中断的条件"></a>实现多重中断的条件</h4><p><img src="/../images/image-20230403104828849.png" alt="image-20230403104828849"></p><p>（1）提前设置开中断指令</p><p>因为CPU进入中断，隐指令会自动执行关指令，所以需要开指令接受中断请求。</p><p>（2）优先级高的中断源有权中断优先级低的中断源</p><p><img src="/../images/image-20230403105053164.png" alt="image-20230403105053164"></p><h4 id="屏蔽技术"><a href="#屏蔽技术" class="headerlink" title="屏蔽技术"></a>屏蔽技术</h4><p>（1）屏蔽触发器与屏蔽字</p><p>当中断源被屏蔽时（MASK=1）即使D=1，INTR只能置为0。</p><p><img src="/../images/image-20230403105412363.png" alt="image-20230403105412363"></p><p>（2）屏蔽技术可以改变优先级</p><p><img src="/../images/image-20230403105432202.png" alt="image-20230403105432202"></p><p>（3）屏蔽技术的其他作用</p><p>可以人为屏蔽某个中断源的请求以达到机器运行正常。</p><h4 id="多重断点的断点保护"><a href="#多重断点的断点保护" class="headerlink" title="多重断点的断点保护"></a>多重断点的断点保护</h4><p>（1）断点保存在堆栈中</p><p>（2）断点保存在特定存储单元中</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指令系统</title>
    <link href="/2024/02/01/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/02/01/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><blockquote><p>  什么是机器指令，指令系统又是什么？</p></blockquote><p>人们把机器语言的语句叫做机器指令，把这些指令集合叫做指令系统。</p><h3 id="指令的一般格式"><a href="#指令的一般格式" class="headerlink" title="指令的一般格式"></a>指令的一般格式</h3><p>指令是由<strong>操作码</strong>和<strong>地址码</strong>两部分组成的。（都是通过二进制描述）</p><h4 id="1、操作码"><a href="#1、操作码" class="headerlink" title="1、操作码"></a><strong>1、操作码</strong></h4><ul><li>  操作码是用来说明这条指令是用来完成什么样的操作的。</li><li>  操作长度可以是固定的也可以是变化的。如果是固定的，便于硬件的设计，指令译码时间短，广泛运用于字长较长的计算机，如RISC。</li><li>  如果是不固定的，可以有效的压缩操作码的平均长度，在字长较短的微型计算机中方广泛运用。操作码不固定会增加指令译码和分析的难度，使得控制器的设计复杂，通常使用扩展操作码技术使操作码的长度随着地址数的减少而增加。也就是不同的地址数可以有不同的操作数，从而有效缩短指令字长。</li></ul><p><img src="/../images/image-20230326104921193.png" alt="image-20230326104921193"></p><p>上图分析：</p><ul><li>  如果操作码是4位，最多有15条三地址指令，如果操作码是8位，最多有15条二地址指令；如果操作码是12位，最多有15条1地址指令。</li><li>  三地址操作码每减少一种就可以多构造2^4种二地址操作码。可以看到如果操作码是8位时，1111被作为前四位的固定操作码，因为1111相当于是三地址码分给二地址码。</li></ul><h4 id="2、地址码"><a href="#2、地址码" class="headerlink" title="2、地址码"></a>2、地址码</h4><p>地址码是用来保存该指令的源操作数的地址。</p><p>（下列指令都假设指令字长为32位。操作码固定为8位）</p><h5 id="（1）四地址指令"><a href="#（1）四地址指令" class="headerlink" title="（1）四地址指令"></a>（1）四地址指令</h5><p><img src="/../images/image-20230326110522933.png" alt="image-20230326110522933"></p><p>OP是操作数，A1是第一操作数地址，A2是第二操作数地址，A3是结果地址，A4是下一条指令地址。</p><p>该指令完成<img src="../../../../../相册/typora/image-20230326110715358.png" alt="image-20230326110715358" style="zoom:67%;" />的操作。如果地址字段均指示主存的地址，则完成一条四地址指令，共需要访问4次存储器。寻址范围<img src="../../../../../相册/typora/image-20230326122031552.png" alt="image-20230326122031552" style="zoom:67%;" />。</p><h5 id="（2）三地址指令"><a href="#（2）三地址指令" class="headerlink" title="（2）三地址指令"></a>（2）三地址指令</h5><p><img src="/../images/image-20230326121334314.png" alt="image-20230326121334314"></p><p>完成<img src="../../../../../相册/typora/image-20230326121354765.png" alt="image-20230326121354765" style="zoom:67%;" />指令，原来下一条指令地址利用PC去记录。完成一次指令需要访问4次存储器。寻址范围<img src="../../../../../相册/typora/image-20230326122112816.png" alt="image-20230326122112816" style="zoom:67%;" />。</p><h5 id="（3）二地址指令"><a href="#（3）二地址指令" class="headerlink" title="（3）二地址指令"></a>（3）二地址指令</h5><p><img src="/../images/image-20230326121516902.png" alt="image-20230326121516902"></p><p>完成<img src="../../../../../相册/typora/image-20230326121530791.png" alt="image-20230326121530791" style="zoom:67%;" />指令，A1表示第一个操作数，A2表示第二操作数，二地址指令取消了A3地址保存结果，而是采用把结果覆盖到A1或者A2中。完成一次指令仍需要访问4次存储器。但是如果把结果保存在ACC中，就只需要3次访存就可以。寻址范围<img src="../../../../../相册/typora/image-20230326122142565.png" alt="image-20230326122142565" style="zoom:67%;" />。</p><h5 id="（4）一地址指令"><a href="#（4）一地址指令" class="headerlink" title="（4）一地址指令"></a>（4）一地址指令</h5><p><img src="/../images/image-20230326121847103.png" alt="image-20230326121847103"></p><p>完成<img src="../../../../../相册/typora/image-20230326122202153.png" alt="image-20230326122202153" style="zoom:67%;" />指令操作。ACC参与存储和运算操作数，完成一条指令只需要2次访存。寻址范围<img src="../../../../../相册/typora/image-20230326122327067.png" alt="image-20230326122327067" style="zoom:67%;" />。</p><h5 id="（5）零地址指令"><a href="#（5）零地址指令" class="headerlink" title="（5）零地址指令"></a>（5）零地址指令</h5><p>指令中没有地址码，例如，空操作、停机、子程序返回、中断返回等。</p><h3 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h3><p>指令字长取决于操作码长度、操作数地址长度、操作数地址个数。指令字长固定：指令字长=存储字长。指令字长可变：按字节的倍数变化。</p><h2 id="操作数类型和操作类型"><a href="#操作数类型和操作类型" class="headerlink" title="操作数类型和操作类型"></a>操作数类型和操作类型</h2><h3 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h3><p>常见的操作数类型有地址、数字、字符、逻辑数据等。</p><p>（1）地址</p><p>地址就是无符号的整数。</p><p>（2）数字</p><p>包含定点数、浮点数、十进制数。</p><p>（3）字符</p><p>通常采用ACSⅡ码。</p><p>（4）逻辑数据</p><p>用于逻辑运算。</p><h3 id="数据在存储器中的存放方式"><a href="#数据在存储器中的存放方式" class="headerlink" title="数据在存储器中的存放方式"></a>数据在存储器中的存放方式</h3><p><strong>1、从任意位置开始存储</strong></p><p>优点：不浪费存储资源。</p><p>缺点：除了访问一个字节之外，访问其它任何类型的数据， 都可能花费两个存储周期的时间。读写控制比较复杂。</p><p><strong>2、从一个存储字的起始位置开始访问</strong></p><p>优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。</p><p>缺点：浪费存储资源。</p><p><strong>3、边界对准方式</strong></p><p>从地址的整数倍位置开始访问。</p><h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><p><strong>1、数据传送</strong></p><p>数据传送就是各种元器件之间的数据交互，例如寄存器与寄存器之间、寄存器与存储单元之间、存储单元与存储单元之间。</p><p><strong>2、算术逻辑操作</strong></p><p>加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算 与、或、非、异或、位操作、位测试、位清除、位求反</p><p><strong>3、移位</strong></p><p>分为算术移位、逻辑移位、循环移位。算术移位是对有符号的数操作，逻辑是无符号的数。</p><p><strong>4、转移</strong></p><p><strong>（1）无条件转移</strong></p><p>不受约束，如“JMP X”。</p><p><strong>（2）条件转移</strong></p><p>根据当前指令执行结果来决定是否需要转移。</p><img src="../../../../../相册/typora/image-20230326124216225.png" alt="image-20230326124216225" style="zoom:67%;" /><p><strong>（3）调用和返回</strong></p><p>需要重复利用同一个程序段时，将这个程序段设定为独立子程序，调用（CALL）和返回指令（RETURN）配合使用。</p><p><strong>（4）陷阱与陷阱指令</strong></p><ul><li>  一般不提供给用户直接使用 在出现事故时，由 CPU 自动产生并执行（隐指令）</li><li>  设置供用户使用的陷阱指令</li></ul><p><strong>（5）输入输出</strong></p><p>端口中的内容读入到CPU 的寄存器、CPU 的寄存器输出到端口中的内容。</p><p><strong>（6）其他</strong></p><p>等待指令、停机指令、空操作指令、开中断指令等。</p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>寻址方式就是确定本指令的数据地址以及下一跳指令地址的方法。寻址方式分为<strong>指令寻址和数据寻址</strong>。</p><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>分为<strong>顺序寻址</strong>和<strong>跳跃寻址</strong>。</p><p>1、顺序寻址</p><p>通过PC程序计数器自动加一形成下一条的地址。</p><p>2、跳跃寻址</p><p>当例如指令中是“JMP 7”，就直接跳到第7条指令。</p><h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><p>数据寻址的地址由下面几部分组成。操作数的有效地址记为EA，是由寻址特征和形式地址共同决定的。</p><p><img src="/../images/image-20230326125309276.png" alt="image-20230326125309276"></p><h4 id="1、立即寻址"><a href="#1、立即寻址" class="headerlink" title="1、立即寻址"></a>1、立即寻址</h4><p><img src="/../images/image-20230326125508622.png" alt="image-20230326125508622"></p><p>操作数就在指令字里，A就是操作数本身，不是地址。数据采用补码的形式存放。优点是只要取指令就有操作数，在执行阶段不必访问存储器。A的位数限制立即数的范围。</p><h4 id="2、直接寻址"><a href="#2、直接寻址" class="headerlink" title="2、直接寻址"></a>2、直接寻址</h4><p><img src="/../images/image-20230326125830548.png" alt="image-20230326125830548"></p><p>直接寻址中指令字中的形式地址A就是操作数的真实地址EA。优点是寻找操作数简单，在指令执行时对主存访问一次。但是它的缺点是限制了操作数的寻址范围。而且必须修改A的值才可以修改操作数的地址。</p><h4 id="3、隐含寻址"><a href="#3、隐含寻址" class="headerlink" title="3、隐含寻址"></a>3、隐含寻址</h4><p><img src="/../images/image-20230326182319815.png" alt="image-20230326182319815"></p><p>其操作数地址隐含在操作码中或者某个寄存器中，这导致指令字中少了一个地址字段，可以缩短指令字长。</p><h4 id="4、间接寻址"><a href="#4、间接寻址" class="headerlink" title="4、间接寻址"></a>4、间接寻址</h4><p><img src="/../images/image-20230326182636448.png" alt="image-20230326182636448"></p><p>间接寻址不直接将操作数的地址存在A中，而是指出操作数有效地址所在的存储单元地址。有效地址是通过形式地址间接提供的，注意这里的存储器都是主存，之后会有存储在寄存器上的。</p><p><strong>优点：</strong></p><ul><li>  这种寻址和直接寻址相比，扩大了寻址范围。当多次间接寻址时，可以用存储字的首位来标记间接寻址是否结束。</li><li>  便于编制程序。</li></ul><p><strong>缺点：</strong></p><ul><li>  指令执行时需要两次访问主存。会导致执行时间过长。</li></ul><h4 id="5、寄存器寻址"><a href="#5、寄存器寻址" class="headerlink" title="5、寄存器寻址"></a>5、寄存器寻址</h4><p><img src="/../images/image-20230326183322889.png" alt="image-20230326183322889"></p><p>地址码直接指出了寄存器的编号，EA=R，由于寄存器寻址在执行过程中不用访问主存，所以执行速度快。同时，指令字段短，节省了存储空间。</p><h4 id="6、寄存器间接寻址"><a href="#6、寄存器间接寻址" class="headerlink" title="6、寄存器间接寻址"></a>6、寄存器间接寻址</h4><p><img src="/../images/image-20230326183553462.png" alt="image-20230326183553462"></p><p>指令执行阶段需要访存主存。有效地址在寄存器中，操作数在主存中。它比间接寻址少访存一次。</p><h4 id="7、基址寻址"><a href="#7、基址寻址" class="headerlink" title="7、基址寻址"></a>7、基址寻址</h4><p><img src="/../images/image-20230326183949826.png" alt="image-20230326183949826"></p><p>基址寻址需要设有基址寄存器（BR），操作数有效地址为指令字中的形式地址与基址寄存器中的内容相加。基址寄存器分为隐式和显式。</p><p>（1）采用专用基址寄存器</p><p><img src="/../images/image-20230326183823365.png" alt="image-20230326183823365"></p><ul><li>  可以扩大寻址范围</li><li>  有利于多道程序</li><li>  BR内容由操作系统或者管理程序确定</li><li>  在程序执行的过程中，BR不变，A可以变。</li></ul><p>（2）采用通用寄存器。</p><p><img src="/../images/image-20230326184237541.png" alt="image-20230326184237541"></p><ul><li>  由用户指定哪个通用寄存器作为基址寄存器</li><li>  基址寄存器的内容由操作系统确定</li><li>  在程序执行过程中，R内容不变，A可变。</li></ul><h4 id="8、变址寻址"><a href="#8、变址寻址" class="headerlink" title="8、变址寻址"></a>8、变址寻址</h4><p>变址寻址和基址寻址非常相似。</p><p><img src="/../images/image-20230326184653005.png" alt="image-20230326184653005"></p><p><img src="/../images/image-20230326184703278.png" alt="image-20230326184703278"></p><p>由于两者的应用场景不同，来区别：</p><ul><li>  IX 的内容由用户给定</li><li>  在程序的执行过程中 IX 内容可变，形式地址 A 不变</li><li>  和基址寻址相比，基址寻址主要是用来为程序或者数据分配存储空间。而变址寻址主要是处理数组问题。</li></ul><h4 id="9、相对寻址"><a href="#9、相对寻址" class="headerlink" title="9、相对寻址"></a>9、相对寻址</h4><p><img src="/../images/image-20230326185302358.png" alt="image-20230326185302358"></p><p><img src="/../images/image-20230326185251358.png" alt="image-20230326185251358"></p><p>相对寻址的有效地址是程序计数器PC和形式地址A相加而成。A是相对于当前指令的位移量。A可正可负，通常用补码表示。相对寻址常被用来转移类指令。</p><p>最大特点是转移地址不固定，对于编写浮动程序有利。A的位数决定操作数的寻址范围。</p><h4 id="10、堆栈寻址"><a href="#10、堆栈寻址" class="headerlink" title="10、堆栈寻址"></a>10、堆栈寻址</h4><p><img src="/../images/image-20230326185801822.png" alt="image-20230326185801822"></p><p><img src="/../images/image-20230326185815873.png" alt="image-20230326185815873"></p><h2 id="指令格式举例"><a href="#指令格式举例" class="headerlink" title="指令格式举例"></a>指令格式举例</h2><p>指令格式这一节主要讲设计指令时需要考虑的各种因素，并且举例一些设计相对来说合理的格式。</p><h3 id="设计格式需要考虑的因素"><a href="#设计格式需要考虑的因素" class="headerlink" title="设计格式需要考虑的因素"></a>设计格式需要考虑的因素</h3><p>指令系统集中反映了机器的性能，一个好的指令系统既需要指令丰富，又需要机器执行程序时快速、占用空间小、搞笑。并且指令系统需要考虑向上兼容，也就是高版本需要兼容低版本。</p><p>指令格式可以从以下几个方面考虑：</p><ul><li>  操作类型</li><li>  数据类型</li><li>  指令格式</li><li>  寻址方式</li><li>  寄存器个数</li></ul><h3 id="指令格式举例-1"><a href="#指令格式举例-1" class="headerlink" title="指令格式举例"></a>指令格式举例</h3><h4 id="1、PDP-8"><a href="#1、PDP-8" class="headerlink" title="1、PDP-8"></a>1、PDP-8</h4><p>指令字长：12位，CPU中只设置一个通用寄存器ACC,其主存分为若干个容量相同的存储空间。支持间接寻址、变址寻址、相对寻址。加上操作码扩展技术。共有35条指令。</p><h4 id="2、PDP-11"><a href="#2、PDP-11" class="headerlink" title="2、PDP-11"></a>2、PDP-11</h4><p>机器字长16位，CPU内设8个16位通用寄存器，其中两寄存器有特殊作用，一个用作堆栈指针SP，一个用作程序计数器PC。</p><h4 id="3、IBM360"><a href="#3、IBM360" class="headerlink" title="3、IBM360"></a>3、IBM360</h4><p>IBM360属于系统机，也就是基本指令系统相同的一系列机子。机器字长32位，CPU中16个32位通用寄存器（用户可以任选一个作为基址寄存器BR或者变址寄存器IX），4个双精度（64位）浮点寄存器。</p><h4 id="4、Intel8086"><a href="#4、Intel8086" class="headerlink" title="4、Intel8086"></a>4、Intel8086</h4><p>这款机器是微型计算机，指令字长是1-6字节，不定长。</p><h3 id="指令格式设计举例"><a href="#指令格式设计举例" class="headerlink" title="指令格式设计举例"></a>指令格式设计举例</h3><h2 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h2><p>RISC即为精简指令系统计算机（Reduced Instruction Set Computer）。</p><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>因为当时20世纪70年代中期，发现典型程序中 80% 的语句仅仅使用处理机中 20% 的指令；执行频度高的简单指令，因复杂指令的存在，执行速度无法提高；能否用 20% 的简单指令组合不常用的 80% 的指令功能。于是就引出了RISC技术。</p><h3 id="RISC的主要特征"><a href="#RISC的主要特征" class="headerlink" title="RISC的主要特征"></a>RISC的主要特征</h3><ul><li>  用使用频率高的简单指令组合成为复杂指令。</li><li>  指令长度固定、指令格式种类少、寻址方式少。</li><li>  只有取数（LOAD）存数（STORE）指令访存。</li><li>  CPU中有多个通用寄存器</li><li>  采用流水线技术，一个时钟周期内完成一条指令。</li><li>  控制器采用组合逻辑控制，不作微程序控制。</li><li>  采用优化的编译程序。</li></ul><h3 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h3><ul><li><p>  系统指令复杂庞大，各种指令使用频度相差大 </p></li><li><p>  指令长度不固定、指令格式种类多、寻址方式多 </p></li><li><p>  访存指令不受限制 </p></li><li><p>  大多数指令需要多个时钟周期执行完毕 </p></li><li><p>  采用微程序控制器 </p></li><li><p>  CPU中设有专用寄存器</p></li></ul><h3 id="RISC和CISC的比较"><a href="#RISC和CISC的比较" class="headerlink" title="RISC和CISC的比较"></a>RISC和CISC的比较</h3><p>1、充分利用了VLSI芯片的面积</p><p>2、提高计算机运行速度</p><p>3、便于设计、可降低成本、提高可靠性</p><p>4、有效支持高级语言程序</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机运算方法</title>
    <link href="/2024/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <url>/2024/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机的运算方法"><a href="#计算机的运算方法" class="headerlink" title="计算机的运算方法"></a>计算机的运算方法</h1><p><img src="/../images/image-20230321121954693.png" alt="image-20230321121954693"></p><h2 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h2><p>计算机中参与运算的主要的数主要有两大类：无符号数和有符号数。</p><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>计算机中的数通常是存储在寄存器上的，寄存器的位数就是机器字长。当机器字长相同时，无符号数和有符号数的数值范围是不一样的。因为有符号数有一位存储符号。</p><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><p>对于有符号数，用0代表正数，1代表负数。</p><h4 id="1、机器数和真数"><a href="#1、机器数和真数" class="headerlink" title="1、机器数和真数"></a>1、机器数和真数</h4><p><img src="/../images/image-20230321122502777.png" alt="image-20230321122502777"></p><h4 id="2、原码表示法"><a href="#2、原码表示法" class="headerlink" title="2、原码表示法"></a>2、原码表示法</h4><p>（1）整数原码</p><p>整数的符号位和数值位之间用逗号分隔，小数的符号位与数值位之间用小数点分隔。</p><p><strong>定义</strong>：</p><p><img src="/../images/image-20230321122742699.png" alt="image-20230321122742699"></p><p>X为真数，n为整数的位数。</p><p><strong>例子：</strong></p><p><img src="/../images/image-20230321123058265.png" alt="image-20230321123058265"></p><p><strong>定义：</strong></p><p><img src="/../images/image-20230321123114688.png" alt="image-20230321123114688"></p><p><strong>例子：</strong></p><p><img src="/../images/image-20230321123134014.png" alt="image-20230321123134014"></p><h4 id="3、补码表示法"><a href="#3、补码表示法" class="headerlink" title="3、补码表示法"></a>3、补码表示法</h4><p>（1）补数，也就是可以理解为周期函数，将负数通过模变成正数。</p><p>补数具有以下性质：</p><ul><li>  一个负数加上 “模” 即得该负数的补数</li><li>  一个正数和一个负数互为补数时，它们绝对值之和即为模。</li><li>  正数的补数就是本身。 </li></ul><p><strong>整数补码定义</strong>：</p><p><img src="/../images/image-20230321124019066.png" alt="image-20230321124019066"></p><p><img src="/../images/image-20230321124039266.png" alt="image-20230321124039266"></p><p><strong>小数补码定义：</strong></p><p><img src="/../images/image-20230321124117542.png" alt="image-20230321124117542"></p><p>在求解补码时，利用快捷计算方法：</p><ul><li><p>  当真值为负时，补码可以用原码除符号位外每位取反，末位加1求得。</p></li><li><p>  当真值为负时，原码可用补码除符号位外每位取反，末位加1求得。</p></li></ul><h4 id="4、反码表示法"><a href="#4、反码表示法" class="headerlink" title="4、反码表示法"></a>4、反码表示法</h4><p><strong>整数反码定义：</strong></p><p><img src="/../images/image-20230321124408916.png" alt="image-20230321124408916"></p><p><img src="/../images/image-20230321124442655.png" alt="image-20230321124442655"></p><p><strong>小数反码定义：</strong></p><p><img src="/../images/image-20230321124533830.png" alt="image-20230321124533830"></p><p><img src="/../images/image-20230321124540105.png" alt="image-20230321124540105"></p><p><img src="/../images/image-20230321124602068.png" alt="image-20230321124602068"></p><h4 id="三种机器数的总结"><a href="#三种机器数的总结" class="headerlink" title="三种机器数的总结"></a>三种机器数的总结</h4><ul><li>  最高位为符号位，书写上用“,”（整数） 或“.”（小数）将数值部分和符号位隔开。</li><li>  对于正数，原码 = 补码 = 反码</li><li>  对于负数 ，符号位为 1，其 数值部分 ，原码除符号位外每位取反末位加 1 补码 原码，除符号位外每位取反-&gt;反码。</li></ul><h4 id="5、移码表示法"><a href="#5、移码表示法" class="headerlink" title="5、移码表示法"></a>5、移码表示法</h4><p>定义：</p><p><img src="/../images/image-20230321124751218.png" alt="image-20230321124751218"></p><p><img src="/../images/image-20230321132536559.png" alt="image-20230321132536559"></p><p>补码与移码只差一个符号位</p><h2 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h2><h3 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h3><p>机器处理的数不是纯小数或者纯整数时，必须乘上一个比例因子，否则就会产生”溢出”。</p><h3 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h3><p><strong>为什么要浮点数：</strong></p><ul><li>  编程困难，程序员要调节小数点的位置。</li><li>  数的表示范围小，为了能表示两个大小 相差很大的数据，需要很长的机器字长；</li><li>  数据存储单元的利用率往往很低。</li></ul><p>我的看法就是浮点数就是科学计数法，可以节省空间，并且不需要调节小数点的位置。</p><p>浮点数的一般表示形式：</p><p><img src="/../images/image-20230321133922675.png" alt="image-20230321133922675"></p><p>S是尾数是小数，可正可负；r是尾数的基值；j是阶码，可正可负。</p><h4 id="1、表示形式"><a href="#1、表示形式" class="headerlink" title="1、表示形式"></a>1、表示形式</h4><p><img src="/../images/image-20230321134158801.png" alt="image-20230321134158801"></p><p><img src="/../images/image-20230321134205527.png" alt="image-20230321134205527"></p><h4 id="2、浮点数的表示范围"><a href="#2、浮点数的表示范围" class="headerlink" title="2、浮点数的表示范围"></a>2、浮点数的表示范围</h4><p><img src="/../images/image-20230321134358626.png" alt="image-20230321134358626"></p><p>设阶码取m位，尾数的数值拉取n位。</p><p>最大正数：<img src="../../../../../相册/typora/image-20230321134512175.png" alt="image-20230321134512175" style="zoom:67%;" /></p><p>最小正数：<img src="../../../../../相册/typora/image-20230321134538013.png" alt="image-20230321134538013" style="zoom:67%;" /></p><p>最大负数：<img src="../../../../../相册/typora/image-20230321134558438.png" alt="image-20230321134558438" style="zoom:67%;" /></p><p>最小负数：<img src="../../../../../相册/typora/image-20230321134624825.png" alt="image-20230321134624825" style="zoom:67%;" /></p><p>上溢：阶码&gt;最大阶码</p><p>下溢：阶码&lt;最小阶码，按照机器零处理。</p><h4 id="3、浮点数的规格化形式"><a href="#3、浮点数的规格化形式" class="headerlink" title="3、浮点数的规格化形式"></a>3、浮点数的规格化形式</h4><p>规格化的过程是根据不同的基数，确定不同的规格化形式。</p><p>当基数为2时，尾数最高位为1。</p><p>当基数为4时，尾数最高两位不全为0</p><p>当基数为8时，尾数最高 3 位不全为 0</p><h4 id="4、浮点数的规格化"><a href="#4、浮点数的规格化" class="headerlink" title="4、浮点数的规格化"></a>4、浮点数的规格化</h4><p><img src="/../images/image-20230321140033472.png" alt="image-20230321140033472"></p><p>基数 r 越大，可表示的浮点数的范围越大。基数 r 越大，浮点数的精度降低。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="/../images/image-20230321140143072.png" alt="image-20230321140143072"></p><h3 id="IEEE-754-标准（待补充）"><a href="#IEEE-754-标准（待补充）" class="headerlink" title="IEEE 754 标准（待补充）"></a>IEEE 754 标准（待补充）</h3><p>现代计算机中，浮点数一般采用IEEE标准。</p><p><img src="/../images/image-20230321140305960.png" alt="image-20230321140305960"></p><p>尾数为规格化表示</p><p><img src="/../images/image-20230321140339383.png" alt="image-20230321140339383"></p><h2 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h2><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>在计算机中，移位是相对于小数点的，左移导致绝对值变大，右移导致绝对值缩小。通过移位和加减配合，能够实现乘除运算。</p><p><strong>算术移位规则：</strong></p><p><img src="/../images/image-20230322110026202.png" alt="image-20230322110026202"></p><ul><li>  机器数为正时，不论左移还是右移，填补的代码都是0；</li></ul><p><strong>例题：</strong></p><p><img src="/../images/image-20230322110917986.png" alt="image-20230322110917986"></p><p><img src="/../images/image-20230322110931223.png" alt="image-20230322110931223"></p><p><img src="/../images/image-20230322110942437.png" alt="image-20230322110942437"></p><h4 id="逻辑移位和算术移位的区别"><a href="#逻辑移位和算术移位的区别" class="headerlink" title="逻辑移位和算术移位的区别"></a>逻辑移位和算术移位的区别</h4><p>（1）逻辑移位</p><p>无符号的移位，逻辑左移，低位置为0，高位丢失。逻辑右移，高位添0，低位丢失</p><p>（2）算术移位</p><p>有符号数的移位，高位为符号位，保持不变。</p><h3 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h3><p>采用补码加减法运算。</p><p><img src="/../images/image-20230322111436000.png" alt="image-20230322111436000"></p><p><img src="/../images/image-20230322111443137.png" alt="image-20230322111443137"></p><p>连同符号位一起相加，符号位产生的进位自然丢掉</p><p><strong>注意：</strong>[-B]补由[B]补连同符号位一起，每位取反，末尾加1。需要注意的是在计算结束以后，需要对结果进行mod计算。</p><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><p>（1）用一位符号位判断溢出</p><p>参加操作的 两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。</p><p><strong>硬件实现：</strong></p><p>最高有效位的进位 （异或处理）符号位的进位 = 1</p><p><img src="/../images/image-20230322111959636.png" alt="image-20230322111959636"></p><p>（2）用两位符号位判断溢出</p><p><img src="/../images/image-20230322112012600.png" alt="image-20230322112012600"></p><p>结果的双符号位 相同——未溢出</p><p>结果的双符号位不同——溢出</p><p>最高符号位代表真正的符号。</p><p>采用双符号方案时，寄存器或者主存中操作数就保存一位就可以，因为任何正确的数，两个符号位的值是相同的。</p><h4 id="补码加减法的硬件配置"><a href="#补码加减法的硬件配置" class="headerlink" title="补码加减法的硬件配置"></a>补码加减法的硬件配置</h4><p><img src="/../images/image-20230322112157000.png" alt="image-20230322112157000"></p><h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><p><strong>改进后的笔算乘法过程：</strong></p><p><img src="/../images/image-20230322112433077.png" alt="image-20230322112433077"></p><p>上述的运算过程可以总结为：</p><ul><li>  乘法运算可用移位和加法来实现，两个n位数相乘需要4次加法和4次移位。</li><li>  由乘数的末位来确定被乘数是否要和部分积相加，然后相加的结果和乘数同时进行逻辑右移1位，乘数的末位去除，高位是部分积的末位。</li><li>  被乘数只与部分积的高位相加</li></ul><h4 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h4><p>(1) 原码一位乘运算规则</p><p><img src="/../images/image-20230322113341429.png" alt="image-20230322113341429"></p><p><img src="/../images/image-20230322113440043.png" alt="image-20230322113440043"></p><p><img src="/../images/image-20230322113530825.png" alt="image-20230322113530825"></p><p>原码一位乘运算就是乘法运算。</p><p><strong>硬件配置：</strong></p><p><img src="/../images/image-20230322113611467.png" alt="image-20230322113611467"></p><h4 id="补码乘法（待补充）"><a href="#补码乘法（待补充）" class="headerlink" title="补码乘法（待补充）"></a>补码乘法（待补充）</h4><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p><img src="/../images/image-20230322114652019.png" alt="image-20230322114652019"></p><h4 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h4><p><img src="/../images/image-20230322114710617.png" alt="image-20230322114710617"></p><p><img src="/../images/image-20230322114720356.png" alt="image-20230322114720356"></p><h5 id="（1）恢复余数法"><a href="#（1）恢复余数法" class="headerlink" title="（1）恢复余数法"></a>（1）恢复余数法</h5><p>也就是当余数为负数的时候就要回复余数，下面会详细讲解。</p><p><strong>直接看例题：</strong></p><p><img src="/../images/image-20230322114835432.png" alt="image-20230322114835432"></p><p><img src="/../images/image-20230322114848579.png" alt="image-20230322114848579"></p><p><strong>分析以上的算术规则就是：</strong></p><p><img src="/../images/image-20230322114940781.png" alt="image-20230322114940781"></p><ul><li>  注意的是被除数和商是同时逻辑左移的。</li><li>  总结算法：余数为负，上商0，加上除数恢复余数（注意不用左移）。余数为正，上商1，左移一位，减去除数。左移n次退出。</li><li>  第一次上的商在商的整数位上，如果该位为1，表示除法溢出，反之。</li></ul><h5 id="（2）加减交替法"><a href="#（2）加减交替法" class="headerlink" title="（2）加减交替法"></a>（2）加减交替法</h5><p><img src="/../images/image-20230322115838944.png" alt="image-20230322115838944"></p><p><strong>直接看例题：</strong></p><p><img src="/../images/image-20230322115859734.png" alt="image-20230322115859734"></p><p><img src="/../images/image-20230322120109135.png" alt="image-20230322120109135"></p><p><strong>硬件配置：</strong></p><p><img src="/../images/image-20230322120140584.png" alt="image-20230322120140584"></p><h2 id="浮点四则运算"><a href="#浮点四则运算" class="headerlink" title="浮点四则运算"></a>浮点四则运算</h2><p><img src="/../images/image-20230323094311912.png" alt="image-20230323094311912"></p><p>浮点数尾数部分和定点加减运算相同，但是因为阶码不等，影响实际的小数位置，为此，浮点数加减的运算规则是：</p><ol><li> 对阶 </li><li> 尾数求和 </li><li> 规格化 </li><li> 舍入 </li><li> 溢出判断</li></ol><h3 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h3><p>对阶就是将两个操作数的小数点位置对齐。</p><p>（1）求阶差</p><p><img src="/../images/image-20230323094749970.png" alt="image-20230323094749970"></p><p>求阶差可以使用补码求法，求出来的补码再将其转换成原码，也就是除了符号位其余的数取反，最后一位数加1。下面的例子是假设阶数符号位2位。</p><p>（2）对阶原则</p><p>小阶向大阶看齐。使阶数小的尾数向右移动，每右移一位，阶码加1，知道两个阶码相同，右移次数就是阶码差。但是<strong>阶数右移会出现精度丢失</strong>，之后会进行舍入操作。</p><p>（3）例子</p><p><img src="/../images/image-20230323095141120.png" alt="image-20230323095141120"></p><h3 id="尾数求和"><a href="#尾数求和" class="headerlink" title="尾数求和"></a>尾数求和</h3><p>接上一个例子：</p><p>如果是减法就看成加上这个数的负数的补码。</p><p><img src="/../images/image-20230323095214220.png" alt="image-20230323095214220"></p><h3 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h3><p><strong>定义：</strong></p><p><img src="/../images/image-20230323100319048.png" alt="image-20230323100319048"></p><p><strong>判断：</strong></p><p><img src="/../images/image-20230323100346022.png" alt="image-20230323100346022"></p><p>原码——不论正数、负数，第一数位为1。</p><p>补码——符号位和第一数位不同。</p><p><strong>特例：</strong></p><p><img src="/../images/image-20230323100546047.png" alt="image-20230323100546047"></p><p><img src="/../images/image-20230323100551260.png" alt="image-20230323100551260"></p><h3 id="左规"><a href="#左规" class="headerlink" title="左规"></a>左规</h3><p>当尾数出现00.0XXXX或者11.1XXXXX需要左规。</p><p><strong>定义</strong>：</p><p>尾数左移一位，阶码减 1，直到数符和第一数位不同为止。</p><h3 id="右规"><a href="#右规" class="headerlink" title="右规"></a>右规</h3><p>当出现01.XXXXX或者10.XXXX，表示尾数溢出，需要右规。</p><blockquote><p>  这在定点数中是不允许的，但是浮点运算中这不算溢出，可以通过右规处理。</p></blockquote><p><strong>定义：</strong></p><p>尾数右移一位，阶码加 1。</p><h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>在 <strong>对阶</strong> 和 <strong>右规</strong> 过程中，可能出现<strong>尾数末位丢失</strong>引起误差，需考虑舍入。</p><p>（1）0舍1入法</p><p><strong>定义：</strong></p><p>尾数右移时，被移除的最高数是0，舍去，如果被移去的最高数值是1，则在尾数的末尾加1。</p><p>（2）恒置1法</p><p>右移时不论舍去最高位是什么，都将尾数末尾置为1。</p><h3 id="溢出判断-1"><a href="#溢出判断-1" class="headerlink" title="溢出判断"></a>溢出判断</h3><p><img src="/../images/image-20230323101712444.png" alt="image-20230323101712444"></p><h2 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h2><h3 id="ALU电路"><a href="#ALU电路" class="headerlink" title="ALU电路"></a>ALU电路</h3><p><img src="/../images/image-20230323101809601.png" alt="image-20230323101809601"></p><p>AB是输入变量，k是控制信号，F是输出函数。</p><h3 id="快速进位链"><a href="#快速进位链" class="headerlink" title="快速进位链"></a>快速进位链</h3><ol><li> <strong>并行加法器</strong></li></ol><p><img src="/../images/image-20230323102136534.png" alt="image-20230323102136534"></p><p>由于每个全加器的进位输出是高一位的全加器的进位输入，所以这种一级一级的进位过程会导致运算速度降低。</p><ol start="2"><li> <strong>串行进位链</strong></li></ol><p>以 4 位全加器为例，每一位的进位表达式为：</p><p><img src="/../images/image-20230323102505126.png" alt="image-20230323102505126"></p><p>4位全加器产生进位全部时间是8t。</p><p>n位时间是2nt。</p><ol start="3"><li> <strong>并行进位链</strong>（先行进位，跳跃进位）</li></ol><p><img src="/../images/image-20230323102712566.png" alt="image-20230323102712566"></p><p><strong>（1）单重分组跳跃进位链</strong></p><p>n 位全加器分若干小组，小组中的进位同时产生， 小组与小组之间采用串行进位。</p><p>以<strong>n=16</strong>为例：</p><p><img src="/../images/image-20230323102832391.png" alt="image-20230323102832391"></p><p><strong>（2）双重分组跳跃进位链</strong>(待补充)</p><p>n 位全加器分若干大组，大组中又包含若干 小组。每个大组中小组的最高位进位同时产生。 大组与大组之间采用串行进位。</p><p>以<strong>n=32</strong>为例：</p><p><img src="/../images/image-20230323103015191.png" alt="image-20230323103015191"></p><p><img src="/../images/image-20230323103022867.png" alt="image-20230323103022867"></p><p><img src="/../images/image-20230323103029641.png" alt="image-20230323103029641"></p><p><img src="/../images/image-20230323103036492.png" alt="image-20230323103036492"></p><p><img src="/../images/image-20230323103045418.png" alt="image-20230323103045418"></p><p><img src="/../images/image-20230323103053529.png" alt="image-20230323103053529"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入输出系统</title>
    <link href="/2024/02/01/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/02/01/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="输入输出系统的发展概况"><a href="#输入输出系统的发展概况" class="headerlink" title="输入输出系统的发展概况"></a>输入输出系统的发展概况</h3><p>发展分为4个阶段：</p><p><strong>1、早期阶段</strong></p><ul><li>  IO设备与主存之间交换信息都必须通过CPU，这个阶段下每个IO设备都需要一套逻辑电路和CPU连接，这样使得线路十分<strong>分散、庞杂</strong>。</li><li>  IO设备与CPU之间是串行方式工作的。</li><li>  更换IO设备非常困难。</li><li>  利用程序查询方式。</li></ul><p><strong>2、接口模块和DMA阶段</strong></p><ul><li>  这个时候采用了总线连接。</li><li>  IO设备之间可以实现并行工作方式</li><li>  通过中断方式交换信息</li><li>  为了提高CPU效率，出现了直接存储器存取（DMA），特点是IO设备与主存之间有一条直接数据通路。</li></ul><p><strong>3、具有通信结构的阶段</strong></p><ul><li>  通道出现的原因是在一些大型的计算机系统中，如果每个IO都配备专门DMA接口，会导致控制变复杂。</li><li>  通道主要负责管理IO设备以及实现主存与IO设备之间交换信息。</li></ul><p><strong>4、具有I/O处理机的阶段</strong></p><h3 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h3><p><strong>1、I/O软件</strong></p><p>（1）I/O指令</p><p><img src="/../images/image-20230314134140015.png" alt="image-20230314134140015"></p><p>是CPU指令的一部分，I/O指令的设备码相当于设备的地址。</p><p>（2）通道指令</p><p>通道指令是对具有通道的IO系统专门设置的指令。IBM370的通道指令为64位。</p><p><strong>2、I/O硬件</strong></p><h3 id="I-O设备与主机的联系方式"><a href="#I-O设备与主机的联系方式" class="headerlink" title="I/O设备与主机的联系方式"></a>I/O设备与主机的联系方式</h3><p><strong>1、IO设备编址方式</strong></p><p>（1）统一编址</p><p>将IO设备看成是存储器地址的一部分。统一编址占用存储空间，减少主存容量，但无需专用的IO指令。</p><p>（2）不统一编址</p><p>IO地址和存储器地址是分开的。不统一编址的特点相反。</p><p><strong>2、设备寻址</strong></p><p>通过IO指令的设备码字段直接指出该设备的设备号。</p><p><strong>3、传送方式</strong></p><p>分为串行传输和并行传输</p><p><strong>4、联络方式</strong></p><p>（1）立即响应方式</p><p>如一些指示灯。</p><p>（2）异步工作采用应答信号联络</p><p>发生场景是当IO设备与主机工作速度不一致时。</p><p><img src="/../images/image-20230314140113190.png" alt="image-20230314140113190"></p><p>（3）同步工作采用同步时标</p><p><strong>5、I/O设备与主机连接方式</strong></p><p>（1）辐射式连接</p><img src="../../../../../相册/typora/image-20230314140248153.png" alt="image-20230314140248153" style="zoom:67%;" /><p>每台设备都有一套控制线路和一组信号线。不便于增删设备。</p><p>（2）总线连接</p><p>便于增删设备。是现代大多数计算机系统使用的。</p><h3 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I/O设备与主机信息传送的控制方式"></a>I/O设备与主机信息传送的控制方式</h3><p><strong>1、程序查询方式</strong></p><p><img src="/../images/image-20230314140511776.png" alt="image-20230314140511776"></p><p>CPU不断查询IO设备是否做好准备。这种方式处于串行工作状态，CPU效率不高。如果IO没有做好准备，CPU会踏步等待。</p><p><strong>2、程序中断方式</strong></p><p><img src="/../images/image-20230314140755727.png" alt="image-20230314140755727"></p><p>CPU启动IO设备后继续执行原程序，当IO设备准备就绪并且发出中断请求时，CPU才响应。</p><p>中断方式流程：</p><p><img src="/../images/image-20230314141021243.png" alt="image-20230314141021243"></p><p><strong>3、DMA 方式</strong></p><ul><li><p>  主存和 I/O 之间有一条直接数据通道 </p></li><li><p>不中断现行程序</p><p>  <img src="/../images/image-20230314141216617.png" alt="image-20230314141216617"></p><p>  CPU和IO并行工作</p></li><li><p>  周期挪用</p></li></ul><p><strong>4、三种方式的 CPU 工作效率比较</strong></p><p><img src="/../images/image-20230314141313718.png" alt="image-20230314141313718"></p><h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/../images/image-20230315091921740.png" alt="image-20230315091921740"></p><p>IO设备大致可以分为三类：</p><ul><li>  人机交互设备：键盘、鼠标。</li><li>  计算机信息的存储设备：磁盘、光盘、磁带等</li><li>  机-机通信设备：调制解调器</li></ul><h3 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h3><p>1、键盘</p><p>键盘的输入信息的步骤：</p><ul><li>  按下一个键</li><li>  判断是哪个键按下</li><li>  将此键翻译成ASCⅡ码。</li></ul><p>2、鼠标</p><ul><li>  机械式：金属球</li><li>  光电式：光电转换器</li></ul><p>3、触摸屏</p><h3 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h3><p>1、显示设备</p><p>CRT是目前应用最广泛发显示器件。既可以字符显示器也可以作为图像、图形显示器。</p><p>显示器设备主要可以分为：字符显示器、图形显示器、图像显示器。</p><p>2、打印机</p><ul><li>  击打式（点阵式）</li><li>  非击打式（逐页打印）</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1、A/D、D/A 模拟/数字转换器</p><p>2、终端，由键盘和显示器组成，完成显示控制与存储、键盘管理及通信控制</p><p>3、汉字处理：汉字输入、汉字存储、汉字输出</p><h3 id="多媒体技术"><a href="#多媒体技术" class="headerlink" title="多媒体技术"></a>多媒体技术</h3><p>多媒体计算机的关键技术：</p><ul><li>  视频和音频数据的压缩与解压技术</li><li>  多媒体转用芯片</li><li>  大容量存储器</li><li>  适用于多媒体系统的软件</li></ul><h2 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>为什么要设置接口？</p><p>1、实现设备的选择 </p><p>2、实现数据缓冲达到速度匹配</p><p>3、实现数据串一并格式转换</p><p>4、实现电平的转换</p><p>5、传送控制命令</p><p>6、反映设备的状态。</p><h3 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h3><p><strong>1、总线连接方式的I/O接口电路</strong></p><p><img src="/../images/image-20230315093829247.png" alt="image-20230315093829247"></p><p>（1）数据线</p><p>IO设备与主机之间的数据交换</p><p>（2）设备选择线</p><p>设备选择线是用来传送设备码的。</p><p>（3）命令线</p><p>传输CPU向设备发出的命令信号。</p><p>（4）状态线</p><p>将IO设备的状态向主机报告。</p><p><strong>2、接口的功能和组成</strong></p><p><strong>功能：</strong></p><p>（1）选址功能</p><p>（2）传送命令功能</p><p>（3）传送数据的功能</p><p>（4）反映IO设备工作状态的功能</p><p><strong>组成：</strong></p><p>（1）设备选择电路</p><p>（2）命令寄存器、命令译码器</p><p>（3）数据缓冲寄存器</p><p>（4）设备状态标记</p><p><img src="/../images/image-20230315095636284.png" alt="image-20230315095636284"></p><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>1、按数据传送方式分类</p><ul><li>  并行接口</li><li>  串行接口</li></ul><p>2、按功能选择的灵活性分类</p><ul><li>  可编程接口</li><li>  不可编程接口</li></ul><p>3、按通用性分类</p><ul><li>  通用接口</li><li>  专用接口</li></ul><p>4、按数据传送的控制方式分类</p><ul><li>  程序型接口</li><li>  DMA型接口</li></ul><h2 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h2><h3 id="程序查询流程"><a href="#程序查询流程" class="headerlink" title="程序查询流程"></a>程序查询流程</h3><p>1、查询流程</p><p>单个设备：</p><p><img src="/../images/image-20230315110430052.png" alt="image-20230315110430052"></p><p>多个设备：</p><p><img src="/../images/image-20230315110536602.png" alt="image-20230315110536602"></p><p>在查询多个设备时，CPU需要按照IO设备的优先级进行查找。程序查找方式让CPU效率变低。</p><p>2、程序流程</p><p><img src="/../images/image-20230315110657465.png" alt="image-20230315110657465"></p><h3 id="程序查询方式的接口电路"><a href="#程序查询方式的接口电路" class="headerlink" title="程序查询方式的接口电路"></a>程序查询方式的接口电路</h3><p><img src="/../images/image-20230315123513597.png" alt="image-20230315123513597"></p><p>该接口的工作流程：</p><p>①CPU通过IO指令启动输入设备，指令的设备码字段就会通过地址线送至设备选择电路。</p><p>②如果该接口的设备码与地址线上的代码吻合，SEL有效。</p><p>③启动命令①使得B置为1，D置为0。</p><p>④由B启动设备</p><p>⑤输入设备将数据送至DBR（数据缓冲寄存器）。</p><p>⑥设备发出设备工作结束，将D置为1，B置为0；</p><p>⑦D通知CPU准备就绪。</p><p>⑧CPU执行输入指令，将数据缓冲寄存器中的数据送至CPU的通用寄存器中，在存入相关单元。</p><h2 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><h3 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h3><p>程序在运行时，遇到异常情况或者特殊请求时，计算机停止现行程序的运行，待处理完突发事务后再返回现行程序的中断处。</p><h3 id="I-O中断的产生"><a href="#I-O中断的产生" class="headerlink" title="I/O中断的产生"></a>I/O中断的产生</h3><p><img src="/../images/image-20230315124840655.png" alt="image-20230315124840655"></p><h3 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h3><p><strong>1、中断请求触发器和中断屏蔽触发器</strong></p><p><img src="/../images/image-20230315125046442.png" alt="image-20230315125046442"></p><p>每台外部设备都必须配备一个中断请求触发器INTR，当为1时，表示有中断请求。在IO设备接口中需要设置一个屏蔽触发器MASK，当为1时，表示被屏蔽。</p><p>总结就是仅当设备准备就绪并且该设备未被屏蔽（MASK=0）时，CPU的中断信号可将中断请求触发器置为1。</p><p><strong>2、排队器</strong></p><p><img src="/../images/image-20230315130156100.png" alt="image-20230315130156100"></p><p>当有多个中断源时，按照中断源的优先级别进行排序。设备优先权可以通过硬件或者软件实现，这里使用的是链式排队器。</p><p>链式排队器的使用规则如下：</p><ul><li>  排队器输出端INTP只有一个高电平。</li><li>  当某个中断源提出中断请求时，迫使比它低的中断源INTP变成低电平。</li><li>  某个中断源有请求时，<img src="../../../../../相册/typora/image-20230315130939717.png" alt="image-20230315130939717" style="zoom:67%;" />为0。</li><li>  当有两个中断源同时请求时，可以通过加上上面两个输入头的与非门，可以保证只有一个输出头是高电平。</li></ul><p><strong>3、中断向量地址形成部件</strong></p><p><img src="../../../../../相册/typora/image-20230315131156556.png" alt="image-20230315131156556"  /><img src="../../../../../相册/typora/image-20230315131203681.png" alt="image-20230315131203681"  /></p><p>发生中断时，需要找到中断请求的程度，也就是要找到入口地址，找到入口地址有软件和硬件方法之分。我们通过硬件向量法寻找向量地址。</p><p>如上面第一幅图，排队器的输出就是向量地址，然后把向量地址去（图二）主存中找到对应的地址，该地址中保留的地址信息就是入口地址。</p><p><strong>4、程序中断方式接口电路的基本组成</strong></p><p><img src="/../images/image-20230315131734873.png" alt="image-20230315131734873"></p><h3 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I/O中断处理过程"></a>I/O中断处理过程</h3><p><strong>1、CPU响应中断的条件和时间</strong></p><p>（1）条件</p><ul><li>  允许中断触发器EINT=1</li><li>  用开中断指令将EINT置为1</li><li>  用关中断指令将EINT置为0或者硬件自动复位。</li></ul><p>（2）时间</p><p>当D=1（随机）且MASK=0时，在每条指令执行阶段的结束前，CPU法中断查询信号（将INTR置为1）</p><p><strong>2、I/O中断处理过程</strong></p><p><img src="/../images/image-20230315132400638.png" alt="image-20230315132400638"></p><h3 id="中断服务程序的流程"><a href="#中断服务程序的流程" class="headerlink" title="中断服务程序的流程"></a>中断服务程序的流程</h3><p><strong>1、中断服务程序的流程</strong></p><p>（1）保护现场</p><ul><li>  保护程序的断点</li><li>  保存通用寄存器和状态寄存器的内容</li><li>  进栈指令</li></ul><p>（2）中断服务</p><p>对不用的IO设备具有不同内容的设备服务。</p><p>（3）恢复现场</p><p>出栈指令</p><p>（4）中断返回</p><p>中断返回指令</p><p><strong>2、单重中断和多重中断</strong></p><p><img src="/../images/image-20230315133019891.png" alt="image-20230315133019891"></p><p><strong>单重中断：</strong>不允许中断现行的中断服务程序  </p><p><strong>多重中断</strong>：允许级别更高的中断源中断现行的中断服务程序</p><h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><h3 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h3><p><img src="/../images/image-20230316155354208.png" alt="image-20230316155354208"></p><blockquote><p>  什么是DMA方式？</p></blockquote><p>主存和DMA接口之间有一条直接通路，在IO设备和主存之间进行信息交换的时候可以不用通过CPU。所以不需要CPU暂停现行程序。适合高速IO设备与主存之间的通信。</p><p>当出现高速IO设备和CPU共享主存，可能导致两者冲突。为了有效避免，我们通过下面3个方式：</p><p><strong>（1）停止CPU访问主存</strong></p><p>当外部设备传输一组数据时，DMA向CPU发出停止信号，CPU停止访问主存，这样的优点是控制简单，但是会造成CPU为充分发挥对主存的利用率。</p><p><img src="/../images/image-20230316155506254.png" alt="image-20230316155506254"></p><p><strong>（2）周期挪用</strong></p><p>IO设备发出数据请求时，DMA挪用或者窃取一个或者多个周期，DMA不请求时，CPU仍旧继续访问主存。</p><p><img src="/../images/image-20230316155727257.png" alt="image-20230316155727257"></p><p>DMA访问主存有三种可能：</p><ul><li>  CPU此时不访问</li><li>  CPU正在访存</li><li>  CPU与DMA同时请求访存，CPU将总线控制权让给DMA。</li></ul><p><strong>（3）DMA与CPU交替访问</strong></p><p>这种适合于CPU的工作周期比主存存取周期长的情况。</p><p><img src="/../images/image-20230316160113771.png" alt="image-20230316160113771"></p><h3 id="DMA接口的功能和组成"><a href="#DMA接口的功能和组成" class="headerlink" title="DMA接口的功能和组成"></a>DMA接口的功能和组成</h3><p><strong>1、DMA接口的功能</strong></p><p>(1) 向CPU申请DMA传送 </p><p>(2) 处理总线控制权的转交  </p><p>(3) 管理系统总线、控制数据传送  </p><p>(4) 确定数据传送的首地址和长度修正传送过程中的数据地址和长度  </p><p>(5) DMA传送结束时，给出操作完成信号</p><p><strong>2、DMA接口基本组成</strong></p><p><img src="/../images/image-20230316160851241.png" alt="image-20230316160851241"></p><ul><li>  主存地址寄存器（AR）：存放存储中需要交换数据的地址。</li><li>  字计数器（WC）：记录传送数据的总字数</li><li>  数据缓冲寄存器（BR）：用于暂存每次传输的数据。</li><li>  DMA控制逻辑：管理DMA的传送过程。当设备传送结束一个字，就向DMA提出申请（DREQ），向CPU发出总线使用权的请求（HRQ），待收到CPU响应信号（HLDA）后DMA负责管理传送的全过程，通知设备已经被赋予一个DMA周期（DACK）。</li><li>  中断机构：当字计数器置为0时，由中断机构发出中断请求给CPU进行后处理。</li><li>  设备地址寄存器（DAR）:存储IO设备的设备码或者表示信息存储区的寻址信息。</li></ul><h3 id="DMA的工作过程"><a href="#DMA的工作过程" class="headerlink" title="DMA的工作过程"></a>DMA的工作过程</h3><p><strong>1、DMA的传送过程</strong></p><p>预处理、数据传送、后处理</p><p><strong>（1）预处理</strong></p><p>通过几条输入输出指令预置如下信息（<strong>程序初始化</strong>）：</p><ul><li>  通知 DMA 控制逻辑传送方向（入/出）</li><li>  设备地址——DMA 的 DAR </li><li>  主存地址——DMA 的 AR </li><li>  传送字数——DMA 的 WC</li></ul><p><strong>（2）数据传送</strong></p><p>DMA是以数据块为单位进行传送的</p><p><img src="/../images/image-20230316162444116.png" alt="image-20230316162444116"></p><p>输出流程：</p><p><img src="/../images/image-20230316162534941.png" alt="image-20230316162534941"></p><p><strong>（3）后处理</strong></p><ul><li>  主要校验送入主存的数据是否正确。</li><li>  是否继续用DMA</li><li>  测试传送过程是否正确，错则转诊断程序，由中断服务程序完成。</li></ul><p><strong>2、DMA接口与系统的连接方式</strong></p><p>（1）具有公共请求线的 DMA 请求 </p><p><img src="/../images/image-20230316162826729.png" alt="image-20230316162826729"></p><p>（2）独立的DMA请求</p><p><img src="/../images/image-20230316162900042.png" alt="image-20230316162900042"></p><p>3、DMA方式与程序中断的比较</p><ul><li>  数据传送，程序中断靠程序传送，DMA靠硬件</li><li>  响应时间，程序中断是在一条指令结束的时候响应，DMA方式是存取周期结束。</li><li>  处理异常能力：程序中断有处理异常的能力，DMA没有</li><li>  中断请求：DMA不需要中断程序。</li><li>  优先级：DMA高。</li></ul><h3 id="DMA接口的类型"><a href="#DMA接口的类型" class="headerlink" title="DMA接口的类型"></a>DMA接口的类型</h3><p><img src="/../images/image-20230316163259082.png" alt="image-20230316163259082"></p><p><img src="/../images/image-20230316163305994.png" alt="image-20230316163305994"></p><p><img src="/../images/image-20230316163312507.png" alt="image-20230316163312507"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器</title>
    <link href="/2024/02/01/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2024/02/01/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><ol><li> 按存储介质分类</li></ol><p>（1）半导体存储器</p><p>（2）磁表面存储器</p><p>（3）磁芯存储器</p><p>（4）光盘存储器</p><ol start="2"><li> 按照存取方式分类</li></ol><p>（1）随机存储器（RAM）</p><p>​    RAM是一种可读可写的存储器，其特点是对存储器的任何一个存储单元的内容都可以随机存取。RAM又分为静态RAM（用触发器寄存信息）和动态RAM（以电容充放电原理寄存信息）。</p><p>（2）只读存储器（ROM）</p><p>（3）串行访问存储器</p><p>​    顺序存取存储器    磁带</p><p>​    直接存取存储器    磁盘</p><ol start="3"><li> 按照在计算机中的作用分类</li></ol><p><img src="/../images/image-20230308094142431.png" alt="image-20230308094142431"></p><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p>存储器有3个主要的性能指标：速度、容量、每位价格。</p><p>存储系统层次结构主要体现在缓存-主存和主存-辅存这两个存储层次上。</p><p><img src="/../images/image-20230308095327520.png" alt="image-20230308095327520"></p><p>主存-辅存层次的不断发展，形成了虚拟存储系统。</p><h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="主存的基本构成"><a href="#主存的基本构成" class="headerlink" title="主存的基本构成"></a>主存的基本构成</h4><p><img src="/../images/image-20230308095723932.png" alt="image-20230308095723932"></p><p>从上面这个图中我们可以看出，地址总线接到MAR上，根据MAR中的地址去读取存储单元，需要经过驱动器和译码器，同时读出操作时，需要经过读写电路进行放大才能够将被选中的存储字送到MDR中。</p><h4 id="主存和CPU的联系"><a href="#主存和CPU的联系" class="headerlink" title="主存和CPU的联系"></a>主存和CPU的联系</h4><p><img src="/../images/image-20230308100830545.png" alt="image-20230308100830545"></p><p>现代计算机，MDR和MAR都是存放在CPU中，通过总线和主存连接。</p><h4 id="主存中存储单元的分配"><a href="#主存中存储单元的分配" class="headerlink" title="主存中存储单元的分配"></a>主存中存储单元的分配</h4><p>在学习这一个知识点之前，我们先对一些基本概念进行总结。</p><ul><li>  比特位/位：bit，一般写作b</li><li>  字节：byte/Byte，一般写作B。1B=8b</li><li>  字：不同的机器字的位数不同。</li><li>  存储单元：CPU访问存储器的基本单位，8位二进制数为一个存储单元。也就是<strong>一字节</strong>。</li><li>  存储字长：就是一个字的位数。</li><li>  地址线：一根地址线对应2个存储单元。地址线一次确定一个存储单元，存储单元的个数=2^地址线。</li></ul><p>我们继续看下面的题目：</p><p><img src="/../images/image-20230308105640965.png" alt="image-20230308105640965"></p><p>12345678H，（H为16进制）。</p><p>一共8个数，每两个占用一个字节，也就是4字节。其中，12为高位，78为低位。</p><p><strong>区分大端、大尾和小端、小尾</strong></p><p>左边的图是低地址存高位字节，右边的图是低地址存地位字节。</p><p><strong>字地址</strong></p><p>字地址=存储字地址=存储单元地址</p><p>高位字节地址为字地址（大端模式），低位字节为字地址（小端模式）。</p><p><strong>寻址范围</strong>(待补充)</p><h4 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h4><p>主要的技术指标是<strong>存储容量</strong>和<strong>存储速度</strong>。</p><ul><li><p>存储容量：主存存放的二进制代码的总位数</p><p>  存储容量=存储单元个数*存储字长</p></li><li><p>  存储时间：存储器的访问时间（读出与写入的时间）</p></li><li><p>  存储周期：连续两次独立的存储器操作。（读或写）所需的 最小间隔时间。</p></li><li><p>  存储器的带宽：位/秒</p></li></ul><h3 id="半导体存储芯片"><a href="#半导体存储芯片" class="headerlink" title="半导体存储芯片"></a>半导体存储芯片</h3><p><img src="/../images/image-20230309103626963.png" alt="image-20230309103626963"></p><h4 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h4><p><strong>存储矩阵</strong>：存储矩阵是由大量相同的位存储单元阵列构成。</p><p><strong>译码驱动</strong>：将地址总线送来的地址信号翻译成对应的存储单元的选择信号，该信号在读写电路的配合下完成对被选中的单元进行的读写操作。</p><p><img src="/../images/image-20230309104156519.png" alt="image-20230309104156519"></p><p><strong>读写电路</strong>：包括读出放大器和写入电路，用来完成读写操作。</p><p>读写控制线：决定芯片进行读写操作。</p><p>片选线：CS表示芯片选择信号，CE表示芯片使能信号。低电平表示有效，高电平表示无效。</p><p>地址线：单向的，其位数与存储字的个数有关。</p><p>数据线：双向的，其位数与读出写入的数据位数有关。</p><p>数据线数和地址线数共同反映了存储芯片容量的大小。</p><p>容量=2^地址线数*数据线</p><h4 id="译码驱动方式"><a href="#译码驱动方式" class="headerlink" title="译码驱动方式"></a>译码驱动方式</h4><p>分为两种：线选法和重合法。</p><h5 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h5><p>特点是用一根字选择线，直接选中一个存储单元。例如输入0000，（下图是4条地址线，所以是16个存储单元，8条数据线，所以是8位，一共是16*8的矩阵）只有0字线被选中，对应着0这条线上的存储单元可以进行读写操作。</p><p><strong>缺点：</strong>如果有1M的地址线，就要2^20个字线。</p><p><img src="/../images/image-20230309105801579.png" alt="image-20230309105801579"></p><h5 id="重合法"><a href="#重合法" class="headerlink" title="重合法"></a>重合法</h5><p><img src="/../images/image-20230309133705367.png" alt="image-20230309133705367"></p><p>重合法将单一地址译码器分成了行地址和列地址译码器。行和列的交汇处共同锁定一个单元。如果加入00000，这时0行整行都被选中。然后让列地址译码器为00000，那么就可以确定00这个单元。</p><p>适用于存储大的内存芯片。</p><h3 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h3><p>随机存储器可以分为：静态RAM（SRAM）和动态RAM（DRAM）。</p><h4 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h4><h5 id="静态RAM基本电路"><a href="#静态RAM基本电路" class="headerlink" title="静态RAM基本电路"></a>静态RAM基本电路</h5><p><img src="/../images/image-20230309151317246.png" alt="image-20230309151317246"></p><p>静态RAM是通过触发器存储0或1，由T1-T6这六个MOS管构成一个基本电路。T5-T6由行地址控制，T7-T8由列地址控制。</p><p>由于静态RAM是用触发器工作的，所以当信息读出后一九保持着原状态，不需要再生。但是电源掉电后会使得信息丢失，故是一种<strong>易失性半导体存储器。</strong></p><p>（1）读操作</p><p><img src="/../images/image-20230309153547937.png" alt="image-20230309153547937"></p><p>（2）写操作</p><p><img src="/../images/image-20230309153603400.png" alt="image-20230309153603400"></p><p>在写操作时，在写选择时，经过两个写放大器以后，使两端输出为相反电平。这样可以保证触发器的两端是相反的电平。</p><h5 id="静态RAM芯片举例"><a href="#静态RAM芯片举例" class="headerlink" title="静态RAM芯片举例"></a>静态RAM芯片举例</h5><blockquote><p>  Intel2114芯片</p></blockquote><p><img src="/../images/image-20230309153909652.png" alt="image-20230309153909652"></p><p>（1）基本构成</p><p>基本电路用过6个MOS管组成，是一个存储容量为1K*4位。可以一次传输4位的数据，将64*64的矩阵分成4组。</p><p>CS是片选信号（低电平有效），WE是写允许信号（低电平为写，高电平是读）。</p><p>（2）矩阵结构</p><p><img src="/../images/image-20230309154247065.png" alt="image-20230309154247065"></p><p>（3）读操作</p><p>CS为低电平，WE为高电平，输出端输出第0行的第0，16，32，48这4个基本单元所存的信息。</p><h4 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h4><h5 id="动态RAM的基本单元电路"><a href="#动态RAM的基本单元电路" class="headerlink" title="动态RAM的基本单元电路"></a>动态RAM的基本单元电路</h5><p><img src="/../images/image-20230309155024581.png" alt="image-20230309155024581"></p><img src="../../../../../相册/typora/image-20230309155108755.png" alt="image-20230309155108755" style="zoom:67%;" /><p>常见的单元电路有<strong>三管式</strong>和<strong>单管式</strong>。都是通过电容存储。电容一般只能维持1-2ms，所以需要对其进行刷新。</p><h5 id="动态RAM芯片举例"><a href="#动态RAM芯片举例" class="headerlink" title="动态RAM芯片举例"></a>动态RAM芯片举例</h5><ol><li> 三管动态RAM芯片</li></ol><blockquote><p>  Intel1103</p></blockquote><p><img src="/../images/image-20230309160109457.png" alt="image-20230309160109457"></p><ul><li>  读操作</li></ul><p><img src="/../images/image-20230309155735468.png" alt="image-20230309155735468"></p><p>读操作时，首先对T4进行通电，电源对都数据线进行充电，读信号有效，T2就会被导通。如果Cg没有充电，则是0，T2通电，电流从T2传到读选择线，读到的数据是1。</p><ol start="2"><li> 单管动态RAM芯片</li></ol><blockquote><p>  RAM4116(16K*1位):</p></blockquote><p><img src="/../images/image-20230309160720851.png" alt="image-20230309160720851"></p><p><img src="/../images/image-20230309160558474.png" alt="image-20230309160558474"></p><ul><li>  读操作</li></ul><p>如果 CS中保存的是0，则数据线没有电流</p><p>如果 CS中保存的是1，则数据线有电流</p><ul><li>  写操作</li></ul><p>写入的是1 ： 对电容进行充电<br>写入的是 0：对电容进行放电</p><h5 id="动态RAM刷新"><a href="#动态RAM刷新" class="headerlink" title="动态RAM刷新"></a>动态RAM刷新</h5><p>（1）集中刷新</p><p>集中刷新是对所有存储单元的刷新，刷新的时候必须停止读写操作。</p><p><img src="/../images/image-20230309161720689.png" alt="image-20230309161720689"></p><p>（2）分散刷新</p><p><img src="/../images/image-20230309161920451.png" alt="image-20230309161920451"></p><p>可以保证不停止读写操作，但是耗时，效率低下。</p><p>（3） 分散刷新与集中刷新相结合（异步刷新）</p><p><img src="/../images/image-20230309162021700.png" alt="image-20230309162021700"></p><p>每行每隔 2 ms 刷新一次，将刷新安排在指令译码阶段，不会出现 “死区”。</p><h4 id="静态RAM和动态RAM对比"><a href="#静态RAM和动态RAM对比" class="headerlink" title="静态RAM和动态RAM对比"></a>静态RAM和动态RAM对比</h4><p><img src="/../images/image-20230309162111663.png" alt="image-20230309162111663"></p><h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><p>根据只读存储器的原始定义，里面的内容一旦确定就不可以改变，但是后来出现新的需求，用户想要改变ROM中的信息，这就出现了PROM、EPROM、EEPROM。</p><p>对半导体ROM而言，基本器件有两种：MOS型和TTL型。</p><h4 id="掩模ROM"><a href="#掩模ROM" class="headerlink" title="掩模ROM"></a>掩模ROM</h4><p>采用重合法驱动，行选择线和列选择线交叉处既可以有耦合元件又可以没有。如果有耦合元件，输出“1”，没有输出“0”。MOS管不可以进行改变，只能读。</p><h4 id="PROM"><a href="#PROM" class="headerlink" title="PROM"></a>PROM</h4><p>是一次性破坏性编程的只读存储器，由双极型电路和熔丝构成。熔丝断开的状态来判断0和1。</p><p><img src="/../images/image-20230310105656805.png" alt="image-20230310105656805"></p><h4 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h4><p>EPROM是一种可擦除可编程只读存储器。目前最多的是浮动栅雪崩注入型MOS管构成，称为FAMOS型EPROM。</p><p><img src="/../images/image-20230310105915905.png" alt="image-20230310105915905"></p><p>D端加正电压，形成浮动栅，S与D之间不通电，MOS管处于“0”状态。</p><p>D端不加正电压，不能形成浮动栅，S与D之间通电，MOS管处于“1”状态。</p><p>EPROM改写的方式有两种：一种是用紫外线照射，但是擦除的时间太长，不能进行单独的擦除。另一种方法是用电气的方式。在联机的条件下，用字擦除方式或页擦除方式，既可以局部擦除也可以全部擦除。这种称为<strong>EEPROM</strong>。</p><h4 id="FlashMemory"><a href="#FlashMemory" class="headerlink" title="FlashMemory"></a>FlashMemory</h4><p>性能价格比更好、可靠性高的可擦写非易失性存储器。</p><p>具有整块擦除的特点，擦除速度快。</p><p>具备RAM功能。</p><h3 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><p>单片存储芯片的容量有限，很难满足实际要求，将若干个存储芯片连在一起才能组成更大容量</p><h4 id="存储容量的扩展"><a href="#存储容量的扩展" class="headerlink" title="存储容量的扩展"></a>存储容量的扩展</h4><h5 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h5><p>位扩展是增加存储字长。</p><p><img src="/../images/image-20230310130919327.png" alt="image-20230310130919327"></p><h5 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h5><p><img src="/../images/image-20230310130958111.png" alt="image-20230310130958111"></p><h5 id="字位扩展"><a href="#字位扩展" class="headerlink" title="字位扩展"></a>字位扩展</h5><p><img src="/../images/image-20230310131039799.png" alt="image-20230310131039799"></p><h4 id="存储器与CPU的连接-1"><a href="#存储器与CPU的连接-1" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h4><ul><li>  地址线的连接</li><li>  数据线的连接</li><li>  读/写命令线的连接</li><li>  片选线的连接</li><li>  合理选择存储芯片</li><li>  其他 时序、负载</li></ul><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>设CPU共有16根地址线，8根数据线，并用MREQ（低电平有效）作访存控制信号，WR作读写命令信号（高电平为读，低电平为写）。现有下列存储芯片：ROM（2K×8位，4K×4位，8K×8位），RAM（1K×4位，2K×8位，4K×8位），及74138译码器和其他门电路（门电路自定）。试从上述规格中选用合适芯片，画出CPU和存储芯片的连接图。要求：</p><p>（1）6000H ~ 67FFH 为系统区。6800H~6BFFH 为用户区</p><p>（2）指出选用的存储芯片类型及数量。</p><p>（3）详细画出片选逻辑。</p><p>以下是作答：</p><img src="../../../../../相册/typora/image-20230310140356820.png" alt="image-20230310140356820" style="zoom: 200%;" /><p><img src="/../images/image-20230310140431375.png" alt="image-20230310140431375"></p><h3 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h3><h4 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h4><p>任意两组合法代码之间二进制位数的最小差异</p><p>编码的纠错、检错能力与编码的最小距离有关。</p><p><code>L-1=D+C</code></p><p><strong>L：</strong>编码的最小距离</p><p><strong>D：</strong>检查错误的位数</p><p><strong>C：</strong>纠正错误的位数</p><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>分为奇校验和偶校验。</p><p>例子：</p><p>原数        奇校验        偶校验</p><p>1001        1001 1        1001 0</p><p>1101        1101 0        1101 1</p><h4 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h4><p><img src="/../images/image-20230310145531410.png" alt="image-20230310145531410"></p><p>汉明码是采用奇偶校验和分组校验的方式检测和纠正错误。</p><p>如果检验的位数有n，那么需要添加k位检验数，组成一个n+k的代码。新增的k应该满足如下条件。</p><img src="../../../../../相册/typora/image-20230310144605014.png" alt="image-20230310144605014" style="zoom:50%;" /><p>检验位的位置确定：</p><img src="../../../../../相册/typora/image-20230310144720558.png" alt="image-20230310144720558" style="zoom: 50%;" /><p>分组如下：</p><img src="../../../../../相册/typora/image-20230310144816584.png" alt="image-20230310144816584" style="zoom:67%;" /><p>每一组中具有以下的特点：</p><ul><li>  每个小组gi有一位且仅有一位为它所独占，这一位是其他小组所没有的，即gi独占<img src="../../../../../相册/typora/image-20230310145204848.png" alt="image-20230310145204848" style="zoom:80%;" />（i，2，3，….）位。</li><li>  每两个小组gi和gj共同占有一个是其他小组没有的，每两个小组共同占用第<img src="../../../../../相册/typora/image-20230310145644554.png" alt="image-20230310145644554" style="zoom:80%;" />位。</li><li>  每三个小组共同占用第<img src="../../../../../相册/typora/image-20230310145723504.png" alt="image-20230310145723504" style="zoom:80%;" />位。</li></ul><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><p>求 0101 按 “偶校验” 配置的汉明码？</p><p><strong>解：</strong></p><p><img src="/../images/image-20230310150628129.png" alt="image-20230310150628129"></p><h3 id="提高访问速度的措施"><a href="#提高访问速度的措施" class="headerlink" title="提高访问速度的措施"></a>提高访问速度的措施</h3><p>采用高速器件、采用层次结构Cache-主存、调整主存结构。</p><h4 id="单体多字系统"><a href="#单体多字系统" class="headerlink" title="单体多字系统"></a>单体多字系统</h4><p>用一句话概括这种系统就是一次读取多个地址。</p><p>采用前提：指令和数据在主存中必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</p><h4 id="多体并行系统"><a href="#多体并行系统" class="headerlink" title="多体并行系统"></a>多体并行系统</h4><p>就是采用多体模块组成的存储器，每个模块都有相同的容量和存取速度，各模块都有各自独立的地址寄存器（MAR）、数据寄存器（MDR）、地址译码、驱动电路，他们能够并行工作、又能交叉工作。</p><p>（1）高位交叉</p><p><img src="/../images/image-20230313161539912.png" alt="image-20230313161539912"></p><p>因为程序是按照顺序编址的，也就是一个存储体满了以后再进行下一个存储体的编址，这样一来，我们就只能把高位作为体号、地位作为体内地址。</p><p>（2）低位交叉</p><p>低位交叉就是各个存储体轮流编址，原因和高位差不多，所以高位是体内地址、低位是体号。</p><p><img src="/../images/image-20230313162051856.png" alt="image-20230313162051856"></p><p>地位交叉的特点是在不改变周期的前提下，增加存储器的带宽。和高位交叉不同的是，高位交叉容易出现一个存储体特别繁忙，而其他的存储体非常空闲。</p><p><img src="/../images/image-20230313162225647.png" alt="image-20230313162225647"></p><p>设K体低位交叉存储器，存取周期为T，总线传输周期 为τ，为实现流水线方式存取，应满足 T ＝ kτ。 </p><p><img src="/../images/image-20230313162349072.png" alt="image-20230313162349072"></p><p>连续读取 k 个字所需的时间为   T＋(k－1)τ</p><h4 id="高性能存储芯片"><a href="#高性能存储芯片" class="headerlink" title="高性能存储芯片"></a>高性能存储芯片</h4><ul><li><p>SDRAM (同步 DRAM) </p><p>  在系统时钟的控制下进行读出和写入</p><p>  CPU 无须等待</p></li><li><p> RDRAM</p><p>   主要解决 存储器带宽 问题 </p></li><li><p>带 Cache 的 DRAM  </p><p>  在 DRAM 的芯片内 集成 了一个由 SRAM 组成的  Cache ，有利于 <strong>猝发式读取</strong>。</p></li></ul><h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>避免CPU空等现象出现：</p><p>因为CPU和主存之间的速度差异，所以需要引入一个缓存。</p><p><img src="/../images/image-20230313174609385.png" alt="image-20230313174609385"></p><h4 id="Cache的工作原理"><a href="#Cache的工作原理" class="headerlink" title="Cache的工作原理"></a>Cache的工作原理</h4><p>（1）主存和缓存的编址</p><p><img src="/../images/image-20230313203919251.png" alt="image-20230313203919251"></p><p>主存和缓存按块存储，块的大小相同。</p><p>（2）命中与未命中</p><p><strong>命中：</strong>主存块调入缓存，主存块与缓存块建立了对应关系。用标记记录与某缓存块建立了对应关系的主存块号。</p><p><strong>未命中：</strong>主存块未调入缓存，主存块与缓存块未建立对应关系。</p><p>（3）Cache的命中率</p><p>CPU欲访问信息在Cache中的比率。命中率与Cache的容量与快长有关。</p><p>（4）Cache-主存系统的效率</p><p>效率 e 与 命中率 有关。</p><p><img src="/../images/image-20230313204826595.png" alt="image-20230313204826595"></p><p>设 Cache 命中率 为 h，访问 Cache 的时间为 tc   ，  访问 主存 的时间为 tm</p><p><img src="/../images/image-20230313204908815.png" alt="image-20230313204908815"></p><h4 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h4><p><img src="/../images/image-20230313204937027.png" alt="image-20230313204937027"></p><h4 id="Cache的读写操作"><a href="#Cache的读写操作" class="headerlink" title="Cache的读写操作"></a>Cache的读写操作</h4><p>（1）读</p><p><img src="/../images/image-20230313205012942.png" alt="image-20230313205012942"></p><p>（2）写</p><ul><li><p>写直达法（write-through）</p><p>  写操作时数据既写入Cache又写入主存；写操作时间就是访问主存的时间，Cache块退出时， 不需要对主存执行写操作，更新策略比较容易实现。</p></li><li><p>写回法（write-back）</p><p>  写操作时只把数据写入 Cache 而不写入主存  当 Cache 数据被替换出去时才写回主存   写操作时间就是访问 Cache 的时间，Cache块退出时，被替换的块需写回主存，增加了  Cache 的复杂性。</p></li></ul><h4 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h4><p>（1）增加级数</p><p>（2）统一缓存和分立缓存</p><h3 id="Cache-主存的地址映射"><a href="#Cache-主存的地址映射" class="headerlink" title="Cache-主存的地址映射"></a>Cache-主存的地址映射</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="/../images/image-20230313205958121.png" alt="image-20230313205958121"></p><p>每个主存块只有和一个缓存块对应，映射关系是<img src="../../../../../相册/typora/image-20230313210141032.png" alt="image-20230313210141032" style="zoom:67%;" />。</p><p><strong>缺点：</strong></p><p>直接映射不够灵活，因每个主存块只能固定地对应某个缓存块，即使缓存内还有很多空间也不能占用。程序恰好访问到要重复访问对应的缓存块，只能利用替换算法将缓存块中的数据替换。</p><h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p><img src="/../images/image-20230313210704824.png" alt="image-20230313210704824"></p><p>主存 中的任一块可以映射到缓存中的任一块。这样一来确实解决了每个主存块只能够存储对应的缓存块，但是也导致了问题：首先是这样的电路设计复杂成本高，当我们需要缓存块对应的主存块时，需要对主存进行遍历。</p><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><p><img src="/../images/image-20230313211237834.png" alt="image-20230313211237834"></p><p>某一主存块 j 按模 Q 映射到 缓存 的第 i 组中的 任一块</p><h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><ol><li>  先进先出 （ FIFO ）算法 </li><li>  近期最少使用（ LRU）算法 </li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统总线</title>
    <link href="/2024/02/01/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/"/>
    <url>/2024/02/01/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="总线概念"><a href="#总线概念" class="headerlink" title="总线概念"></a>总线概念</h2><p>总线是连接多个部件的信息传输线，是各部件共享的传输介质。如果出现两个或者两个以上的部件同时向总线发送信息，会导致信号冲突，传输失效。</p><p>总线上的信息传输可以分为串行或者并行，并且在线路上按照位传输，一般并行的线路传输距离会比较近，主要是并行线路会出现相互干扰。</p><h3 id="单总线结构图"><a href="#单总线结构图" class="headerlink" title="单总线结构图"></a>单总线结构图</h3><p><img src="/../images/image-20230304163516479.png" alt="image-20230304163516479"></p><h3 id="面向CPU的双总线结构图"><a href="#面向CPU的双总线结构图" class="headerlink" title="面向CPU的双总线结构图"></a>面向CPU的双总线结构图</h3><p><img src="/../images/image-20230304163555276.png" alt="image-20230304163555276"></p><h3 id="存储器为中心的双总线结构图"><a href="#存储器为中心的双总线结构图" class="headerlink" title="存储器为中心的双总线结构图"></a>存储器为中心的双总线结构图</h3><p><img src="/../images/image-20230304163629228.png" alt="image-20230304163629228"></p><h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><h3 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h3><p>芯片内部的总线</p><h3 id="系统总线-1"><a href="#系统总线-1" class="headerlink" title="系统总线"></a>系统总线</h3><p>计算机各部件之间的信息传输线，根据系统传输信息的不同分为：数据总线、地址总线、控制总线。</p><ul><li>  数据总线：是双向传输总线，其位数与机器字长、存储字长有关。</li><li>  地址总线：用来指明CPU欲访问的存储单元或者I/O端口的地址，由CPU输出，单向传输。地址线的位数和存储单元个数有关。</li><li>  控制总线：对任一控制线来说，传输是单向的，但是对于控制总线总体来说，可以认为是双向的。</li></ul><h3 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h3><p>用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信。</p><p>传输方式分为：串行通信和并行通信。</p><h2 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h2><h3 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h3><ul><li><p>机械特性</p><p>  尺寸、形状、管脚数 及 排列顺序</p></li><li><p>电气特性</p><p>  传输方向和有效的电平范围</p></li><li><p>功能特性</p><p>  每根传输线的功能：地址、数据、控制。</p></li><li><p>时间特性</p><p>  信号的时序关系</p></li></ul><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ol><li> 总线宽度：数据线的根数</li><li> 标准传输率：每秒传输的最大字节数（MBps）。</li><li> 时钟同步/异步</li><li> 总线复用</li><li> 信号线数</li><li> 总线控制方式</li><li> 负载能力等</li></ol><h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><p><img src="/../images/image-20230304165618416.png" alt="image-20230304165618416"></p><h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><p>总线结构通常分为<strong>单总线结构</strong>和<strong>多总线结构</strong>。</p><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><p><img src="/../images/image-20230304165947100.png" alt="image-20230304165947100"></p><p>这种结构将CPU、主存、IO设备全部挂在一组总线上，这样的设计简单，也易于扩充。这类总线大多被小型计算机或者微型计算机使用。</p><h3 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h3><h4 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h4><p><img src="/../images/image-20230304170744467.png" alt="image-20230304170744467"></p><p>双总线结构的特点是将速度较低的IO设备分离出来，对IO设备进行统一的管理，系统的吞吐量可以相当大，这种结构大多用在大中型计算机系统。</p><h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><p><img src="/../images/image-20230304170711430.png" alt="image-20230304170711430"></p><p>三总线主要是将高速IO设备和低速IO设备进行了分离。主存总线和DMA总线不能够同时对主存进行存取，IO总线只有CPU执行IO指令才可以用到。</p><h4 id="三总线结构的又一式"><a href="#三总线结构的又一式" class="headerlink" title="三总线结构的又一式"></a>三总线结构的又一式</h4><p><img src="/../images/image-20230304171132456.png" alt="image-20230304171132456"></p><p>主要变化就是1、加上了Cache和局部总线，使得CPU可以与Cache和更多的局部IO设备连接。IO设备与主存的传输也不用经过CPU。2、还有一条扩展总线。</p><h4 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h4><p><img src="/../images/image-20230304171742212.png" alt="image-20230304171742212"></p><p>增加了一条高速总线，这种结构对于高速设备而言，其自身的工作很少依赖CPU，同时它们又比扩展总线上的设备更贴近CPU。</p><h3 id="总线结构举例"><a href="#总线结构举例" class="headerlink" title="总线结构举例"></a>总线结构举例</h3><h4 id="传统微型机总线结构"><a href="#传统微型机总线结构" class="headerlink" title="传统微型机总线结构"></a>传统微型机总线结构</h4><p><img src="/../images/image-20230304172032186.png" alt="image-20230304172032186"></p><h4 id="VL-UUS局部总线结构"><a href="#VL-UUS局部总线结构" class="headerlink" title="VL-UUS局部总线结构"></a>VL-UUS局部总线结构</h4><p><img src="/../images/image-20230304172054686.png" alt="image-20230304172054686"></p><h4 id="PCI总线结构"><a href="#PCI总线结构" class="headerlink" title="PCI总线结构"></a>PCI总线结构</h4><p><img src="/../images/image-20230304172115549.png" alt="image-20230304172115549"></p><h4 id="多层PCI总线结构"><a href="#多层PCI总线结构" class="headerlink" title="多层PCI总线结构"></a>多层PCI总线结构</h4><p><img src="/../images/image-20230304172140150.png" alt="image-20230304172140150"></p><h2 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h2><p>对于这么多的部件，在总线的争夺上，按照各部件的优先级来解决谁占用总线。</p><h3 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h3><p>主设备：<strong>对总线有</strong> <strong>控制权</strong></p><p>从设备：<strong>响应</strong> <strong>从主设备发来的总线命令</strong></p><p>总线判优控制：集中式、分布式。</p><p>常见的集中式有以下三种：</p><h4 id="链式查找"><a href="#链式查找" class="headerlink" title="链式查找"></a>链式查找</h4><p><img src="/../images/image-20230304173406070.png" alt="image-20230304173406070"></p><p>链式查找如果BG到达的接口有BR，BG信号就不会传递下去，并显示BS，也就是意味着该接口获得了总线使用权。</p><p>这种方式的特点是：</p><ul><li><p>  只需要很少的几根线就能够按一定优先级实现总线控制，并且很容易扩容。</p></li><li><p>  对电路故障很敏感</p></li><li><p>  优先级低的设备很难获得总线控制。</p></li></ul><p><strong>这种查找方式一般应用于微型计算机和嵌入式机器中。</strong></p><h4 id="计数器定时查询"><a href="#计数器定时查询" class="headerlink" title="计数器定时查询"></a>计数器定时查询</h4><p><img src="/../images/image-20230304174018910.png" alt="image-20230304174018910"></p><p>特点：</p><ul><li>  计数从0开始，按0-n的顺序降序排列，固定不动</li><li>  计数也可以从上一次计数终止点开始</li><li>  计数器的初始值可以由程序设置，优先次序可以改变</li></ul><h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><p><img src="/../images/image-20230304174335912.png" alt="image-20230304174335912"></p><p>特点：</p><ul><li>  响应速度快</li><li>  优先次序控制灵活</li><li>  控制线数量多</li><li>  总线控制复杂</li></ul><h3 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h3><p><strong>总线周期：</strong></p><p>①申请分配阶段：<strong>主模块申请</strong>，总线仲裁决定</p><p>②寻址阶段：<strong>主模块向从模块</strong> <strong>给出地址</strong> <strong>和</strong> <strong>命令</strong></p><p>③传数阶段：<strong>主模块和从模块</strong> <strong>交换数据</strong></p><p>④结束阶段：<strong>主模块</strong> <strong>撤消有关信息</strong></p><p>总线通信方式：同步通信、异步通信、半同步通信、分离式通信</p><h4 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h4><p><img src="/../images/image-20230304174940013.png" alt="image-20230304174940013"></p><h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><p><img src="/../images/image-20230304175008087.png" alt="image-20230304175008087"></p><h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><p>同步：<strong>发送方</strong> <strong>用系统</strong> <strong>时钟前沿</strong> <strong>发信号</strong>、<strong>接收方</strong> <strong>用系统</strong> <strong>时钟后沿</strong> <strong>判断、识别</strong></p><p>异步：<strong>允许不同速度的模块和谐工作</strong>，增加一条“等待”响应信号** <strong>WAIT</strong></p><p><img src="/../images/image-20230304175143039.png" alt="image-20230304175143039"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统概论</title>
    <link href="/2024/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <url>/2024/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1计算机系统简介"><a href="#1-1计算机系统简介" class="headerlink" title="1.1计算机系统简介"></a>1.1计算机系统简介</h1><p><img src="/../images/image-20230302103818677.png" alt="image-20230302103818677"></p><p><img src="/../images/image-20230302103832207.png" alt="image-20230302103832207"></p><p>计算机体系结构和计算机组成的区别：</p><ul><li>  计算机体系结构在于有无乘法指令</li><li>  计算机组成在于如何实现乘法指令</li></ul><h1 id="1-2计算机的基本组成"><a href="#1-2计算机的基本组成" class="headerlink" title="1.2计算机的基本组成"></a>1.2计算机的基本组成</h1><h2 id="冯·诺依曼计算机的特点"><a href="#冯·诺依曼计算机的特点" class="headerlink" title="冯·诺依曼计算机的特点"></a><strong>冯·诺依曼计算机的特点</strong></h2><ul><li><p>  计算机由五大部件组成</p></li><li><p>  指令和数据以同等地位存于存储器，可按地址寻访。</p></li><li><p>  指令和数据用二进制表示</p></li><li><p>  指令由操作码和地址码组成</p></li><li><p>  存储程序</p></li><li><p>  <strong>以运算器为中心</strong></p></li></ul><h2 id="硬件框图"><a href="#硬件框图" class="headerlink" title="硬件框图"></a>硬件框图</h2><p><img src="/../images/image-20230302193920259.png" alt="image-20230302193920259"></p><img src="../../../../../相册/typora/image-20230302193933581.png" alt="image-20230302193933581" style="zoom:80%;" /><h2 id="系统复杂性管理的方法"><a href="#系统复杂性管理的方法" class="headerlink" title="系统复杂性管理的方法"></a>系统复杂性管理的方法</h2><ul><li>  层次化</li><li>  模块化</li><li>  规则性</li></ul><h2 id="计算机的工作步骤"><a href="#计算机的工作步骤" class="headerlink" title="计算机的工作步骤"></a>计算机的工作步骤</h2><h3 id="1、上机前的准备"><a href="#1、上机前的准备" class="headerlink" title="1、上机前的准备"></a>1、上机前的准备</h3><ul><li><p>  建立数学模型</p></li><li><p>  确定计算方法</p></li><li><p>  编制解题程序</p></li></ul><p>计算机在编制解题程序的时候使用的操作码表示机器所执行的各种操作，如取数、存数、加、减、乘、除、停机、打印等。地址码表示参与运算的数在存储器中的位置。机器指令的操作码和地址码都是由0和1代码组合来表示。</p><h3 id="2、计算机工作过程"><a href="#2、计算机工作过程" class="headerlink" title="2、计算机工作过程"></a>2、计算机工作过程</h3><h4 id="（1）主存储器"><a href="#（1）主存储器" class="headerlink" title="（1）主存储器"></a>（1）主存储器</h4><img src="../../../../../相册/typora/image-20230303100710572.png" alt="image-20230303100710572" style="zoom:50%;" /><p><strong>存储器是由存储体+存储单元+存储元件构成。</strong></p><ul><li>  存储元件：存储一位0或者1二进制代码</li><li>  存储单元：存放一串二进制代码</li><li>  存储字：存储单元中二进制代码的组合</li><li>  存储字长：存储单元中二进制代码的位数，每个存储单元都赋予一个地址号。</li></ul><p><strong>为了实现按地址访问的方式，主存中还配备 了两个寄存器MAR和MDR。</strong></p><ul><li>  MAR：存储器地址寄存器反映存储单元的个数。</li><li>  MDR：存储器数据寄存器反映存储字长。</li></ul><h4 id="（2）运算器"><a href="#（2）运算器" class="headerlink" title="（2）运算器"></a>（2）运算器</h4><p>运算器最少包含3个寄存器和一个算术逻辑单元<strong>（ALU）</strong>。<strong>ACC</strong>为累加器、<strong>MQ</strong>为乘商寄存器、<strong>X</strong>为操作数寄存器。</p><p><img src="/../images/image-20230303101703776.png" alt="image-20230303101703776"></p><h4 id="（3）控制器"><a href="#（3）控制器" class="headerlink" title="（3）控制器"></a>（3）控制器</h4><ol><li> 功能：</li></ol><ul><li>  解释指令</li><li>  保证指令的按序执行</li></ul><ol start="2"><li> 基本组成：</li></ol><img src="../../../../../相册/typora/image-20230303102117752.png" alt="image-20230303102117752" style="zoom:50%;" /><p><strong>完成一条指令的过程：1、取指令PC；2、分析指令IR；3、执行指令CU。</strong></p><p>PC存放当前要执行指令的地址，具有计数功能（）PC）+1=PC；</p><p>IR存放当前欲执行的指令。</p><h4 id="（4）主机完成一条指令的过程"><a href="#（4）主机完成一条指令的过程" class="headerlink" title="（4）主机完成一条指令的过程"></a>（4）主机完成一条指令的过程</h4><ul><li>  取数指令</li></ul><p><img src="/../images/image-20230303102611032.png" alt="image-20230303102611032"></p><p>分析取数指令：</p><p>①PC用来存放当前欲执行指令的地址，有一条和MAR的直接通路，并且具有自动加1的功能。</p><p>②命令主存做读的操作，将读到的地址</p><p>③将主存中读到的内容送入MDR</p><p>④然后由MDR送至控制器的IR中，完成指令的取指过程</p><p>⑤经过CU分析，操作数是取数指令</p><p>⑥于是CU又将IR中的地址送入MAR</p><p>⑦命令存储器进行读操作</p><p>⑧将该地址单元操作数x送至MDR。</p><p>⑧再由MDR送至运算器的ACC，完成执行过程。</p><h4 id="（5）例题"><a href="#（5）例题" class="headerlink" title="（5）例题"></a>（5）例题</h4><p> **ax^2 **+ <strong>bx</strong> <strong>+</strong> <strong>c</strong> <strong>程序的运行过程</strong> ？</p><p><img src="/../images/image-20230303104023706.png" alt="image-20230303104023706"></p><h1 id="1-3计算机硬件的主要技术指标"><a href="#1-3计算机硬件的主要技术指标" class="headerlink" title="1.3计算机硬件的主要技术指标"></a>1.3计算机硬件的主要技术指标</h1><p>（1）机器字长</p><p>是指CPU一次能够处理的数据的位数，通常和CPU的寄存器位数有关。</p><p>（2）存储容量</p><p><img src="/../images/image-20230303105109921.png" alt="image-20230303105109921"></p><p>（3）运算速度</p><p><img src="/../images/image-20230303105133747.png" alt="image-20230303105133747"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户级线程</title>
    <link href="/2024/02/01/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/02/01/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h1><blockquote><p>  首先什么是用户级线程？</p></blockquote><p>在回答这个问题之前我们需要先搞清楚什么是线程，线程就是指令切换，进程是指令加上资源。也就是线程是将资源分离了，分而治之。既保留了并发的优点又避免了进程切换的代价。线程的切换实质上就是映射表不变PC指针改变。那什么是用户级线程呢，我们后面再讲。</p><h2 id="线程的价值"><a href="#线程的价值" class="headerlink" title="线程的价值"></a>线程的价值</h2><p> 上面我们讲过了，线程就是只有切换指令而没有切换资源，这样的好处是什么？</p><p><img src="../../../../../相册/typora/image-20230421125943191.png" alt="image-20230421125943191" style="zoom: 25%;" /><img src="../../../../../相册/typora/image-20230421130000706.png" alt="image-20230421130000706" style="zoom:25%;" /></p><p>如上面的两幅图，如果没有用到多线程，加载所有资源都要用到一个线程，那么可能就会造成一开始网站上一点东西都没有，但是突然一下全部加载好了，这会造成用户体验极差。</p><p>多线程是利用同一张映射表，也就是资源是一样的。</p><h2 id="Yield"><a href="#Yield" class="headerlink" title="Yield()"></a>Yield()</h2><p>yield()函数就是用来切换线程的。函数在调用Yield()函数的时候并不知道自己要切换到哪个线程中，只是表明放弃对CPU的占有。Yield()函数是用户主动调用的，而不是放到内核中执行。</p><p>下面我们就通过代码的方式来说明Yield()的使用。</p><h3 id="两个执行序列一个栈"><a href="#两个执行序列一个栈" class="headerlink" title="两个执行序列一个栈"></a>两个执行序列一个栈</h3><img src="../../../../../相册/typora/image-20230421131029754.png" alt="image-20230421131029754" style="zoom:50%;" /><p>如上面的代码执行过程如下：</p><p>1、从A()函数开始，调用B()函数，并将104压入栈中。</p><p>2、进入B函数，调用Yield()函数，将204压入栈中，此时的csp是：<img src="../../../../../相册/typora/image-20230421131308941.png" alt="image-20230421131308941" style="zoom:50%;" />然后调用Yield()函数跳转到300。</p><img src="../../../../../相册/typora/image-20230421131344430.png" alt="image-20230421131344430" style="zoom:67%;" /><p>3、执行300处的C函数，调用D()，并将304压入栈中，最后调用D()执行Yield()函数，压入404，此时的csp为<img src="../../../../../相册/typora/image-20230421131529404.png" alt="image-20230421131529404" style="zoom:50%;" />。</p><p>4、也就是返回到了B函数的}。</p><blockquote><p>  思考：再往下执行会出现什么问题？</p></blockquote><p>在C语言中}表示ret也就是从栈中pop出元素。那么pop出的第一个元素就是404，也就是又回到了404所在的函数D中。但是我们预期设想的是希望返回到A中结束程序。</p><blockquote><p>  思考：上面暴露出了什么问题，怎么解决？</p></blockquote><p>上面暴露出了当两个执行序列公用一个栈的话，会造成栈中数据混乱的情况。那么我们就用两个栈保存线程的数据。</p><h3 id="两个栈解决问题"><a href="#两个栈解决问题" class="headerlink" title="两个栈解决问题"></a>两个栈解决问题</h3><p>两个栈和一个栈的Yield代码区别就在于引入了TCB，这个TCB和PCB相似，在这里TCB用于存栈顶地址，当调用了Yield(），首相先将csp中的值存入TCB中的esp也就是保存栈的信息。</p><img src="../../../../../相册/typora/image-20230421135319512.png" alt="image-20230421135319512" style="zoom:50%;" /><p>上面的jmp204应该去除，因为跳转地址保存在栈中。</p><blockquote><p>  现在我们对于两个线程的切换就是两个TCB、两个栈、切换的PC在栈中。也就是我们需要做到这几件事，那么谁帮我们来做，那就是ThreadCreate来创建线程并且初始化这些。</p></blockquote><h2 id="ThreadCreate"><a href="#ThreadCreate" class="headerlink" title="ThreadCreate()"></a>ThreadCreate()</h2><img src="../../../../../相册/typora/image-20230421135950096.png" alt="image-20230421135950096" style="zoom:67%;" /><p>通过上面的代码我们可以看出：ThreadCreate就是创建了一个TCB，并且创建了一个新的栈，来保存新线程的信息。</p><h2 id="为什么叫用户级线程"><a href="#为什么叫用户级线程" class="headerlink" title="为什么叫用户级线程"></a>为什么叫用户级线程</h2><img src="../../../../../相册/typora/image-20230421140642940.png" alt="image-20230421140642940" style="zoom:67%;" /><p>如果当线程需要调用硬件时，如果进程阻塞，就会切换到另一个进程，那么在原来进程上的所有线程将会处于宕机状态。因为操作系统感知不到用户级线程。</p><h2 id="引出内核级线程"><a href="#引出内核级线程" class="headerlink" title="引出内核级线程"></a>引出内核级线程</h2><img src="../../../../../相册/typora/image-20230421141024704.png" alt="image-20230421141024704" style="zoom:67%;" /><p>如果TCB在核心的话，再分配CPU调度的时候会更加有优势。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用</title>
    <link href="/2024/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2024/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统的接口"><a href="#操作系统的接口" class="headerlink" title="操作系统的接口"></a>操作系统的接口</h1><p>在讲系统调用之前，谈一谈什么是操作系统的接口。学过高级语言的都知道所谓的接口就是API，比如我们需要调用支付宝付款的接口，那我们只要去查询支付宝开放的接口，我们就可以利用这个接口来联通支付宝的支付功能。（当然实际中没有这么简单）。</p><h2 id="命令是什么"><a href="#命令是什么" class="headerlink" title="命令是什么"></a>命令是什么</h2><p>在操作系统中，一条命令就是一段用C语言写的程序，那我们平时使用的图形界面都是什么呢，也就是一个包含画图功能的C程序。</p><h2 id="什么是操作系统接口"><a href="#什么是操作系统接口" class="headerlink" title="什么是操作系统接口"></a>什么是操作系统接口</h2><p>操作系统接口是连接操作系统和应用软件的连接者。通过普通的C代码加上一些重要的函数连接。</p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>例如实现一个whoami的系统调用：</p><img src="../../../../../相册/typora/image-20230417134526684.png" alt="image-20230417134526684" style="zoom:50%;" /><p>例如上面的函数，蓝色部分是用户程序，红色部分是内核程序。思考：为什么不能直接调用（以上的代码是错误的）？</p><p>因为如果可以自由的调用，那么操作系统内部的数据就非常容易被窃取，会造成电脑的不安全。所以操作系统将内核数据和用户数据隔离开来。也就是用户代码称为<strong>用户态</strong>，系统代码称为<strong>内核态</strong>。</p><p>继续思考，为什么内核态不能访问到，明明都是在一个内存中。</p><p>这就需要引出权限级的作用了，由于CS：IP是当前命令，所以用CS的最低两位来表示：0是内核态，3是用户态。</p><p>当CPL=3时，用户态不能够访问内核数据；当CPL=0时，内核态可以访问任何的数据。</p><p>但是难道就这样？我们没有办法进入内核吗？</p><h2 id="硬件提供了主动进入内核的方法。"><a href="#硬件提供了主动进入内核的方法。" class="headerlink" title="硬件提供了主动进入内核的方法。"></a>硬件提供了主动进入内核的方法。</h2><p>对于x86计算机，提供中断指令int。int指令使得CS中的CPL置为0，也就是获得最高的权限级。由此进入内核。</p><p>这也是用户程序调用内核程序的唯一办法。</p><p>所以我们到这里就可以引出系统<strong>调用的核心</strong>：</p><ul><li>  用户程序中包含着一段有int指令的代码（在库函数中）。</li><li>  操作系统写中断处理，获取想调程序的编号。</li><li>  操作系统根据编号执行相关的代码</li></ul><p><strong>注：在操作系统内部设计的时候还没有用到封装的思想，所以这些都是一种硬件设计。</strong></p><h2 id="系统调用的具体实现"><a href="#系统调用的具体实现" class="headerlink" title="系统调用的具体实现"></a>系统调用的具体实现</h2><p>先说说大概思路：</p><img src="../../../../../相册/typora/image-20230417140642368.png" alt="image-20230417140642368" style="zoom:50%;" /><p>这里调用的是write函数。</p><p>（1）</p><p><img src="/../images/image-20230417140905868.png" alt="image-20230417140905868"></p><p>_syscall3是一个宏，其中有3个参数。</p><p>_NR_write是一个系统调用号，放在eax中。同时eax也存放返回值，ebx，ecx，edx存放3个参数。</p><p>（2）int 0x80中断的处理</p><p>set_system_gate是用来设置0x80的中断处理：</p><p><img src="/../images/image-20230417141528411.png" alt="image-20230417141528411"></p><p>（3）中断处理程序</p><p><img src="/../images/image-20230417141622063.png" alt="image-20230417141622063"></p><p>其中**_sys_call_table+4*%eax**就是相应系统调用处理函数入口</p><p>（4）_sys_call_table</p><p><img src="/../images/image-20230417141711351.png" alt="image-20230417141711351"></p><p><strong>call _sys_call_table(,%eax,4)<strong>就是</strong>call sys_write</strong></p><p>总结整个的调用过程：</p><p><img src="/../images/image-20230417141835449.png" alt="image-20230417141835449"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核级线程</title>
    <link href="/2024/02/01/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/02/01/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h1><h2 id="在多核处理器中内核级线程的作用"><a href="#在多核处理器中内核级线程的作用" class="headerlink" title="在多核处理器中内核级线程的作用"></a>在多核处理器中内核级线程的作用</h2><p><img src="/../images/image-20230421141717209.png" alt="image-20230421141717209"></p><p>在多核的处理器中，多线程可以使用多核硬件并行使用。</p><h2 id="内核级线程的栈实现"><a href="#内核级线程的栈实现" class="headerlink" title="内核级线程的栈实现"></a>内核级线程的栈实现</h2><p>ThreadCreate是系统调用，内核管理TCB，内核负责切换线程。那在用户级线程中我们通过TCB将一个栈关联进行切换栈操作。</p><img src="../../../../../相册/typora/image-20230421142422797.png" alt="image-20230421142422797" style="zoom:67%;" /><p>在内核级线程中我们通过将用户栈和内核栈关联的方式将一个栈变为一套栈来使用。</p><h3 id="用户栈和内核栈之间关联。"><a href="#用户栈和内核栈之间关联。" class="headerlink" title="用户栈和内核栈之间关联。"></a>用户栈和内核栈之间关联。</h3><img src="../../../../../相册/typora/image-20230421143219079.png" alt="image-20230421143219079" style="zoom:67%;" /><p>用户栈通过int中断进入内核栈，内核栈通过iret返回到用户栈。</p><img src="../../../../../相册/typora/image-20230421143336742.png" alt="image-20230421143336742" style="zoom:67%;" /><p>我们分析一下上面的代码：首先用户态中执行A、B函数将104、204压入用户栈中，然后执行read函数时，执行int中断程序进入内核态。此时SS记录用户栈的栈基地址，SP记录用户栈的栈顶。CS记录段基址。然后执行1000，执行sys_read()执行内核函数。</p><p>一旦启动内核读就会造成磁盘阻塞，就要开始调度，找到next线程。switch_to(cur,next);这里的switch_to 交换的是线程的TCB。</p><p><img src="../../../../../相册/typora/image-20230421144813924.png" alt="image-20230421144813924" style="zoom: 33%;" /><img src="../../../../../相册/typora/image-20230421144726508.png" alt="image-20230421144726508" style="zoom: 50%;" /></p><p>其中？？？中应该是：sys_read函数的某一个地方。</p><p>？？：interrupt之前的某一个地方</p><p>线程T创建的CS=？？中填写线程T的开始地址。？？？？是一段能完成二级返回的包含iret的代码。</p><h2 id="内核线程switch-to的五段论"><a href="#内核线程switch-to的五段论" class="headerlink" title="内核线程switch_to的五段论"></a>内核线程switch_to的五段论</h2><p><img src="/../images/image-20230421145522689.png" alt="image-20230421145522689"></p><p>五段论的执行过程：</p><p>1、首先是进入切换，也就是进入中断入口。利用int函数进入内核。调用call中断处理程序。</p><p>2、然后在中断处理程序中，如果程序启动磁盘或者时钟中断则引发切换，调用schedule()函数。</p><p>3、进入schedule函数中，next找到下一个TCB。也就是记录下一个线程控制块。然后调用switch_to函数。</p><p>4、进入switch_to函数，将esp寄存器中的数据保存在TCB中，然后将下一个TCB中的csp盖到esp寄存器上。然后ret。</p><p>5、中断出口，带有iret指令的代码。</p><h2 id="ThreadCreate（）"><a href="#ThreadCreate（）" class="headerlink" title="ThreadCreate（）"></a>ThreadCreate（）</h2><img src="../../../../../相册/typora/image-20230421145550347.png" alt="image-20230421145550347" style="zoom:67%;" /><p><img src="/../images/image-20230421145634488.png" alt="image-20230421145634488"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程图像</title>
    <link href="/2024/02/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%BE%E5%83%8F/"/>
    <url>/2024/02/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程图像"><a href="#多线程图像" class="headerlink" title="多线程图像"></a>多线程图像</h1><h2 id="引入进程的概念"><a href="#引入进程的概念" class="headerlink" title="引入进程的概念"></a>引入进程的概念</h2><p>我们都是到CPU的工作原理就是通过取指执行，我们需要做的就是给CPU一个PC指针指向要执行的指令，CPU就会自己执行下去，那这样会不会有什么问题出现？</p><p>例如下面的一段代码：</p><img src="../../../../../相册/typora/image-20230418122852332.png" alt="image-20230418122852332" style="zoom: 80%;" /><p>如果CPU要去执行这段代码，我们就知道设定PC初值指向第一个C语句。然后cpu一条一条执行下去，可以执行，但是分析CPU这样一条一条的执行下去会出现什么问题？</p><p>注意看fprintf语句，这是一条IO指令，IO指令意味着什么，意味着CPU需要请求IO设备也就是这个过程中CPU是处于空闲的状态的。那我们怎么提高CPU的利用效率？</p><p><img src="/../images/image-20230418123427216.png" alt="image-20230418123427216"></p><p>利用并行的方式，也就是<strong>多道程序、交替执行</strong>。</p><p><strong>思考：</strong>那怎么切换到另一个程序上呢？</p><p>答案也很简单就只要修改PC的值就好了，但是这里如果只修改PC的值之后会出现很多问题，我们之后再作讨论。</p><p><strong>思考：</strong>修改了PC就好了吗？</p><p>当然不是，要把正在运行的程序进行保存，等到切回来的时候不会出现什么错误。所以这里就需要引出一个概念，Linux0.11 设计了一个结构体：<code>struct task_struct&#123;...&#125;</code>，用于记录进程的“样子”，每个进程都有一个该结构体的对象——PCB（进程控制块）。</p><p><strong>思考：</strong>那么进程是什么呢？</p><p>进程就是进行中的程序，用户控制操作系统核心就是控制进程。</p><h2 id="多进程图像"><a href="#多进程图像" class="headerlink" title="多进程图像"></a>多进程图像</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>main中的fork()创建了一个子进程，fork()的执行过程如下：</p><ul><li>  fork()内执行int 0x80，进入内核</li><li>  执行system_call程序</li><li>  执行sys_fork程序</li><li>  执行copy_process()函数</li></ul><p>其中copy_process()才是创建子进程的地方。</p><p>创建了一个fork()以后就是会执行init()，执行了init()后会执行一个shell（就如同windows桌面程序被弹出）。也就是一个命令启动一个进程，返回shell然后再启动其他的进程。</p><p><strong>思考：</strong>多进程怎么进行存放？</p><p>前面我们说过，利用PCB来存放一个进程的所有信息。那么很多个进程就可以利用队列的方式，多进程的组织就是：PCB+状态+队列。</p><p><img src="/../images/image-20230418131911801.png" alt="image-20230418131911801"></p><p>上面的图称为<strong>进程状态图</strong>。</p><h3 id="进程的交替"><a href="#进程的交替" class="headerlink" title="进程的交替"></a>进程的交替</h3><p>进程是如何进行交替的，这也是多线程图像的核心部分</p><p><img src="/../images/image-20230418132430676.png" alt="image-20230418132430676"></p><p>例如上面的例子：</p><p>假如程序运行到了启动磁盘读写，则将该进程的状态置为W(阻塞)，然后将该进程放入阻塞队列中，然后执行schedule()进行切换。schedule中先进行了线程的调度，然后利用switch_to将当前进程的寄存器状态保存起来，然后将下一个进程的内容扣在CPU寄存器中。</p><p><strong>进程交替三个部分:</strong></p><p>队列操作+调度+切换。</p><p>进程的调度可以是FIFO或者按照Priority。</p><h3 id="进程之间的影响"><a href="#进程之间的影响" class="headerlink" title="进程之间的影响"></a>进程之间的影响</h3><p>多个进程如果同时存在于内存会出现以下问题：</p><p><img src="/../images/image-20230418133621694.png" alt="image-20230418133621694"></p><p>也就是进程1调用了进程2的代码。</p><p>解决的方法就是：限制对地址100的读写，而通过映射的方式进行读写。如下图。</p><p><img src="/../images/image-20230418133753672.png" alt="image-20230418133753672"></p><h3 id="多进程怎么合作"><a href="#多进程怎么合作" class="headerlink" title="多进程怎么合作"></a>多进程怎么合作</h3><p><img src="/../images/image-20230418134536626.png" alt="image-20230418134536626"></p><p>现在有两个进程同时操作一个共享数据。</p><p><strong>思考</strong>：会出现什么问题？</p><p>如果我们执行以下的操作：</p><p><img src="/../images/image-20230418134641511.png" alt="image-20230418134641511"></p><p><img src="/../images/image-20230418134708475.png" alt="image-20230418134708475"></p><p>那么一个可能的执行序列会是这样的：</p><p><img src="/../images/image-20230418134735512.png" alt="image-20230418134735512"></p><p><strong>解决：</strong></p><p>利用进程同步，也就是给进程加锁。</p><p><img src="/../images/image-20230418134834512.png" alt="image-20230418134834512"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDT和LDT</title>
    <link href="/2024/02/01/GDT%E5%92%8CLDT/"/>
    <url>/2024/02/01/GDT%E5%92%8CLDT/</url>
    
    <content type="html"><![CDATA[<h1 id="GDT和LDT"><a href="#GDT和LDT" class="headerlink" title="GDT和LDT"></a>GDT和LDT</h1><p>从前面的操作系统加载过程中我们知道了操作系统在加载中会改变寻址方式，也就是实模式和保护模式下的寻址方式的改变。</p><p>下面我们就通过寻址方式展开说一下背后的原理以及GDT和LDT的工作内容。</p><h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><h3 id="实模式下的内存寻址"><a href="#实模式下的内存寻址" class="headerlink" title="实模式下的内存寻址"></a>实模式下的内存寻址</h3><p>实模式下的内存寻址就是如下的公式：</p><blockquote><p>  段首地址*16+偏移地址=物理地址</p></blockquote><p>因为在8086CPU内部有20条地址线，但是寄存器的大小都是16位的，也就是寻址范围是64KB，如果要用到20条地址线就需要通过地址加法器来将两个16位的地址合成一个20位的地址。</p><h3 id="保护模式下分段机制的内存寻址"><a href="#保护模式下分段机制的内存寻址" class="headerlink" title="保护模式下分段机制的内存寻址"></a>保护模式下分段机制的内存寻址</h3><p>保护模式下的内存寻址范围是4G，能达到这么广范围的寻址，靠原来的实模式下的内存寻址肯定是满足不了，但是可以通过GDT来实现，什么是GDT，GDT在哪里，GDT又是怎么实现这么多的地址寻址的，我们一个一个讲。</p><p>先说说寻址的规则：</p><p>了解几个概念先：</p><ul><li>  段选择子：对应的就是段地址，只是把ds和cs等段寄存器当作段选择子，也就是不通过直接利用`段地址：偏移地址来定位内存单元。</li><li>  段描述表（GDT）：我们解决了什么是GDT，是一张表，也就是可以理解成数组，而段选择子就是它的索引。</li><li>  段描述符：我们拿到GDT要干什么，那一定是要把里面的只拿出来当作我们的段地址，所以GDT中保存的内容就是段描述符，也就相当于数组中的值。</li></ul><p>说完了概念我们讲一下在保护模式下怎么寻址：</p><blockquote><p>  段描述符中的段基址+偏移量=物理地址</p></blockquote><h2 id="什么是GDT"><a href="#什么是GDT" class="headerlink" title="什么是GDT"></a>什么是GDT</h2><p>上面我们只是浅浅的说了一下什么是GDT，现在我们深入了解一下。</p><p>GDT称为全局描述符表，只有一张且全局可见，存放在内存中的任何地方</p><p><img src="https://img-blog.csdnimg.cn/5021220a0a4241c59c7c94f41eb29dc7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkwOTA5Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="图2.1 段描述符"></p><p>看到上面的这幅图一定非常的😵。下面我解读一下：</p><ul><li>  G：颗粒度。当G=0时，段限长的20位为实际段限长，最大限长为2^20=1MB；当G=1时，实际段限长为20位段限长乘以2^12=4KB，最大限长达到4GB。</li><li>  DPL：特权级。0表示最高特权级，3表示最低特权级，和CPL相比，CPL是当前的进程特权级，如果CPL(权级)&gt;DPL，则可以通行，反之不能通行。</li><li>  基地址：基地址总共32位，寻址范围为4G。</li></ul><h2 id="GDT在哪"><a href="#GDT在哪" class="headerlink" title="GDT在哪"></a>GDT在哪</h2><p>GDT存放在内存中，但是我们怎么找到它呢？</p><p>当然是有一个入口去记录GDT的地址，那么这个入口就是一个叫做GDTR的寄存器（48bits）来存放入口地址。下面是GDTR的结构：</p><p><img src="https://img-blog.csdnimg.cn/20200101200022770.png#pic_center" alt="图3.1 GDT结构图"></p><p>指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。</p><h2 id="什么是LDT"><a href="#什么是LDT" class="headerlink" title="什么是LDT"></a>什么是LDT</h2><p>LDT是局部段描述符表，和GDT的结构相似。</p><p>在内存中可以有好多个LDT，但是在一个任务中最多只有一个LDT，并且每个LDT又是当作一个段记录在GDT中。</p><p>如果每个任务都有LDT那么切换任务时就需要修改LDTR，修改的方式就是通过LLDT指令将下一个任务的LDT的段描述符的段选择子装入此寄存器。</p><p><img src="https://img-blog.csdnimg.cn/13d1a9632c714a3ca1e96c1e07e937b9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkwOTA5Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="图4.1 Linux0.11中的 GDT 和 LDT"></p><h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><p>段选择子就是原来的各个段寄存器，但是并不是每一个段选择子都是段寄存器，而是根据汇编语言来控制的，例如jmpi 0 8。就是利用常数表示选择子。</p><p>段选择子大小为 16bit。段选择子包括三部分：描述符索引（index）、TI、请求特权级（RPL）。其中index占13位、TI占1位、RPL占2位。</p><ul><li><p>  TI 值只有一位0或1，0代表选择子是在 GDT 中索引，1代表选择子是在 LDT 中索引。</p></li><li><p>  请求特权级（RPL）则代表选择子的特权级，共有4个特权级（0级、1级、2级、3级）。</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="访问-GDT"><a href="#访问-GDT" class="headerlink" title="访问 GDT"></a>访问 GDT</h3><p><img src="https://img-blog.csdnimg.cn/20200101203309645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkwOTA5Mg==,size_16,color_FFFFFF,t_70" alt="图6.1 通过访问 GDT 寻址"></p><h3 id="访问-LDT"><a href="#访问-LDT" class="headerlink" title="访问 LDT"></a>访问 LDT</h3><p><img src="https://img-blog.csdnimg.cn/20200101203425902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkwOTA5Mg==,size_16,color_FFFFFF,t_70" alt="图6.2 通过访问 LDT 寻址"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>80x86保护模式</title>
    <link href="/2024/02/01/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/02/01/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="80x86保护模式"><a href="#80x86保护模式" class="headerlink" title="80x86保护模式"></a>80x86保护模式</h1><p>通过这一篇文章可以了解到x86保护模式的内存管理、各种保护措施、中断和异常处理、任务管理、保护模式编程的初始化，最后就是一个简单的内核案例。</p><p>注意：写在前面，我们研究x86保护模式实际上还没有进入操作系统的内核，这都是CPU已经设定好的一些功能，但是我们必须掌握这种架构的设计与使用，Linux系统中虽然有一些功能并没有使用到，但是了解一个体系结构永远都不会是过时的。</p><p>以下是总结式笔记，内容不全</p><h2 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h2><ul><li>  标志寄存器</li><li>  内存管理寄存器</li><li>  控制寄存器</li></ul><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>简单来说，标志寄存器EFLAGS中的系统标志和IOPL字段是用来控制IO访问、可屏蔽硬件中断、调试、任务切换、虚拟8086模式</p><h3 id="内存管理寄存器"><a href="#内存管理寄存器" class="headerlink" title="内存管理寄存器"></a>内存管理寄存器</h3><p>GDTR、IDTR、LDTR、TR。首先这4个寄存器都是段基址寄存器。</p><h4 id="全局描述符表寄存器GDTR"><a href="#全局描述符表寄存器GDTR" class="headerlink" title="全局描述符表寄存器GDTR"></a>全局描述符表寄存器GDTR</h4><p>GDTR看名字就知道是用来存储GDT表的地址。用于保存全局描述符表GDT的32位线性基地址和16位的表限长度。</p><p>在保护模式初始化过程中必须要给GDTR加载一个新值。</p><h4 id="中断描述符表寄存器IDTR"><a href="#中断描述符表寄存器IDTR" class="headerlink" title="中断描述符表寄存器IDTR"></a>中断描述符表寄存器IDTR</h4><p>其中记录的是IDT表的32位的线性基地址和16位表限长度。</p><h4 id="局部描述符表寄存器LDTR"><a href="#局部描述符表寄存器LDTR" class="headerlink" title="局部描述符表寄存器LDTR"></a>局部描述符表寄存器LDTR</h4><p>同样是记录LDT表的32位基地址和16位的表限长度。</p><h4 id="任务寄存器TR"><a href="#任务寄存器TR" class="headerlink" title="任务寄存器TR"></a>任务寄存器TR</h4><p>用于存储当前任务的TSS段的16位段选择符和32位基地址和16位段长度和描述符属性值</p><h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>控制寄存器（CR0-CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。</p><p>这里重点讲一下CR0。</p><h4 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h4><p>CR0中含有控制处理器操作模式和状态的系统控制标志。</p><p>CR0中的保护控制位：</p><ul><li>  PE：启动保护标志。当设置PE=0时，表示处于实地址模式，当设置位1时表示运行在保护模式下。PE是用来控制分段机制。</li><li>  PG：用来控制分页机制，分段机制和分页机制我会在后面讲解，分段和分页对于x86寻址起到了非常大的作用。PG=1时，开启了分页机制，反之关闭。有一个特例就是当PE=0,PG=1时因为不在保护模式下不能够开启分页机制。</li></ul><h2 id="保护模式内存管理"><a href="#保护模式内存管理" class="headerlink" title="保护模式内存管理"></a>保护模式内存管理</h2><p>0</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统是怎么启动的</title>
    <link href="/2024/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84/"/>
    <url>/2024/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h1><p>引入：在下面这块开机启动界面的背后发生了什么，倒是我们可以在这块冰冷的屏幕上面显示精彩的内容，操作系统在里面起到什么样的角色，又是任何从机器中读取代码和解释代码的呢？</p><p><img src="/../images/image-20230414135655373.png" alt="image-20230414135655373"></p><h2 id="计算机上电"><a href="#计算机上电" class="headerlink" title="计算机上电"></a>计算机上电</h2><ul><li>  刚开机，内存中没有任何的程序，只有BIOS可以执行。X86PC处于实模式（和保护模式相对，实模式的寻址CS:IP，和保护模式不同），寻址方式和我们学过的8086一样，寻址范围为20位也就是1M。开机时 <code>CS = 0xFFFF； IP = 0x0000</code>，那么就是寻址<code>0xFFFF0</code>地址，而这个地址存储的就是ROM BIOS映射区（计算机初始化过程中会把BIOS代码复制到ROMBIOS映射区）。</li></ul><p>以上内容就是在将CPU首先从ROＭ BIOS映射区开始执行。那么BIOS是用来干嘛的呢</p><ul><li>  该程序主要负责检测系统硬件是否正常，并建立中断向量表（这只是供操作系统使用，操作系统初始化以后就会覆盖，并且建立新的中断向量表）。</li><li>  在ROM BIOS映射区的代码执行到最后，就会将操作系统启动程序（bootsect.s）从0磁盘0扇区复制到内存<code>0X07C00</code>处，并且设置CS=<code>0X07C0</code>,IP=<code>0x0000</code></li><li>  最后cpu转移到bootsect.s开始执行。</li></ul><p><img src="/../images/image-20230414103136676.png" alt="image-20230414103136676"></p><p>操作系统程序在磁盘中的分布情况：</p><p><img src="/../images/image-20230414103359727.png" alt="image-20230414103359727"></p><h2 id="引导扇区代码-bootsect-s（实模式下运行的16位汇编代码程序，8086汇编语言）"><a href="#引导扇区代码-bootsect-s（实模式下运行的16位汇编代码程序，8086汇编语言）" class="headerlink" title="引导扇区代码:bootsect.s（实模式下运行的16位汇编代码程序，8086汇编语言）"></a>引导扇区代码:bootsect.s（实模式下运行的16位汇编代码程序，8086汇编语言）</h2><p>bootsect.s是操作系统的引导程序，是操作系统执行的第一个程序，bootsect.s工作如下：</p><p>1、将自己的程序搬运到0x9000开始的位置（为后续的system的挪用腾出位置），也就是将0x07c0:0x0000处的256个字全部移动到0x9000，然后跳转到0x90000+go处执行程序，bootsect.s的大小不会超过一个扇区，磁盘的0扇区只存bootsect.s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">_start:   ！第46行<br>movax,#BOOTSEG<br>movds,ax<br>movax,#INITSEG<br>moves,ax<br>movcx,#256<br>subsi,si<br>subdi,di<br>rep   <br>movw    ！将自己搬到0X90000处<br>jmpigo,INITSEG    ！跳转至0X90000+go 处执行程序<br>go:movax,cs<br></code></pre></td></tr></table></figure><p>注：jmpi     ip，cs</p><p>2、将setup从磁盘第2块扇区开始到第4块扇区加载到内存0x90200位置处，也就是紧接着bootsect。然后利用BIOS中断(int 0x13) 取磁盘参数表中当前启动引导盘的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">load_setup:     ！第67行<br>movdx,#0x0000! drive 0, head 0<br>movcx,#0x0002! sector 2, track 0<br>movbx,#0x0200! address = 512, in INITSEG<br>movax,#0x0200+SETUPLEN! service 2, nr of sectors<br>int0x13! read it<br>jncok_load_setup! ok - continue<br></code></pre></td></tr></table></figure><p>注：0x13是BIOS读磁盘扇区的中断。</p><p>3、接着在屏幕上显示”Loading system“</p><p>4、读入setup模块以后：ok_load_setup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Ok_load_setup: //载入setup模块<br>    mov dl,#0x00 mov ax,#0x0800 //ah=8获得磁盘参数<br>    int 0x13 mov ch,#0x00 mov sectors,cx<br>    mov ah,#0x03 xor bh,bh int 0x10 //读光标<br>    mov cx,#24 mov bx,#0x0007<br>    mov bp,#msg1 mov ax,#1301 int 0x10 //显示字符<br>    mov ax,#SYSSEG //SYSSEG=0x1000 <br>    mov es,ax <br>    call read_it //读入system模块<br>    jmpi 0,SETUPSEG<br></code></pre></td></tr></table></figure><p>5、读入system模块</p><p>将 system 模块的代码从磁盘搬到内存0x10000开始的位置。SYSSIZE = 0x3000 is 0x30000 bytes = 196kB 。Linux0.11中默认内核大小不会超过196KB。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movax,#SYSSEG   ！第107行<br>moves,ax! segment of 0x010000<br>callread_it<br>...<br>read_it:<br>...<br>read_track:<br>...<br>mov dx,head  ！head.s是system模块的第一个程序<br>mov dh,dl<br>mov dl,#0<br>and dx,#0x0100<br>mov ah,#2<br>int 0x13   !这才是正式开始搬运system模块。<br>...<br></code></pre></td></tr></table></figure><p>因为system模块可能很大，要跨越磁道，所以需要定义一个函数。</p><p>6、确定根文件系统的设备号。</p><p>7、跳转至setup执行，移交控制权</p><p><strong>bootsect.s的工作总结:bootsect.s主要就是加载setup和读system</strong></p><h2 id="操作系统的启动setup-s（实模式下运行的-16-位汇编代码程序，8086-汇编语言）"><a href="#操作系统的启动setup-s（实模式下运行的-16-位汇编代码程序，8086-汇编语言）" class="headerlink" title="操作系统的启动setup.s（实模式下运行的 16 位汇编代码程序，8086 汇编语言）"></a>操作系统的启动setup.s（实模式下运行的 16 位汇编代码程序，8086 汇编语言）</h2><p>setup是一个操作系统加载程序，就是完成OS启动前的设置，setup的工作如下：</p><p>1、利用BIOS的中断获取计算机参数（内存大小，磁盘参数、显示器参数等），并将参数存入0X90000开始的位置（将bootsect.s覆盖掉）。获取的参数如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/17731575-630c494ee7d7cf66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/766/format/webp" alt="img"></p><p>2、将system模块从 0x10000 - 0x8ffff (当时认为内核系统模块 system 的长度不会超过此值 512KB) 整块向下移动到内存绝对地址 0x00000 处。这意味着原来的 BIOS 中断向量表被覆盖了（问题：中断向量表是用来干什么的）。</p><p>3、接下来加载中断描述符表寄存器（idtr）和全局描述符寄存器（gdtr），建立idt和gdt，但是这只是个临时表，之后会重新设置gdt和idt，这里是为了方便cpu进入保护模式时能正确寻址（这里主要是为了保证能跳到system模块执行）。设置8259芯片，重新设置中断向量表。</p><p>4、设置CPU控制寄存器CR0（称为机器状态字），CPU进入32位保护模式，程序跳转到物理内存起始位置开始执行。保护模式下和实模式下的int n和cs:ip解释不同。</p><p>5、最后跳转到位于system模块最前面的head.s程序继续执行。</p><p><strong>补充1：cr0寄存器</strong></p><ul><li>  PE端=0 为实模式</li><li>  PE端=1 为保护模式</li><li>  PG端=1 启动分页</li></ul><p><strong>补充2：32位的寻址方式</strong></p><p>因为20位地址只能够寻址1M的寻址范围，所以需要32位寻址范围为4G。</p><ul><li>  CS成为选择子：放置查表索引</li><li>  根据表项产生地址</li><li>  <strong>setup需初始化GDT表</strong></li><li>  使用GDT表项，将jmp 0,8（setup.s末句）寻址为0地址</li></ul><p><strong>补充3：中断处理IDT</strong>(待补充)</p><h2 id="执行head-s（运行在保护模式下的-32-位汇编代码程序，AT-amp-T-语法的汇编语言程序）"><a href="#执行head-s（运行在保护模式下的-32-位汇编代码程序，AT-amp-T-语法的汇编语言程序）" class="headerlink" title="执行head.s（运行在保护模式下的 32 位汇编代码程序，AT&amp;T 语法的汇编语言程序）"></a>执行head.s（运行在保护模式下的 32 位汇编代码程序，AT&amp;T 语法的汇编语言程序）</h2><p>它将进一步进行操作系统的初始化，head.s 程序在被编译生成目标文件后会与内核其他程序一起被链接成 system 模块，位于 system 模块的最前面开始部分。从这里开始内核就完全在保护模式下运行了，该程序位于内存绝对地址为0处开始。</p><p>工作内容：</p><p>1、首先加载各个数据段寄存器，重新设置IDT</p><p>2、重新设置GDT</p><p>3、检查A20地址线是否打开</p><p>4、设置管理内存的分页处理机制，将页目录表放在绝对物理地址0开始处。</p><p>5、最后heads程序返回指令将预先放置在堆栈中的main.c程序入口弹出，运行main()。</p><p><strong>补充1：</strong></p><p>heads怎么跳到main函数的？从汇编语言跳到c语言要经过怎么样的操作？</p><p>答：首先先将参数、返回值、main压入栈，然后通过ret一个一个出栈，如下图所示：</p><p><img src="/../images/image-20230414144150917.png" alt="image-20230414144150917"></p><p>main是一个永远都不会退出的程序，因为退出就会造成死机。</p><p><strong>补充2</strong>：</p><p>mem_init初始化过程</p><p><img src="/../images/image-20230414144613600.png" alt="image-20230414144613600"></p><p>以上的代码就是初始化了一个称为mem_map的表结构，有些表不为空就说明是存放操作系统的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>操作系统启动加载的过程简单来说就是：以加载mem_init()为例子：bootsect.s-&gt;setup.s-&gt;head.s-&gt;main()-&gt;mem_init()</p><h1 id="实验一：操作系统的引导"><a href="#实验一：操作系统的引导" class="headerlink" title="实验一：操作系统的引导"></a>实验一：操作系统的引导</h1>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习记录本</title>
    <link href="/2024/02/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E6%9C%AC/"/>
    <url>/2024/02/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="accumulation"><a href="#accumulation" class="headerlink" title="accumulation"></a>accumulation</h1><ul><li>  <code>netstat -ano | findstr</code>window中查看端口</li><li>  taskkill /F /PID 315144结束进程</li></ul><h1 id="question"><a href="#question" class="headerlink" title="question"></a>question</h1><ul><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录24-2月</title>
    <link href="/2024/02/01/%E8%AE%B0%E5%BD%9524-2%E6%9C%88/"/>
    <url>/2024/02/01/%E8%AE%B0%E5%BD%9524-2%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<h1 id="February"><a href="#February" class="headerlink" title="February"></a>February</h1><ul><li>  [ ] 伙伴匹配系统完成（4h）()</li><li>  [ ] MIS-family项目完成（有时间做）(10h)</li><li>  [ ] 微服务框架学习（20h）</li><li>  [ ] 黑马头条项目完成（20h）</li><li>  [ ] Redis黑马课程实战篇（15h）</li><li>  [ ] 并发控制黑马视频课+《并发实战》（15h）</li><li>  [ ] JVM视频课（15h）</li><li>  [ ] OJ项目完成（30h）</li><li>  [ ] 数据库mysql，mybatis，mybatisplus（3h）</li><li>  [ ] 计算机网络（30min/day）(空闲时间)</li><li>  [ ] 代码随想录（1h/day）</li><li>  [ ] 《算法笔记》+PAT真题所有2遍（1h/day）</li><li>  [ ] 操作系统（30min/day）(空闲时间)</li><li>  [ ] 其他知识点（1h/day）</li></ul><h1 id="Part-One（2-1—2-8）"><a href="#Part-One（2-1—2-8）" class="headerlink" title="Part One（2-1—2-8）"></a>Part One（2-1—2-8）</h1><ul><li>  [ ] 伙伴匹配系统完成（4h）</li><li>  [ ] MIS-family项目完成（有时间做）(10h)</li><li>  [ ] 微服务框架学习（20h）</li><li>  [ ] 黑马头条项目完成（20h）</li><li>  [ ] Redis黑马课程实战篇（15h）</li><li>  [ ] 代码随想录+剑指offer（Java实现）（1h/day)</li><li>  [ ] 《算法笔记》+PAT（c++）（1h/day）</li><li>  [ ] 《TCP/IP》（30min/day）</li><li>  [ ] 《CSAPP》（30min/day）</li></ul><h1 id="24-2-1"><a href="#24-2-1" class="headerlink" title="24-2-1"></a>24-2-1</h1><ul><li>  [x] 伙伴匹配系统完成（4h）（2h30min）</li><li>  [x] Redis实战2篇（1h）（40min）</li><li>  [x] 微服务框架Day03（1h）(40min)</li><li>  [ ] 黑马头条Day02（1h）（45min）</li><li>  [ ] 代码随想录数组+字符串+哈希表（1h）</li><li>  [ ] 《算法笔记》1-3章+习题册（1h）</li><li>  [ ] 《TCPIP》第二章（30min）</li><li>  [x] 《CSAPP》(30min)（45min）</li><li>  [ ] 《深入理解JVM》（30min）</li><li>  [ ] 牛客Java刷题（30min）</li><li>  [ ] 毕业论文方法确定</li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>日常记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伙伴匹配项目笔记</title>
    <link href="/2024/01/31/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/31/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="鱼泡-伙伴匹配系统"><a href="#鱼泡-伙伴匹配系统" class="headerlink" title="鱼泡 - 伙伴匹配系统"></a>鱼泡 - 伙伴匹配系统</h1><p>介绍：帮助大家找到志同道合的伙伴，移动端 H5 网页（尽量兼容 PC 端）</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>用户去添加标签，标签的分类（要有哪些标签、怎么把标签进行分类）学习方向 java / c++，工作 / 大学</li><li>主动搜索：允许用户根据标签去搜索其他用户<ol><li>Redis 缓存</li></ol></li><li>组队<ol><li>创建队伍</li><li>加入队伍</li><li>根据标签查询队伍</li><li>邀请其他人</li></ol></li><li>允许用户去修改标签</li><li>推荐<ol><li>相似度计算算法 + 本地分布式计算</li></ol></li></ol><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>Vue 3 开发框架（提高页面开发的效率）</li><li>Vant UI（基于 Vue 的移动端组件库）（React 版 Zent）</li><li>Vite 2（打包工具，快！）</li><li>Nginx 来单机部署</li></ol><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li>Java 编程语言 + SpringBoot 框架</li><li>SpringMVC + MyBatis + MyBatis Plus（提高开发效率）</li><li>MySQL 数据库</li><li>Redis 缓存</li><li>Swagger + Knife4j 接口文档</li></ol><h2 id="第一期计划"><a href="#第一期计划" class="headerlink" title="第一期计划"></a>第一期计划</h2><ol><li>前端项目初始化 15 min √</li><li>前端主页 + 组件概览 15 min √</li><li>数据库表设计 15 min √<ol><li>标签表</li><li>用户表</li></ol></li><li>初始化后端项目</li><li>开发后端 - 根据标签搜索用户 30 min</li><li>开发前端 - 根据标签搜索用户 20 min</li></ol><h2 id="前端项目初始化"><a href="#前端项目初始化" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h2><p>用脚手架初始化项目</p><ul><li>Vue CLI <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></li><li><strong>Vite 脚手架</strong> ：<a href="https://vitejs.cn/guide/#scaffolding-your-first-vite-project">https://vitejs.cn/guide/#scaffolding-your-first-vite-project</a></li></ul><p>整合组件库 Vant：</p><ul><li>安装 Vant</li><li>按需引入 npm i <a href="mailto:&#x76;&#105;&#116;&#x65;&#45;&#112;&#x6c;&#117;&#x67;&#x69;&#x6e;&#45;&#x73;&#x74;&#x79;&#108;&#101;&#x2d;&#105;&#109;&#x70;&#x6f;&#114;&#x74;&#x40;&#49;&#46;&#x34;&#46;&#x31;">&#x76;&#105;&#116;&#x65;&#45;&#112;&#x6c;&#117;&#x67;&#x69;&#x6e;&#45;&#x73;&#x74;&#x79;&#108;&#101;&#x2d;&#105;&#109;&#x70;&#x6f;&#114;&#x74;&#x40;&#49;&#46;&#x34;&#46;&#x31;</a> -D</li></ul><p>开发页面经验：</p><ol><li>多参考</li><li>从整体到局部</li><li>先想清楚页面要做成什么样子，再写代码</li></ol><h2 id="前端主页-组件概览-15-min"><a href="#前端主页-组件概览-15-min" class="headerlink" title="前端主页 + 组件概览 15 min"></a>前端主页 + 组件概览 15 min</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>导航条：展示当前页面名称</p><p>主页搜索框 =&gt; 搜索页 =&gt; 搜索结果页（标签筛选页）</p><p>内容</p><p>tab 栏：</p><ul><li>主页（推荐页 + <strong>广告</strong> ）<ul><li>搜索框</li><li>banner</li><li>推荐信息流</li></ul></li><li>队伍页</li><li>用户页（消息 - 暂时考虑发邮件）</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>很多页面要复用组件 / 样式，重复写很麻烦、不利于维护，所以抽象一个通用的布局（Layout）</p><p>组件化</p><h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><p>标签的分类（要有哪些标签、怎么把标签进行分类）</p><h3 id="新增标签表（分类表）"><a href="#新增标签表（分类表）" class="headerlink" title="新增标签表（分类表）"></a>新增标签表（分类表）</h3><p>建议用标签，不要用分类，更灵活。</p><p>性别：男、女</p><p>方向：Java、C++、Go、前端</p><p>正在学：Spring</p><p>目标：考研、春招、秋招、社招、考公、竞赛（蓝桥杯）、转行、跳槽</p><p>段位：初级、中级、高级、王者</p><p>身份：小学、初中、高中、大一、大二、大三、大四、学生、待业、已就业、研一、研二、研三</p><p>状态：乐观、有点丧、一般、单身、已婚、有对象</p><p><strong>【用户自己定义标签】？</strong></p><p>字段：</p><p>id int 主键</p><p>标签名 varchar 非空（必须唯一，唯一索引）</p><p>上传标签的用户 userId int（如果要根据 userId 查已上传标签的话，最好加上，普通索引）</p><p>父标签 id ，parentId，int（分类）</p><p>是否为父标签 isParent, tinyint（0 不是父标签、1 - 父标签）</p><p>创建时间 createTime，datetime</p><p>更新时间 updateTime，datetime</p><p>是否删除 isDelete， tinyint（0、1）</p><p>怎么查询所有标签，并且把标签分好组？按父标签 id 分组，能实现 √</p><p>根据父标签查询子标签？根据 id 查询，能实现 √</p><p>SQL 语言分类：</p><p>DDL define 建表、操作表</p><p>DML manage 更新删除数据，影响实际表里的内容</p><p>DCL control 控制，权限</p><p>DQL query 查询，select</p><p><a href="https://www.cnblogs.com/fan-yuan/p/7879353.html">https://www.cnblogs.com/fan-yuan/p/7879353.html</a></p><h3 id="修改用户表"><a href="#修改用户表" class="headerlink" title="修改用户表"></a>修改用户表</h3><p>用户有哪些标签？</p><p><strong>根据自己的实际需求来！！！</strong> 此处选择第一种</p><ol><li><p>直接在用户表补充 tags 字段，**[‘Java’, ‘男’] 存 json 字符串 ** </p><p> 优点：查询方便、不用新建关联表，标签是用户的固有属性（除了该系统、其他系统可能要用到，标签是用户的固有属性）节省开发成本</p><p> <strong>查询用户列表，查关系表拿到这 100 个用户有的所有标签 id，再根据标签 id 去查标签表。</strong></p><p> 哪怕性能低，可以用缓存。</p><p> 缺点：用户表多一列，会有点</p></li><li><p>加一个关联表，记录用户和标签的关系</p><p> 关联表的应用场景：查询灵活，可以正查反查</p><p> 缺点：要多建一个表、多维护一个表</p><p> 重点：企业大项目开发中尽量减少关联查询，很影响扩展性，而且会影响查询性能</p></li></ol><h3 id="开发后端接口"><a href="#开发后端接口" class="headerlink" title="开发后端接口"></a>开发后端接口</h3><h4 id="搜索标签"><a href="#搜索标签" class="headerlink" title="搜索标签"></a>搜索标签</h4><ol><li>允许用户传入多个标签，多个标签都存在才搜索出来 and。like ‘%Java%’ and like ‘%C++%’。</li><li>允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%Java%’ or like ‘%C++%’</li></ol><p>两种方式：</p><ol><li>SQL 查询（实现简单，可以通过拆分查询进一步优化）</li><li>内存查询（灵活，可以通过并发进一步优化）</li></ol><ul><li><p>如果参数可以分析，根据用户的参数去选择查询方式，比如标签数</p></li><li><p>如果参数不可分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁。</p></li><li><p>还可以 SQL 查询与内存计算相结合，比如先用 SQL 过滤掉部分 tag</p></li></ul><p>建议通过实际测试来分析哪种查询比较快，数据量大的时候验证效果更明显！</p><p>解析 JSON 字符串：</p><p>序列化：java对象转成 json</p><p>反序列化：把 json 转为 java 对象</p><p>java  json 序列化库有很多：</p><ol><li><p><strong>gson</strong>（google 的）</p></li><li><p>fastjson alibaba（ali 出品，快，但是漏洞太多）</p></li><li><p>jackson</p></li><li><p>kryo</p></li></ol><h2 id="用户中心来集中提供用户的检索、操作、注册、登录、鉴权"><a href="#用户中心来集中提供用户的检索、操作、注册、登录、鉴权" class="headerlink" title="用户中心来集中提供用户的检索、操作、注册、登录、鉴权"></a>用户中心来集中提供用户的检索、操作、注册、登录、鉴权</h2><h2 id="中-2022-05-29"><a href="#中-2022-05-29" class="headerlink" title="中 2022-05-29"></a>中 2022-05-29</h2><p>本次直播内容（计划）： </p><ol><li><strong>上次的标签接口调试</strong> 5 min √</li><li>前端整合路由 5min √</li><li>前端开发（搜索页面、用户信息页、用户信息修改页）30 - 50min √</li><li>后端整合 Swagger + Knife4j 接口文档 10 - 15min</li><li>存量用户信息导入及同步（爬虫） 40 min</li></ol><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><ol><li>stream / parallelStream 流失处理</li><li>Optional 可选类</li></ol><h3 id="前端整合路由"><a href="#前端整合路由" class="headerlink" title="前端整合路由"></a>前端整合路由</h3><p>Vue-Router：<a href="https://router.vuejs.org/zh/guide/#html%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9C%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%BC%95%E5%85%A5">https://router.vuejs.org/zh/guide/#html，直接看官方文档引入</a></p><p>Vue-Router 其实就是帮助你根据不同的 url 来展示不同的页面（组件），不用自己写 if / else</p><p>路由配置影响整个项目，所以建议单独用 config 目录、单独的配置文件去集中定义和管理。</p><p>有些组件库可能自带了和 Vue-Router 的整合，所以尽量先看组件文档、省去自己写的时间。</p><h2 id="下-2022-06-05"><a href="#下-2022-06-05" class="headerlink" title="下 2022-06-05"></a>下 2022-06-05</h2><ol><li>Java 后端整合 Swagger + Knife4j 接口文档 10 min √</li><li>存量用户信息导入及同步（爬虫） 30 min - 40 min</li><li></li><li>前后端联调：搜索页面、用户信息页、用户信息修改页 30 - 40 min</li><li>标签内容整理 15 min</li><li>部分细节优化  todo</li></ol><h2 id="后端整合-Swagger-Knife4j-接口文档"><a href="#后端整合-Swagger-Knife4j-接口文档" class="headerlink" title="后端整合 Swagger + Knife4j 接口文档"></a>后端整合 Swagger + Knife4j 接口文档</h2><p>什么是接口文档？写接口信息的文档，每条接口包括：</p><ul><li>请求参数</li><li>响应参数<ul><li>错误码</li></ul></li><li>接口地址</li><li>接口名称</li><li>请求类型</li><li>请求格式</li><li>备注</li></ul><p>who 谁用？一般是后端或者负责人来提供，后端和前端都要使用</p><p>为什么需要接口文档？</p><ul><li>有个书面内容（背书或者归档），便于大家参考和查阅，便于 <strong>沉淀和维护</strong> ，拒绝口口相传</li><li>接口文档便于前端和后端开发对接，前后端联调的 <strong>介质</strong> 。后端 =&gt; 接口文档 &lt;= 前端</li><li>好的接口文档支持在线调试、在线测试，可以作为工具提高我们的开发测试效率</li></ul><p>怎么做接口文档？</p><ul><li>手写（比如腾讯文档、Markdown 笔记）</li><li>自动化接口文档生成：自动根据项目代码生成完整的文档或在线调试的网页。Swagger，Postman（侧重接口管理）（国外）；apifox、apipost、eolink（国产）</li></ul><p>接口文档有哪些技巧？</p><p>Swagger 原理：</p><ol><li>引入依赖（Swagger 或 Knife4j：<a href="https://doc.xiaominfo.com/knife4j/documentation/get_start.html%EF%BC%89">https://doc.xiaominfo.com/knife4j/documentation/get_start.html）</a></li><li>自定义 Swagger 配置类</li><li>定义需要生成接口文档的代码位置（Controller）</li><li>千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 <code>@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</code> 限定配置仅在部分环境开启</li><li>启动即可</li><li>可以通过在 controller 方法上添加 @Api、@ApiImplicitParam(name = “name”,value = “姓名”,required = true)    @ApiOperation(value = “向客人问好”) 等注解来自定义生成的接口描述信息</li></ol><p>如果 springboot version &gt;= 2.6，需要添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><p>todo 怎么隐藏</p><h2 id="存量用户信息导入及同步"><a href="#存量用户信息导入及同步" class="headerlink" title="存量用户信息导入及同步"></a>存量用户信息导入及同步</h2><ol><li>把所有星球用户的信息导入</li><li>把写了自我介绍的同学的标签信息导入</li></ol><p>FeHelper 前端辅助插件，推荐安装</p><h3 id="看上了网页信息，怎么抓到？"><a href="#看上了网页信息，怎么抓到？" class="headerlink" title="看上了网页信息，怎么抓到？"></a>看上了网页信息，怎么抓到？</h3><ol><li>分析原网站是怎么获取这些数据的？哪个接口？</li></ol><p>按 F 12 打开控制台，查看网络请求，复制 curl 代码便于查看和执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;https://api.zsxq.com/v2/hashtags/48844541281228/topics?count=20&quot;</span> ^<br>  -H <span class="hljs-string">&quot;authority: api.zsxq.com&quot;</span> ^<br>  -H <span class="hljs-string">&quot;accept: application/json, text/plain, */*&quot;</span> ^<br>  -H <span class="hljs-string">&quot;accept-language: zh-CN,zh;q=0.9&quot;</span> ^<br>  -H <span class="hljs-string">&quot;cache-control: no-cache&quot;</span> ^<br>  -H <span class="hljs-string">&quot;origin: https://wx.zsxq.com&quot;</span> ^<br>  -H <span class="hljs-string">&quot;pragma: no-cache&quot;</span> ^<br>  -H <span class="hljs-string">&quot;referer: https://wx.zsxq.com/&quot;</span> ^<br>  --compressed<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>用程序去调用接口</strong> （java okhttp httpclient / python 都可以）</li><li>处理（清洗）一下数据，之后就可以写到数据库里</li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>从 excel 中导入全量用户数据，<strong>判重</strong> 。 easy excel：<a href="https://alibaba-easyexcel.github.io/index.html">https://alibaba-easyexcel.github.io/index.html</a></li><li>抓取写了自我介绍的同学信息，提取出用户昵称、用户唯一 id、自我介绍信息</li><li>从自我介绍中提取信息，然后写入到数据库中</li></ol><h4 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h4><p>两种读对象的方式：</p><ol><li>确定表头：建立对象，和表头形成映射关系</li><li>不确定表头：每一行数据映射为 Map&lt;String, Object&gt;</li></ol><p>两种读取模式：</p><ol><li>监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清晰易于维护；一条一条处理，适用于数据量大的场景。</li><li>同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。</li></ol><h2 id="2022-06-12-【4】"><a href="#2022-06-12-【4】" class="headerlink" title="2022-06-12 【4】"></a>2022-06-12 【4】</h2><ol><li>页面和功能开发<ol><li>搜索页面</li><li>用户信息</li><li>用户修改页面</li></ol></li><li>改造用户中心，把单机登录改为分布式 session 登录</li><li>标签的整理、细节的优化</li></ol><h3 id="前端页面跳转传值"><a href="#前端页面跳转传值" class="headerlink" title="前端页面跳转传值"></a>前端页面跳转传值</h3><ol><li>query =&gt; url searchParams，url 后附加参数，传递的值长度有限</li><li>vuex（全局状态管理），搜索页将关键词塞到状态中，搜索结果页从状态取值</li></ol><h2 id="Session-共享"><a href="#Session-共享" class="headerlink" title="Session 共享"></a>Session 共享</h2><p>种 session 的时候注意范围，cookie.domain</p><p>比如两个域名：</p><p>aaa.yupi.com</p><p>bbb.yupi.com</p><p>如果要共享 cookie，可以种一个更高层的公共域名，比如 yupi.com</p><h3 id="为什么服务器-A-登录后，请求发到服务器-B，不认识该用户？"><a href="#为什么服务器-A-登录后，请求发到服务器-B，不认识该用户？" class="headerlink" title="为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？"></a>为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？</h3><p>用户在 A 登录，所以 session（用户登录信息）存在了 A 上</p><p>结果请求 B 时，B 没有用户信息，所以不认识。</p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220612234247152.png"></p><p>解决方案：<strong>共享存储</strong> ，而不是把数据放到单台服务器的内存中</p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220612234335539.png"></p><p>如何共享存储？</p><ol><li>Redis（基于内存的 K / V 数据库）此处选择 Redis，因为用户信息读取 / 是否登录的判断极其<strong>频繁</strong> ，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w</li><li>MySQL </li><li>文件服务器 ceph</li></ol><h3 id="Session-共享实现"><a href="#Session-共享实现" class="headerlink" title="Session 共享实现"></a>Session 共享实现</h3><h4 id="1-安装-Redis"><a href="#1-安装-Redis" class="headerlink" title="1. 安装 Redis"></a>1. 安装 Redis</h4><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>windows 下载：</p><p>Redis 5.0.14 下载：</p><p>链接：<a href="https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg">https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg</a> </p><p>提取码：vkoi </p><p>redis 管理工具 quick redis：<a href="https://quick123.net/">https://quick123.net/</a></p><ol start="2"><li>引入 redis，能够操作 redis：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>修改 spring-session 存储配置 <code>spring.session.store-type</code></p><p> 默认是 none，表示存储在单台服务器</p><p> store-type: redis，表示从 redis 读写 session</p></li></ol><p>JWT 的优缺点：<a href="https://zhuanlan.zhihu.com/p/108999941">https://zhuanlan.zhihu.com/p/108999941</a></p><h2 id="todo-待优化"><a href="#todo-待优化" class="headerlink" title="todo 待优化"></a>todo 待优化</h2><p>前端：动态展示页面标题、微调格式</p><h2 id="2022-07-03-伙伴匹配系统-5"><a href="#2022-07-03-伙伴匹配系统-5" class="headerlink" title="2022-07-03 伙伴匹配系统 5"></a>2022-07-03 伙伴匹配系统 5</h2><ol><li>用户修改页面前端、后端开发和联调</li></ol><h2 id="2022-07-17-伙伴匹配系统-6"><a href="#2022-07-17-伙伴匹配系统-6" class="headerlink" title="2022-07-17 伙伴匹配系统 6"></a>2022-07-17 伙伴匹配系统 6</h2><ol><li>开发主页（默认推荐和自己兴趣相当的用户）</li><li>优化主页的性能（缓存 + 定时任务 + 分布式锁）</li></ol><h3 id="开发主页"><a href="#开发主页" class="headerlink" title="开发主页"></a>开发主页</h3><p>最简单：直接 list 列表</p><p>模拟 1000 万个用户，再去查询</p><h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><ol><li><p>用可视化界面：适合一次性导入、数据量可控</p></li><li><p>写程序：for 循环，建议分批，不要一把梭哈（可以用接口来控制）<strong>要保证可控、幂等，注意线上环境和测试环境是有区别的</strong></p><p> 导入 1000 万条，for i 1000w</p></li><li><p>执行 SQL 语句：适用于小数据量</p></li></ol><h4 id="编写一次性任务"><a href="#编写一次性任务" class="headerlink" title="编写一次性任务"></a>编写一次性任务</h4><p>for 循环插入数据的问题：</p><ol><li>建立和释放数据库链接（批量查询解决）</li><li>for 循环是绝对线性的（并发）</li></ol><p>并发要注意执行的先后顺序无所谓，不要用到非并发类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">16</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10000</span>));<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> CPU 密集型：分配的核心线程数 = CPU - <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span> IO 密集型：分配的核心线程数可以大于 CPU 核数<br></code></pre></td></tr></table></figure><p>数据库慢？预先把数据查出来，放到一个更快读取的地方，不用再查数据库了。（缓存）</p><p>预加载缓存，定时更新缓存。（定时任务）</p><p>多个机器都要执行任务么？（分布式锁：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了）</p><h2 id="数据查询慢怎么办？"><a href="#数据查询慢怎么办？" class="headerlink" title="数据查询慢怎么办？"></a>数据查询慢怎么办？</h2><p>用缓存：提前把数据取出来保存好（通常保存到读写更快的介质，比如内存），就可以更快地读写。</p><h3 id="缓存的实现"><a href="#缓存的实现" class="headerlink" title="缓存的实现"></a>缓存的实现</h3><ul><li>Redis（分布式缓存）</li><li>memcached（分布式）</li><li>Etcd（云原生架构的一个分布式存储，<strong>存储配置</strong>，扩容能力）</li></ul><hr><ul><li><p>ehcache（单机）</p></li><li><p>本地缓存（Java 内存 Map）</p></li><li><p>Caffeine（Java 内存缓存，高性能）</p></li><li><p>Google Guava</p></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote><p>NoSQL 数据库</p></blockquote><p>key - value 存储系统（区别于 MySQL，他存储的是键值对）</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>String 字符串类型： name: “yupi”</p><p>List 列表：names: [“yupi”, “dogyupi”, “yupi”]</p><p>Set 集合：names: [“yupi”, “dogyupi”]（值不能重复）</p><p>Hash 哈希：nameAge: {  “yupi”: 1, “dogyupi”: 2 }</p><p>Zset 集合：names: {  yupi - 9,   dogyupi - 12  }（适合做排行榜）</p><hr><p>bloomfilter（布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截）</p><p>geo（计算地理位置）</p><p>hyperloglog（pv / uv）</p><p>pub / sub（发布订阅，类似消息队列）</p><p>BitMap （1001010101010101010101010101）</p><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yupao.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTemplateConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(connectionFactory);<br>        redisTemplate.setKeySerializer(RedisSerializer.string());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引入一个库时，先写测试类</p></blockquote><h3 id="Java-里的实现方式"><a href="#Java-里的实现方式" class="headerlink" title="Java 里的实现方式"></a>Java 里的实现方式</h3><h4 id="Spring-Data-Redis（推荐）"><a href="#Spring-Data-Redis（推荐）" class="headerlink" title="Spring Data Redis（推荐）"></a>Spring Data Redis（推荐）</h4><p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong> 的接口</p><p>mysql、redis、jpa</p><p><a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">spring-data-redis</a></p><p>1）引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置 Redis 地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># redis 配置</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>独立于 Spring 操作 Redis 的 Java 客户端</p><p>要配合 Jedis Pool 使用</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p><strong>高阶</strong> 的操作 Redis 的 Java 客户端</p><p>异步、连接池</p><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>分布式操作 Redis 的 Java 客户端，让你像在使用本地的集合一样操作 Redis（分布式 Redis 数据网格）</p><h4 id="JetCache"><a href="#JetCache" class="headerlink" title="JetCache"></a>JetCache</h4><p>对比</p><ol><li>如果你用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便</li><li>如果你用的不是 SPring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool</li><li>如果你的项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池</li></ol><hr><ul><li>如果你的项目是分布式的，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐用 redisson</li></ul><h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>不同用户看到的数据不同</p><p>systemId:moduleId:func:options（不要和别人冲突）</p><p>yupao:user:recommed:userId</p><p><strong>redis 内存不能无限增加，一定要设置过期时间！！！</strong></p><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>问题：第一个用户访问还是很慢（加入第一个老板），也能一定程度上保护数据库</p><p>缓存预热的优点：</p><ol><li>解决上面的问题，可以让用户始终访问很快</li></ol><p>缺点：</p><ol><li>增加开发成本（你要额外的开发、设计）</li><li>预热的时机和时间如果错了，有可能你缓存的数据不对或者太老</li><li>需要占用额外空间</li></ol><h4 id="怎么缓存预热？"><a href="#怎么缓存预热？" class="headerlink" title="怎么缓存预热？"></a>怎么缓存预热？</h4><ol><li>定时</li><li>模拟触发（手动触发）</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>用定时任务，每天刷新所有用户的推荐列表</p><p>注意点：</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处每天一次）</li></ol><blockquote><p>分析优缺点的时候，要打开思路，从整个项目从 0 到 1 的链路上去分析</p></blockquote><h3 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h3><ol><li><strong>Spring Scheduler（spring boot 默认整合了）</strong> </li><li>Quartz（独立于 Spring 存在的定时任务框架）</li><li>XXL-Job 之类的分布式任务调度平台（界面 + sdk）</li></ol><p>第一种方式：</p><ol><li>主类开启 @EnableScheduling</li><li>给要定时执行的方法添加 @Scheduling 注解，指定 cron 表达式或者执行频率</li></ol><p>不要去背 cron 表达式！！！！！</p><ul><li><a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li><li><a href="https://www.matools.com/crontab/">https://www.matools.com/crontab/</a></li></ul><hr><h3 id="控制定时任务的执行"><a href="#控制定时任务的执行" class="headerlink" title="控制定时任务的执行"></a>控制定时任务的执行</h3><p>为啥？</p><ol><li>浪费资源，想象 10000 台服务器同时 “打鸣”</li><li>脏数据，比如重复插入</li></ol><p><strong>要控制定时任务在同一时间只有 1 个服务器能执行。</strong></p><p>怎么做？</p><ol><li><p>分离定时任务程序和主程序，只在 1 个服务器运行定时任务。成本太大</p></li><li><p>写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本最低；但是我们的 IP 可能是不固定的，把 IP 写的太死了</p></li><li><p>动态配置，配置是可以轻松的、很方便地更新的（<strong>代码无需重启</strong>），但是只有 ip 符合配置的服务器才真实执行业务逻辑。</p><ul><li>数据库</li><li>Redis</li><li>配置中心（Nacos、Apollo、Spring Cloud Config）</li></ul><p> 问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改</p></li><li><p>分布式锁，只有抢到锁的服务器才能执行业务逻辑。坏处：增加成本；好处：不用手动配置，多少个服务器都一样。</p></li></ol><p><strong>单机就会存在单点故障。</strong></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>有限资源的情况下，控制同一时间（段）只有某些线程（用户 / 服务器）能访问到资源。</p><p>Java 实现锁：synchronized 关键字、并发包的类</p><p>问题：只对单个 JVM 有效</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>为啥需要分布式锁？</p><ol><li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 / 服务器）能访问到资源。</li><li>单个锁只对单个 JVM 有效</li></ol><h3 id="分布式锁实现的关键"><a href="#分布式锁实现的关键" class="headerlink" title="分布式锁实现的关键"></a>分布式锁实现的关键</h3><h4 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 个服务器能抢到锁？</p><p><strong>核心思想</strong> 就是：先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待。</p><p>等先来的人执行方法结束，把标识清空，其他的人继续抢锁。</p><p>MySQL 数据库：select for update 行级锁（最简单）</p><p>（乐观锁）</p><p>✔ Redis 实现：内存数据库，<strong>读写速度快</strong> 。支持 <strong>setnx</strong>、lua 脚本，比较方便我们实现分布式锁。</p><p>setnx：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>用完锁要释放（腾地方）√</p></li><li><p><strong>锁一定要加过期时间 √</strong></p></li><li><p>如果方法执行时间过长，锁提前过期了？</p><p> 问题：</p><ol><li>连锁效应：释放掉别人的锁</li><li>这样还是会存在多个方法同时执行的情况</li></ol></li></ol><p>​    解决方案：续期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!end)&#125;&#123;<br>    续期<br>&#125;)<br><br>end = <span class="hljs-literal">true</span>;<br><br></code></pre></td></tr></table></figure><ol start="4"><li><p>释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原子操作</span><br><span class="hljs-keyword">if</span>(get lock == A) &#123;<br>    <span class="hljs-comment">// set lock B</span><br>    del lock<br>&#125;<br></code></pre></td></tr></table></figure><p> Redis + lua 脚本实现</p></li><li><p>Redis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？</p></li></ol><p><a href="https://blog.csdn.net/feiying0canglang/article/details/113258494">https://blog.csdn.net/feiying0canglang/article/details/113258494</a></p><h4 id="拒绝自己写！！！"><a href="#拒绝自己写！！！" class="headerlink" title="拒绝自己写！！！"></a>拒绝自己写！！！</h4><h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Java 客户端，数据网格</p><p>实现了很多 Java 里支持的接口和数据结构</p><p>Redisson 是一个 java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。</strong></p><h4 id="2-种引入方式"><a href="#2-种引入方式" class="headerlink" title="2 种引入方式"></a>2 种引入方式</h4><ol><li>spring boot starter 引入（不推荐，版本迭代太快，容易冲突）<a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li><li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs setnx">// list，数据存在本地 JVM 内存中<br>List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.add(&quot;yupi&quot;);<br>System.out.println(&quot;list:&quot; + list.get(0));<br><br>list.remove(0);<br><br>// 数据存在 redis 的内存中<br>RList&lt;String&gt; rList = redissonClient.getList(&quot;test-list&quot;);<br>rList.add(&quot;yupi&quot;);<br>System.out.println(&quot;rlist:&quot; + rList.get(0));<br>rList.remove(0);<br></code></pre></td></tr></table></figure><h3 id="定时任务-锁"><a href="#定时任务-锁" class="headerlink" title="定时任务  + 锁"></a>定时任务  + 锁</h3><ol><li>waitTime 设置为 0，只抢一次，抢不到就放弃</li><li>注意释放锁要写在 finally 中</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void test<span class="hljs-constructor">WatchDog()</span> &#123;<br>    RLock lock = redissonClient.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;yupao:precachejob:docache:lock&quot;</span>)</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 只有一个线程能获取到锁</span><br>        <span class="hljs-keyword">if</span> (lock.<span class="hljs-keyword">try</span><span class="hljs-constructor">Lock(0, -1, TimeUnit.MILLISECONDS)</span>) &#123;<br>            <span class="hljs-comment">// todo 实际要执行的方法</span><br>            <span class="hljs-keyword">do</span><span class="hljs-constructor">SomeThings()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;getLock: &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Id()</span>);<br>        &#125;<br>    &#125; catch (InterruptedException e) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(e.get<span class="hljs-constructor">Message()</span>);<br>    &#125; finally &#123;<br>        <span class="hljs-comment">// 只能释放自己的锁</span><br>        <span class="hljs-keyword">if</span> (lock.is<span class="hljs-constructor">HeldByCurrentThread()</span>) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;unLock: &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Id()</span>);<br>            lock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="看门狗机制"><a href="#看门狗机制" class="headerlink" title="看门狗机制"></a>看门狗机制</h3><blockquote><p>redisson 中提供的续期机制</p></blockquote><p>开一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。</p><p>原理：</p><ol><li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）</li><li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li></ol><p><a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p><hr><p>Zookeeper 实现（不推荐）</p><h3 id="组队功能-1h"><a href="#组队功能-1h" class="headerlink" title="组队功能 1h"></a>组队功能 1h</h3><p>理解为王者荣耀</p><h4 id="理想的应用场景"><a href="#理想的应用场景" class="headerlink" title="理想的应用场景"></a>理想的应用场景</h4><p>我要跟别人一起参加竞赛或者做项目，可以发起队伍或者加入别人的队伍</p><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>用户可以 <strong>创建</strong> 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数</p><p>聊天？</p><p>公开 或 private 或加密</p><p><strong>用户创建队伍最多 5 个</strong></p></blockquote><p>展示队伍列表，根据名称搜索队伍  P0，信息流中不展示已过期的队伍</p><p>修改队伍信息 P0 ~ P1</p><p>用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是要有个上限  P0</p><blockquote><p>是否需要队长同意？筛选审批？</p></blockquote><p>用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 —— 先来后到） P1</p><p>队长可以解散队伍 P0</p><hr><p>分享队伍 =》 邀请其他用户加入队伍 P1</p><p>业务流程：</p><ol><li>生成分享链接（分享二维码）</li><li>用户访问链接，可以点击加入</li></ol><p>队伍人满后发送消息通知 P1</p><h4 id="系统（接口）设计"><a href="#系统（接口）设计" class="headerlink" title="系统（接口）设计"></a>系统（接口）设计</h4><h5 id="1、创建队伍"><a href="#1、创建队伍" class="headerlink" title="1、创建队伍"></a>1、创建队伍</h5><p>用户可以 <strong>创建</strong> 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数</p><p>聊天？</p><p>公开 或 private 或加密</p><p>信息流中不展示已过期的队伍</p></blockquote><ol><li>请求参数是否为空？</li><li>是否登录，未登录不允许创建</li><li>校验信息<ol><li>队伍人数 &gt; 1 且 &lt;= 20</li><li>队伍标题 &lt;= 20</li><li>描述 &lt;= 512</li><li>status 是否公开（int）不传默认为 0（公开）</li><li>如果 status 是加密状态，一定要有密码，且密码 &lt;= 32</li><li>超时时间 &gt; 当前时间</li><li>校验用户最多创建 5 个队伍</li></ol></li><li>插入队伍信息到队伍表</li><li>插入用户  =&gt; 队伍关系到关系表</li></ol><h5 id="2、查询队伍列表"><a href="#2、查询队伍列表" class="headerlink" title="2、查询队伍列表"></a>2、查询队伍列表</h5><p>分页展示队伍列表，根据名称、最大人数等搜索队伍  P0，信息流中不展示已过期的队伍</p><ol><li>从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件</li><li>不展示已过期的队伍（根据过期时间筛选）</li><li>可以通过某个<strong>关键词</strong>同时对名称和描述查询</li><li><strong>只有管理员才能查看加密还有非公开的房间</strong></li><li>关联查询已加入队伍的用户信息</li><li><strong>关联查询已加入队伍的用户信息（可能会很耗费性能，建议大家用自己写 SQL 的方式实现）</strong></li></ol><p><strong>实现方式</strong></p><p>1）自己写 SQL</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 自己写 SQL<br><span class="hljs-regexp">//</span> 查询队伍和创建人的信息<br><span class="hljs-regexp">//</span> select * from team t left join user u on t.userId = u.id<br><span class="hljs-regexp">//</span> 查询队伍和已加入队伍成员的信息<br><span class="hljs-regexp">//</span> select *<br><span class="hljs-regexp">//</span> from team t<br><span class="hljs-regexp">//</span>         left join user_team ut on t.id = ut.teamId<br><span class="hljs-regexp">//</span>         left join user u on ut.userId = u.id;<br></code></pre></td></tr></table></figure><h5 id="3-修改队伍信息"><a href="#3-修改队伍信息" class="headerlink" title="3. 修改队伍信息"></a>3. 修改队伍信息</h5><ol><li>判断请求参数是否为空</li><li>查询队伍是否存在</li><li>只有管理员或者队伍的创建者可以修改</li><li>如果用户传入的新值和老值一致，就不用 update 了（可自行实现，降低数据库使用次数）</li><li><strong>如果队伍状态改为加密，必须要有密码</strong></li><li>更新成功</li></ol><h5 id="4-用户可以加入队伍"><a href="#4-用户可以加入队伍" class="headerlink" title="4. 用户可以加入队伍"></a>4. 用户可以加入队伍</h5><p>其他人、未满、未过期，允许加入多个队伍，但是要有个上限  P0</p><ol><li>用户最多加入 5 个队伍</li><li>队伍必须存在，只能加入未满、未过期的队伍</li><li>不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）</li><li>禁止加入私有的队伍</li><li>如果加入的队伍是加密的，必须密码匹配才可以</li><li>新增队伍 - 用户关联信息</li></ol><p><strong>注意，一定要加上事务注解！！！！</strong></p><h5 id="5-用户可以退出队伍"><a href="#5-用户可以退出队伍" class="headerlink" title="5. 用户可以退出队伍"></a>5. 用户可以退出队伍</h5><p>请求参数：队伍 id</p><ol><li><p>校验请求参数</p></li><li><p>校验队伍是否存在</p></li><li><p>校验我是否已加入队伍</p></li><li><p>如果队伍</p><ol><li><p>只剩一人，队伍解散</p></li><li><p>还有其他人</p><ol><li><p>如果是队长退出队伍，权限转移给第二早加入的用户 —— 先来后到</p><blockquote><p>只用取 id 最小的 2 条数据</p></blockquote></li><li><p>非队长，自己退出队伍</p></li></ol></li></ol></li></ol><h5 id="6-队长可以解散队伍"><a href="#6-队长可以解散队伍" class="headerlink" title="6. 队长可以解散队伍"></a>6. 队长可以解散队伍</h5><p>请求参数：队伍 id</p><p>业务流程：</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验你是不是队伍的队长</li><li>移除所有加入队伍的关联信息</li><li>删除队伍</li></ol><h5 id="7-获取当前用户已加入的队伍"><a href="#7-获取当前用户已加入的队伍" class="headerlink" title="7. 获取当前用户已加入的队伍"></a>7. 获取当前用户已加入的队伍</h5><h5 id="8-获取当前用户创建的队伍"><a href="#8-获取当前用户创建的队伍" class="headerlink" title="8. 获取当前用户创建的队伍"></a>8. 获取当前用户创建的队伍</h5><p>复用 listTeam 方法，只新增查询条件，不做修改（开闭原则）</p><hr><h4 id="事务注解"><a href="#事务注解" class="headerlink" title="事务注解"></a>事务注解</h4><p>@Transactional(rollbackFor = Exception.class)</p><p>要么数据操作都成功，要么都失败</p><h3 id="数据库表设计-1"><a href="#数据库表设计-1" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>队伍表 team</p><p>字段：</p><ul><li>id 主键 bigint（最简单、连续，放 url 上比较简短，但缺点是爬虫）</li><li>name 队伍名称</li><li>description 描述</li><li>maxNum 最大人数</li><li>expireTime 过期时间</li><li>userId 创建人 id</li><li>status 0 - 公开，1 - 私有，2 - 加密</li><li>password 密码</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> team<br>(<br>    id           <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    name   <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)                   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;队伍名称&#x27;</span>,<br>    description <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>)                      <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;描述&#x27;</span>,<br>    maxNum    <span class="hljs-type">int</span>      <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;最大人数&#x27;</span>,<br>    expireTime    datetime  <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;过期时间&#x27;</span>,<br>    userId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    status    <span class="hljs-type">int</span>      <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;0 - 公开，1 - 私有，2 - 加密&#x27;</span>,<br>    password <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>)                       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>    <br>        createTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete     tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>)<br>    comment <span class="hljs-string">&#x27;队伍&#x27;</span>;<br></code></pre></td></tr></table></figure><p>用户  - 队伍表 user_team</p><p>字段：</p><ul><li>id 主键</li><li>userId 用户 id</li><li>teamId 队伍 id</li><li>joinTime 加入时间</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_team<br>(<br>    id           <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    userId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    teamId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;队伍id&#x27;</span>,<br>    joinTime datetime  <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;加入时间&#x27;</span>,<br>    createTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete     tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>)<br>    comment <span class="hljs-string">&#x27;用户队伍关系&#x27;</span>;<br></code></pre></td></tr></table></figure><p>两个关系：</p><ol><li>用户加了哪些队伍？</li><li>队伍有哪些用户？</li></ol><p>方式：</p><ol><li>建立用户 - 队伍关系表 teamId userId（便于修改，查询性能高一点，可以选择这个，不用全表遍历）</li><li>用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）</li></ol><h4 id="为什么需要请求参数包装类？"><a href="#为什么需要请求参数包装类？" class="headerlink" title="为什么需要请求参数包装类？"></a>为什么需要请求参数包装类？</h4><ol><li><p>请求参数名称 / 类型和实体类不一样</p></li><li><p>有一些参数用不到，如果要自动生成接口文档，会增加理解成本</p></li><li><p>对个实体类映射到同一个对象</p></li></ol><h4 id="为什么需要包装类？"><a href="#为什么需要包装类？" class="headerlink" title="为什么需要包装类？"></a>为什么需要包装类？</h4><p>可能有些字段需要隐藏，不能返回给前端</p><p>或者有些字段某些方法是不关心的</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>库表设计 5 - 10min</p><p>增删改查 5 - 10 min</p><p>业务逻辑开发（P0）30 min</p><h2 id="2022-09-18-12-期"><a href="#2022-09-18-12-期" class="headerlink" title="2022-09-18 12 期"></a>2022-09-18 12 期</h2><ol><li>开发前端的功能<ol><li>搜索队伍 √</li><li>更新队伍（仅队伍的创始人可见） √</li><li>查看个人已加入队伍 √</li><li>查看个人创建的队伍 √</li><li>解散队伍 √</li><li>退出队伍 √</li></ol></li><li>随机匹配 30 - 40 min</li><li>完成之前的遗留问题 todo</li></ol><h3 id="前端不同页面怎么传递数据？"><a href="#前端不同页面怎么传递数据？" class="headerlink" title="前端不同页面怎么传递数据？"></a>前端不同页面怎么传递数据？</h3><ol><li><strong>url querystring（xxx?id=1）</strong> 比较适用于页面跳转</li><li><strong>url（/team/:id，xxx/1）</strong></li><li>hash (/team#1)</li><li>localStorage</li><li><strong>context（全局变量，同页面或整个项目要访问公共变量）</strong></li></ol><h3 id="随机匹配"><a href="#随机匹配" class="headerlink" title="随机匹配"></a>随机匹配</h3><blockquote><p>为了帮大家更快地发现和自己兴趣相同的朋友</p></blockquote><p>匹配 1 个还是匹配多个？</p><p>答：匹配多个，并且按照匹配的相似度从高到低排序</p><p>怎么匹配？（根据什么匹配）</p><p>答：标签 tags</p><blockquote><p>还可以根据 user_team 匹配加入相同队伍的用户</p></blockquote><p>本质：找到有相似标签的用户</p><p>举例：</p><p>用户 A：[Java, 大一, 男]</p><p>用户 B：[Java, 大二, 男]</p><p>用户 C：[Python, 大二, 女]</p><p>用户 D：[Java, 大一, 女]</p><h4 id="1-怎么匹配"><a href="#1-怎么匹配" class="headerlink" title="1. 怎么匹配"></a>1. 怎么匹配</h4><ol><li>找到有共同标签最多的用户（TopN）</li><li>共同标签越多，分数越高，越排在前面</li><li>如果没有匹配的用户，随机推荐几个（降级方案）</li></ol><p>编辑距离算法：<a href="https://blog.csdn.net/DBC_121/article/details/104198838">https://blog.csdn.net/DBC_121/article/details/104198838</a></p><blockquote><p>最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2</p></blockquote><p>余弦相似度算法：<a href="https://blog.csdn.net/m0_55613022/article/details/125683937%EF%BC%88%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%B8%A6%E6%9D%83%E9%87%8D%E8%AE%A1%E7%AE%97%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AD%A6%E4%BB%80%E4%B9%88%E6%96%B9%E5%90%91%E6%9C%80%E9%87%8D%E8%A6%81%EF%BC%8C%E6%80%A7%E5%88%AB%E7%9B%B8%E5%AF%B9%E6%AC%A1%E8%A6%81%EF%BC%89">https://blog.csdn.net/m0_55613022/article/details/125683937（如果需要带权重计算，比如学什么方向最重要，性别相对次要）</a></p><h4 id="2-怎么对所有用户匹配，取-TOP"><a href="#2-怎么对所有用户匹配，取-TOP" class="headerlink" title="2. 怎么对所有用户匹配，取 TOP"></a>2. 怎么对所有用户匹配，取 TOP</h4><p>直接取出所有用户，依次和当前用户计算分数，取 TOP N（54 秒）</p><p>优化方法：</p><ol><li><p>切忌不要在数据量大的时候循环输出日志（取消掉日志后 20 秒）</p></li><li><p>Map 存了所有的分数信息，占用内存</p><p> 解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）</p><p> e.g.【3, 4, 5, 6, 7】取 TOP 5，id 为 1 的用户就不用放进去了</p></li><li><p>细节：剔除自己 √</p></li><li><p>尽量只查需要的数据：</p><ol><li>过滤掉标签为空的用户 √</li><li>根据部分标签取用户（前提是能区分出来哪个标签比较重要）</li><li>只查需要的数据（比如 id 和 tags） √（7.0s）</li></ol></li><li><p>提前查？（定时任务）</p><ol><li>提前把所有用户给缓存（不适用于经常更新的数据）</li><li>提前运算出来结果，缓存（针对一些重点用户，提前缓存）</li></ol></li></ol><p>大数据推荐，比如说有几亿个商品，难道要查出来所有的商品？</p><p>难道要对所有的数据计算一遍相似度？</p><p>检索 =&gt; 召回 =&gt; 粗排 =&gt; 精排 =&gt; 重排序等等</p><p>检索：尽可能多地查符合要求的数据（比如按记录查）</p><p>召回：查询可能要用到的数据（不做运算）</p><p>粗排：粗略排序，简单地运算（运算相对轻量）</p><p>精排：精细排序，确定固定排位</p><h3 id="分表学习建议"><a href="#分表学习建议" class="headerlink" title="分表学习建议"></a>分表学习建议</h3><p>mycat、sharding sphere 框架</p><p>一致性 hash</p><h3 id="队伍操作权限控制"><a href="#队伍操作权限控制" class="headerlink" title="队伍操作权限控制"></a>队伍操作权限控制</h3><p>加入队伍： 仅非队伍创建人、且未加入队伍的人可见</p><p>更新队伍：仅创建人可见</p><p>解散队伍：仅创建人可见</p><p>退出队伍：创建人不可见，仅已加入队伍的人可见</p><p>加载骨架屏特效 ✔</p><p>解决：van-skeleton 组件</p><p>仅加入队伍和创建队伍的人能看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态） ✔</p><p>方案 1：前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）</p><p>方案 2：在后端去做上述事情（推荐）</p><p>前端导航栏死【标题】问题 ✔</p><p>解决：使用 router.beforeEach，根据要跳转页面的 url 路径 匹配 config/routes 配置的 title 字段。</p><h2 id="14-优化、上线"><a href="#14-优化、上线" class="headerlink" title="14 优化、上线"></a>14 优化、上线</h2><p>1、强制登录，自动跳转到登录页</p><p>解决：axios 全局配置响应拦截、并且添加重定向</p><p>2、区分公开和加密房间；加入有密码的房间，要指定密码</p><p>3、展示已加入队伍人数</p><p>4、重复加入队伍的问题（加锁、分布式锁）并发请求时可能出现问题</p><p><strong>分布式锁</strong></p><h2 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h2><p>先区分多环境：前端区分开发和线上接口，后端 prod 改为用线上公网可访问的数据库</p><p>前端：Vercel（免费）</p><p><a href="https://vercel.com/">https://vercel.com/</a></p><p>后端：微信云托管（部署容器的平台，付费）</p><p><a href="https://cloud.weixin.qq.com/cloudrun/service">https://cloud.weixin.qq.com/cloudrun/service</a></p><p><strong>（免备案！！！）</strong></p><h2 id="如何改造成小程序？"><a href="#如何改造成小程序？" class="headerlink" title="如何改造成小程序？"></a>如何改造成小程序？</h2><p><strong>cordova、跨端开发框架 taro、uniapp</strong></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欲速则不达（春招准备）</title>
    <link href="/2024/01/29/%E6%AC%B2%E9%80%9F%E5%88%99%E4%B8%8D%E8%BE%BE%EF%BC%88%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%EF%BC%89/"/>
    <url>/2024/01/29/%E6%AC%B2%E9%80%9F%E5%88%99%E4%B8%8D%E8%BE%BE%EF%BC%88%E6%98%A5%E6%8B%9B%E5%87%86%E5%A4%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="欲速则不达"><a href="#欲速则不达" class="headerlink" title="欲速则不达"></a>欲速则不达</h1><p>一个月想要好的成绩，必须要放弃一些东西，比如追求所有代码都是自己写，我觉得这是不可能的事情了，一个项目最多一个星期要完成。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>春招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>春招</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑马头条项目笔记</title>
    <link href="/2024/01/29/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/29/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="黑马头条项目笔记"><a href="#黑马头条项目笔记" class="headerlink" title="黑马头条项目笔记"></a>黑马头条项目笔记</h1><p><img src="/../images/image-20240201152142797.png" alt="image-20240201152142797"></p><p>1,在默认频道展示10条文章信息</p><p>2,可以切换频道查看不同种类文章</p><p>3,当用户下拉可以加载最新的文章（分页）本页文章列表中发布时间为最大的时间为依据</p><p>4,当用户上拉可以加载更多的文章信息（按照发布时间）本页文章列表中发布时间最小的时间为依据</p><p>5，如果是当前频道的首页，前端传递默认参数：</p><ul><li><p>maxBehotTime：0（毫秒）</p></li><li><p>minBehotTime：20000000000000（毫秒）—&gt;2063年</p></li></ul><h3 id="1-5-接口定义"><a href="#1-5-接口定义" class="headerlink" title="1.5)接口定义"></a>1.5)接口定义</h3><table><thead><tr><th></th><th><strong>加载首页</strong></th><th><strong>加载更多</strong></th><th><strong>加载最新</strong></th></tr></thead><tbody><tr><td>接口路径</td><td>/api/v1/article/load</td><td>/api/v1/article/loadmore</td><td>/api/v1/article/loadnew</td></tr><tr><td>请求方式</td><td>POST</td><td>POST</td><td>POST</td></tr><tr><td>参数</td><td>ArticleHomeDto</td><td>ArticleHomeDto</td><td>ArticleHomeDto</td></tr><tr><td>响应结果</td><td>ResponseResult</td><td>ResponseResult</td><td>ResponseResult</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黑马头条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务学习（一）——SpringCloud</title>
    <link href="/2024/01/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94SpringCloud/"/>
    <url>/2024/01/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94SpringCloud/</url>
    
    <content type="html"><![CDATA[<h1 id="0-服务框架"><a href="#0-服务框架" class="headerlink" title="0 服务框架"></a>0 服务框架</h1><p><img src="/../images/image-20240129081109429.png" alt="image-20240129081109429"></p><p><img src="/../images/image-20240129081156425.png" alt="image-20240129081156425"></p><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p><strong>问题：</strong></p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><blockquote><p>  高内聚低耦合</p></blockquote><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><h1 id="1-服务拆分和远程调用"><a href="#1-服务拆分和远程调用" class="headerlink" title="1 服务拆分和远程调用"></a>1 服务拆分和远程调用</h1><p><strong>原则：</strong></p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><h2 id="1-1-通过RestTemplate远程调用"><a href="#1-1-通过RestTemplate远程调用" class="headerlink" title="1.1 通过RestTemplate远程调用"></a>1.1 通过RestTemplate远程调用</h2><p>比如说有一个购物车给业务，要求通过用户id查询购物车订单并且返回用户信息，那么现在我先访问Order-service中的查询订单功能，然后需要通过http请求发送到user-service并且请求查询用户的业务。</p><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\image-20210713213312278.png?lastModify=1706488441" alt="image-20210713213312278"></p><p>Spring给我们提供了一个RestTemplate的API，可以方便的实现Http请求的发送。</p><p>（1）先将RestTemplate注册为一个Bean(也可以在启动类中注册)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteCallConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）发送远程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2.1.利用RestTemplate发起http请求，得到http的响应</span><br> ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(<br>         <span class="hljs-string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,<br>         HttpMethod.GET,<br>         <span class="hljs-literal">null</span>,<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;<br>         &#125;,<br>         Map.of(<span class="hljs-string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="hljs-string">&quot;,&quot;</span>))<br> );<br></code></pre></td></tr></table></figure><h2 id="1-2-服务提供者消费者"><a href="#1-2-服务提供者消费者" class="headerlink" title="1.2 服务提供者消费者"></a>1.2 服务提供者消费者</h2><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="file://D:/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/Java%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%BA%BF/SpringCloud/%E8%B5%84%E6%96%99/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/day01-SpringCloud01/%E8%AE%B2%E4%B9%89/assets/image-20210713214925388.png?lastModify=1706488769" alt="image-20210713214925388"></p><p><strong>问题：</strong></p><ul><li>  多个user-service服务调用哪个。</li><li>  如何判断服务是健康</li><li>  如何得知user-service的ip和端口。</li></ul><h1 id="2-Eureka"><a href="#2-Eureka" class="headerlink" title="2 Eureka"></a>2 Eureka</h1><p>Eureka是注册中心。</p><p><strong>问题1：</strong></p><p>order-service如何得知user-service实例地址？</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫<strong>服务注册</strong></li><li>eureka-server保存服务名称到服务实例地址列表的<strong>映射关系</strong></li><li>order-service根据服务名称，拉取实例地址列表。这个叫<strong>服务发现或服务拉取</strong></li></ul><p><strong>问题2：</strong></p><p>order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用<strong>负载均衡</strong>算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p><strong>问题3：</strong></p><p>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为<strong>心跳</strong></li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中<strong>剔除</strong></li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><h2 id="2-1-搭建Eureka"><a href="#2-1-搭建Eureka" class="headerlink" title="2.1 搭建Eureka"></a>2.1 搭建Eureka</h2><p>（1）导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）编写启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><span class="hljs-comment">//不要忘记</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><h2 id="2-2-服务注册"><a href="#2-2-服务注册" class="headerlink" title="2.2 服务注册"></a>2.2 服务注册</h2><p>（1）在服务注册方的pom中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><p>（3）启动多个user-service实例</p><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\image-20210713222656562.png?lastModify=1706490207" alt="image-20210713222656562"></p><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\image-20210713222757702.png?lastModify=1706490188" alt="image-20210713222757702"></p><h2 id="2-3-服务发现"><a href="#2-3-服务发现" class="headerlink" title="2.3 服务发现"></a>2.3 服务发现</h2><p>（1）添加依赖</p><p>（2）yaml配置</p><p>（3）服务拉取和负载均衡</p><p>在RestTemplate的bean上添加@LoadBalanced注解</p><h1 id="3-Ribbon负载均衡"><a href="#3-Ribbon负载均衡" class="headerlink" title="3 Ribbon负载均衡"></a>3 Ribbon负载均衡</h1><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\image-20210713224517686.png?lastModify=1706490407" alt="image-20210713224517686"></p><p>客户端输入的是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="3-1-原理实现"><a href="#3-1-原理实现" class="headerlink" title="3.1 原理实现"></a>3.1 原理实现</h2><p>（1）LoadBalancerIntercepor</p><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\1525620483637.png?lastModify=1706490485" alt="1525620483637"></p><p>intercept方法，拦截了用户的HttpRequest请求：</p><ul><li>  <code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li>  originalUri.getHost()<code>：获取uri路径的主机名，其实就是服务id，</code>user-service</li><li>  <code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>（2）LoadBalancerClient</p><p>前面loadBalancer对应的是LoadBalancerClient</p><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\1525620787090.png?lastModify=1706490822" alt="1525620787090"></p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\1525620835911.png?lastModify=1706490836" alt="1525620835911"></p><p>（3）负载均衡策略IRule</p><p>上面通过一个<code>getServer</code>方法来做负载均衡，进入方法：</p><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\1544361421671.png?lastModify=1706490935" alt="1544361421671"></p><p>继续chooseServer</p><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\1525622652849.png?lastModify=1706490957" alt="1525622652849"></p><p>rule：</p><p><img src="file://D:\编程笔记\Java后端路线\SpringCloud\资料\学习资料\day01-SpringCloud01\讲义\assets\1525622699666.png?lastModify=1706490975" alt="1525622699666"></p><p>最后发现是轮询机制。</p><p>（4）总结</p><p><img src="/../../../../../../../Codefield/projects/selfBlog/source/images/image-20210713224724673.png" alt="image-20210713224724673"></p><h2 id="3-2-负载均衡策略"><a href="#3-2-负载均衡策略" class="headerlink" title="3.2 负载均衡策略"></a>3.2 负载均衡策略</h2><p>通过刚刚的源码分析，所有的规则都在IRule中，也就是修改一下其中的实现类就可以实现不同的策略。</p><p><img src="/../../../../../../../Codefield/projects/selfBlog/source/images/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong>（默认）</td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><h2 id="3-3-自定义负载均衡"><a href="#3-3-自定义负载均衡" class="headerlink" title="3.3 自定义负载均衡"></a>3.3 自定义负载均衡</h2><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><h2 id="3-4-懒加载"><a href="#3-4-懒加载" class="headerlink" title="3.4 懒加载"></a>3.4 懒加载</h2><p>Ribbon默认是懒加载，也就是第一次访问的时候再回去创建LoadBalanceClient，可能导致请求的时间过长。</p><p>修改为饥饿加载，也就是项目启动的时候创建。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span><br></code></pre></td></tr></table></figure><h1 id="4-Nacos注册中心"><a href="#4-Nacos注册中心" class="headerlink" title="4 Nacos注册中心"></a>4 Nacos注册中心</h1><h2 id="4-1-服务注册"><a href="#4-1-服务注册" class="headerlink" title="4.1 服务注册"></a>4.1 服务注册</h2><p>（1）父工程依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）子工程依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p><p>（3）配置地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><p><strong>注：要注释掉eureka依赖</strong></p><h2 id="4-2-服务分级存储模型"><a href="#4-2-服务分级存储模型" class="headerlink" title="4.2 服务分级存储模型"></a>4.2 服务分级存储模型</h2><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210713232522531.png?lastModify=1706491994" alt="image-20210713232522531"></p><p>user-service是一个服务，也就是说可以包含多个集群，应该说多个集群中都有这个服务，优先调用自己集群内的服务。</p><h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><p>（1）修改yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210713232916215.png?lastModify=1706492335" alt="image-20210713232916215"></p><p>（2）再复制一个service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH<br></code></pre></td></tr></table></figure><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210713233727923.png?lastModify=1706492393" alt="image-20210713233727923"></p><h3 id="同集群优先的负载均衡"><a href="#同集群优先的负载均衡" class="headerlink" title="同集群优先的负载均衡"></a>同集群优先的负载均衡</h3><p>因此Nacos中提供了一个<code>NacosRule</code>的实现</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">spring:<br>  cloud:<br>    nacos:<br>      server-addr: localhost:8848<br>      discovery:<br>        cluster-name: HZ <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><h2 id="4-3-权重配置"><a href="#4-3-权重配置" class="headerlink" title="4.3 权重配置"></a>4.3 权重配置</h2><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210713235133225.png?lastModify=1706492478" alt="image-20210713235133225"></p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210713235235219.png?lastModify=1706492515" alt="image-20210713235235219"></p><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p><h2 id="4-4-环境隔离"><a href="#4-4-环境隔离" class="headerlink" title="4.4 环境隔离"></a>4.4 环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><h3 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：<img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210714000414781.png?lastModify=1706492557" alt="image-20210714000414781"></p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210714000440143.png?lastModify=1706492596" alt="image-20210714000440143"></p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210714000505928.png?lastModify=1706492602" alt="image-20210714000505928"></p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210714000522913.png?lastModify=1706492608" alt="image-20210714000522913"></p><h3 id="给微服务配置namespace"><a href="#给微服务配置namespace" class="headerlink" title="给微服务配置namespace"></a>给微服务配置namespace</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间，填ID</span><br></code></pre></td></tr></table></figure><h2 id="4-5-Nacos与Eureka的区别"><a href="#4-5-Nacos与Eureka的区别" class="headerlink" title="4.5 Nacos与Eureka的区别"></a>4.5 Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置为非临时实例</span><br></code></pre></td></tr></table></figure><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h1 id="5-Nacos配置管理"><a href="#5-Nacos配置管理" class="headerlink" title="5 Nacos配置管理"></a>5 Nacos配置管理</h1><h2 id="5-1-从微服务拉取配置"><a href="#5-1-从微服务拉取配置" class="headerlink" title="5.1 从微服务拉取配置"></a>5.1 从微服务拉取配置</h2><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取：</p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/L0iFYNF.png?lastModify=1706516964" alt="img"></p><p>（1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><h2 id="5-2-配置热更新"><a href="#5-2-配置热更新" class="headerlink" title="5.2 配置热更新"></a>5.2 配置热更新</h2><p><strong>方式一</strong></p><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="/../images/image-20210714171036335.png" alt="image-20210714171036335"></p><p><strong>方式二：</strong></p><p>使用@ConfigurationProperties注解代替@Value注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PatternProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String dateformat;<br>&#125;<br></code></pre></td></tr></table></figure><p>在UserController中使用这个类代替@Value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PatternProperties patternProperties;<br><br>    <span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));<br>    &#125;<br><br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是把@value直接导入变成了用PatternProperties来管理。</p><h2 id="5-3-配置共享"><a href="#5-3-配置共享" class="headerlink" title="5.3 配置共享"></a>5.3 配置共享</h2><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="/../images/image-20210714173233650.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="/../images/image-20210714173324231.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="/../images/image-20210714173721309.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="/../images/image-20210714173538538.png" alt="image-20210714173538538"></p><p><img src="/../images/image-20210714173519963.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="/../images/image-20210714174313344.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="/../images/image-20210714174424818.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="/../images/image-20210714174623557.png" alt="image-20210714174623557"></p><h1 id="6-Feign"><a href="#6-Feign" class="headerlink" title="6 Feign"></a>6 Feign</h1><h2 id="6-1-替代RestTemplate"><a href="#6-1-替代RestTemplate" class="headerlink" title="6.1 替代RestTemplate"></a>6.1 替代RestTemplate</h2><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="/../images/image-20210714175102524.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="6-2-自定义配置"><a href="#6-2-自定义配置" class="headerlink" title="6.2 自定义配置"></a>6.2 自定义配置</h2><h3 id="6-2-1-配置文件方式"><a href="#6-2-1-配置文件方式" class="headerlink" title="6.2.1 配置文件方式"></a>6.2.1 配置文件方式</h3><p>（1）针对单个服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>（2）针对所有服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><h3 id="6-2-2-Java代码方式"><a href="#6-2-2-Java代码方式" class="headerlink" title="6.2.2 Java代码方式"></a>6.2.2 Java代码方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfiguration</span>  &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLogLevel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><h2 id="6-3-优化Feign"><a href="#6-3-优化Feign" class="headerlink" title="6.3 优化Feign"></a>6.3 优化Feign</h2><p>提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>feign客户端：</p><p><img src="/../images/image-20210714190542730.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="/../images/image-20210714190528450.png" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="6-3-1-继承方式"><a href="#6-3-1-继承方式" class="headerlink" title="6.3.1 继承方式"></a>6.3.1 继承方式</h3><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210714190640857.png?lastModify=1706585908" alt="image-20210714190640857"></p><h3 id="6-3-2-抽取方式"><a href="#6-3-2-抽取方式" class="headerlink" title="6.3.2 抽取方式"></a>6.3.2 抽取方式</h3><p>将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210714214041796.png?lastModify=1706586000" alt="image-20210714214041796"></p><h1 id="7-Gateway服务网关"><a href="#7-Gateway服务网关" class="headerlink" title="7 Gateway服务网关"></a>7 Gateway服务网关</h1><p><img src="file://D:/Codefield/projects/selfBlog/source/images/image-20210714210131152.png?lastModify=1706586073" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><h2 id="7-1-创建gateway服务"><a href="#7-1-创建gateway服务" class="headerlink" title="7.1 创建gateway服务"></a>7.1 创建gateway服务</h2><p>（<strong>1）创建gateway服务，引入依赖</strong></p><p>创建服务：</p><p><img src="/../images/image-20210714210919458.png" alt="image-20210714210919458"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--网关--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--nacos服务发现依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2）编写启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.gateway;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(GatewayApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3）编写基础配置和路由规则</strong></p><p>创建application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><p><strong>4）重启测试</strong></p><p>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="/../images/image-20210714211908341.png" alt="image-20210714211908341"></p><p><strong>5）网关路由的流程图</strong></p><p>整个访问的流程如下：</p><p><img src="/../images/image-20210714211742956.png" alt="image-20210714211742956"></p><h2 id="7-2-断言工厂"><a href="#7-2-断言工厂" class="headerlink" title="7.2 断言工厂"></a>7.2 断言工厂</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><h2 id="7-3-过滤器工厂"><a href="#7-3-过滤器工厂" class="headerlink" title="7.3 过滤器工厂"></a>7.3 过滤器工厂</h2><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <br>        <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span><br>      <span class="hljs-attr">default-filters:</span> <span class="hljs-comment"># 默认过滤项</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <br></code></pre></td></tr></table></figure><h2 id="7-4-全局过滤器"><a href="#7-4-全局过滤器" class="headerlink" title="7.4 全局过滤器"></a>7.4 全局过滤器</h2><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  处理当前请求，有必要的话通过&#123;<span class="hljs-doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span><br><span class="hljs-comment">     */</span><br>    Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Order(-1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1.获取请求参数</span><br>        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();<br>        <span class="hljs-comment">// 2.获取authorization参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> params.getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-comment">// 3.校验</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(auth)) &#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 4.拦截</span><br>        <span class="hljs-comment">// 4.1.禁止访问，设置状态码</span><br>        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class="hljs-comment">// 4.2.结束处理</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-5-跨域问题"><a href="#7-5-跨域问题" class="headerlink" title="7.5 跨域问题"></a>7.5 跨域问题</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 。。。</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 </span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>anaconda创建虚拟环境</title>
    <link href="/2024/01/26/anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/01/26/anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Anaconda-创建Python3-6，Python3-7虚拟环境"><a href="#Anaconda-创建Python3-6，Python3-7虚拟环境" class="headerlink" title="Anaconda 创建Python3.6，Python3.7虚拟环境"></a>Anaconda 创建Python3.6，Python3.7虚拟环境</h1><p>（1）查看当前的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure><p>（2）查看下载源,设置镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">conda config --show-sources<br><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs/free<br><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs/main<br></code></pre></td></tr></table></figure><p>（3）创建虚拟空间</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">conda create -n env_name <span class="hljs-attribute">python</span>=xxx<br></code></pre></td></tr></table></figure><p>（4）激活虚拟空间</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">activate</span> your_env_name<br></code></pre></td></tr></table></figure><p>（5）退出虚拟环境</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">deactivate env_name</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习（一）</title>
    <link href="/2024/01/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/01/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="/../images/image-20240125162129581.png" alt="image-20240125162129581"></p><p><img src="/../images/image-20240125162237364.png" alt="image-20240125162237364"></p><p>可视化</p><h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><p>Python 虚拟环境用于将软件包安装与系统隔离开来。</p><p>（1）创建一个虚拟空间</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">python</span> -m venv --<span class="hljs-keyword">system</span>-site-packages .\venv<br></code></pre></td></tr></table></figure><p>（2）激活虚拟环境</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.\venv\Scripts\<span class="hljs-built_in">activate</span><br></code></pre></td></tr></table></figure><p>（3）安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bsh">pip install --upgrade tensorflow<br></code></pre></td></tr></table></figure><p>（4）检验安装</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">python -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;</span><br></code></pre></td></tr></table></figure><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p><img src="/../images/image-20240126100457833.png" alt="image-20240126100457833"></p><p>通过梯度下降寻找代价函数的最优解（局部），即每次走的都是下降梯度最陡的。</p><p><strong>实现：</strong></p><p><img src="/../images/image-20240126101206245.png" alt="image-20240126101206245"> </p><p><img src="/../images/image-20240126101352489.png" alt="image-20240126101352489"></p><p>注意该问题中w的赋值问题，α是学习率，影响梯度下降率。</p><p><img src="/../images/image-20240126102120090.png" alt="image-20240126102120090"></p><p><strong>学习率：</strong></p><p><img src="/../images/image-20240126102418197.png" alt="image-20240126102418197"></p><p>如果学习率过大可能越过最小值</p><h2 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h2><p><img src="/../images/image-20240202090959378.png" alt="image-20240202090959378"></p><p>归一化：</p><p><img src="/../images/image-20240202091114388.png" alt="image-20240202091114388"></p><p><strong>检查梯度下降是否收敛</strong></p><p><strong>学习曲线</strong></p><p><img src="/../images/image-20240202091759089.png" alt="image-20240202091759089"></p><h2 id="学习率的选择"><a href="#学习率的选择" class="headerlink" title="学习率的选择"></a>学习率的选择</h2><p><img src="/../images/image-20240202092136545.png" alt="image-20240202092136545"></p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>多项式函数</p><p><img src="/../images/image-20240202092742075.png" alt="image-20240202092742075"></p><h2 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h2><p><img src="/../images/image-20240202093159615.png" alt="image-20240202093159615"> </p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>是一个介于0到1之间的分类算法，而不是回归算法。用来解决二分类问题。</p><p><img src="/../images/image-20240202094009869.png" alt="image-20240202094009869"></p><p><strong>sigmoid function</strong></p><p><img src="/../images/image-20240202094409000.png" alt="image-20240202094409000"></p><p>sigmoid function 是由线性回归而来的。</p><h3 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h3><p><strong>直线型</strong></p><p><img src="/../images/image-20240202095228728.png" alt="image-20240202095228728"></p><p><strong>non-linear型</strong></p><p><img src="/../images/image-20240202095408779.png" alt="image-20240202095408779"></p><p>决策边界的求法：</p><p>令z=0求出边界函数。</p><h3 id="逻辑回归的代价函数"><a href="#逻辑回归的代价函数" class="headerlink" title="逻辑回归的代价函数"></a>逻辑回归的代价函数</h3><p><img src="/../images/image-20240202102624554.png" alt="image-20240202102624554"></p><p><strong>简易版：</strong></p><p><img src="/../images/image-20240202103146956.png" alt="image-20240202103146956"></p><h3 id="梯度下降实现"><a href="#梯度下降实现" class="headerlink" title="梯度下降实现"></a>梯度下降实现</h3><p><img src="/../images/image-20240202103612017.png" alt="image-20240202103612017"></p><h2 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h2><p><img src="/../images/image-20240202104401115.png" alt="image-20240202104401115"></p><p><img src="/../images/image-20240202104552044.png" alt="image-20240202104552044"></p><p>减少过拟合问题 ：</p><ul><li>  减少特征</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaAPI快速索引</title>
    <link href="/2024/01/25/JavaAPI%E5%BF%AB%E9%80%9F%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/01/25/JavaAPI%E5%BF%AB%E9%80%9F%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"> List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Person&gt;();<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">8900</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;male&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jack&quot;</span>,<span class="hljs-number">7000</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&quot;male&quot;</span>,<span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Lily&quot;</span>,<span class="hljs-number">7800</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;female&quot;</span>,<span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Anni&quot;</span>,<span class="hljs-number">8200</span>,<span class="hljs-number">30</span>,<span class="hljs-string">&quot;female&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Owen&quot;</span>,<span class="hljs-number">9500</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;male&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alisa&quot;</span>,<span class="hljs-number">7900</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&quot;female&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>));<br><br>        <span class="hljs-comment">//匹配条件并输出</span><br>        personList.parallelStream().filter(s -&gt; s.getAge() &gt; <span class="hljs-number">19</span>).forEach(System.out::println);<br>        Optional&lt;Person&gt; optionalPerson = personList.stream().filter(s -&gt; s.getAge() &gt; <span class="hljs-number">20</span>).findFirst();<br>        Optional&lt;Person&gt; optionalPerson1 = personList.parallelStream().filter(s -&gt; s.getAge() &gt; <span class="hljs-number">21</span>).findAny();<br><br><span class="hljs-comment">//        Object a=hrRightService.getAllDataScope(&quot;1&quot;);</span><br>        <span class="hljs-comment">//流的种类有顺序流和并行流</span><br>        <span class="hljs-comment">//1.顺序流</span><br>        Stream&lt;Person&gt; stream = personList.stream();<br>        <span class="hljs-comment">//2,并行流数据量大是提示效率</span><br>        Stream&lt;Person&gt; stream1 = personList.parallelStream();<br>        Stream&lt;Person&gt; stream2 = personList.stream().parallel();<br>        <span class="hljs-comment">//遍历stream流</span><br>        personList.stream().forEach(System.out::println);<br>        <span class="hljs-comment">//获取员工工资最高的人</span><br>        Optional&lt;Person&gt; maxOptional = personList.stream().max(Comparator.comparing(Person::getSalary));<br>        System.out.println(<span class="hljs-string">&quot;工资最高的人员&quot;</span> + JsonUtil.toJson(maxOptional));<br>        <span class="hljs-comment">//计算工资大于8000的员工个数</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> personList.stream().filter(e-&gt;e.getSalary()&gt;<span class="hljs-number">8000</span>).count();<br>        System.out.println(<span class="hljs-string">&quot;计算工资大于8000的员工个数&quot;</span> + count);<br>        <span class="hljs-comment">//去除元素中重复的值</span><br>        List&lt;Integer&gt; personList1 = personList.stream().distinct().map(Person::getAge).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;去除元素中重复的值&quot;</span> + JsonUtil.toJson(personList1));<br>        <span class="hljs-comment">//筛选</span><br>        List&lt;String&gt; engNameList = personList.stream().filter(e -&gt; e.getSalary() &gt; <span class="hljs-number">8000</span>).map(Person::getName).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;员工工资高于8000的人员名字列表&quot;</span> + JsonUtil.toJson(engNameList));<br>        <span class="hljs-comment">//映射</span><br>        <span class="hljs-comment">//把sex中英文字符串数组的元素全部改为大写。(这里相当于把这个sex元素变成了字符串类型可以调用String的任何方法</span><br>        List&lt;String&gt; sexList = personList.stream().map(e -&gt; e.getSex().toUpperCase()).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;把sex中英文字符串数组的元素全部改为大写&quot;</span> + JsonUtil.toJson(sexList));<br>        <span class="hljs-comment">//年龄整都整体+3岁。</span><br>        List&lt;Integer&gt; ageList = personList.stream().map(e-&gt;e.getAge()+<span class="hljs-number">3</span>).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;年龄整都整体+3岁。&quot;</span> + JsonUtil.toJson(ageList));<br>        <span class="hljs-comment">//list转map用名字作为key</span><br>        Map&lt;String, Person&gt; map = personList.stream().collect(Collectors.toMap(Person::getName, person -&gt; person));<br>        System.out.println(<span class="hljs-string">&quot;list转map的结果&quot;</span> + JsonUtil.toJson(map));<br>        <span class="hljs-comment">//list转set</span><br>        Set&lt;Person&gt; peopleSet = personList.stream().collect(Collectors.toSet());<br>        <span class="hljs-comment">//list条件筛选工资大于8000的人生成新的map</span><br>        Map&lt;String, Person&gt; maps = personList.stream().filter(p -&gt; p.getSalary() &gt; <span class="hljs-number">8000</span>).collect(Collectors.toMap(Person::getName, p -&gt; p));<br>        System.out.println(<span class="hljs-string">&quot;list条件筛选工资大于8000的人生成新的map&quot;</span> + JsonUtil.toJson(maps));<br>        <span class="hljs-comment">//将名字和工作地合并成一起生成新的字符串</span><br>        List&lt;String&gt; nameWorkList = personList.stream().map(e -&gt; e.getName() + e.getArea()).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;将名字和工作地合并成一起生成新的字符串&quot;</span> + JsonUtil.toJson(nameWorkList));<br>        <span class="hljs-comment">//分组</span><br>        <span class="hljs-comment">//按照员工薪资高于8000的分组</span><br>        Map&lt;Boolean, List&lt;Person&gt;&gt; map1 = personList.stream().collect(Collectors.partitioningBy(e -&gt; e.getSalary() &gt; <span class="hljs-number">8000</span>));<br>        <span class="hljs-comment">//按员工性别分组</span><br>        Map&lt;String, List&lt;Person&gt;&gt; map2 = personList.stream().collect(Collectors.groupingBy(Person::getSex));<br>        <span class="hljs-comment">//员工先按性别再按照地区分组</span><br>        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));<br>        <span class="hljs-comment">//接合(joining)函数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">engName</span> <span class="hljs-operator">=</span> personList.stream().map(Person::getName).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;所有的名字拼接在一起生成新的字符串&quot;</span> + engName);<br>        <span class="hljs-comment">//排序按照工资自然排序</span><br>        List&lt;Person&gt; sortList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).collect(Collectors.toList());<br>        <span class="hljs-comment">//排序按照工资倒序排序</span><br>        List&lt;Person&gt; sortList1 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed()).collect(Collectors.toList());<br>        <span class="hljs-comment">//排序</span><br>        <span class="hljs-comment">//提取组合</span><br>        <span class="hljs-comment">//Collectors提供了一系列用于数据统计的静态方法：</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//计数：count</span><br>        <span class="hljs-comment">//平均值：averagingInt、averagingLong、averagingDouble</span><br>        <span class="hljs-comment">//最值：maxBy、minBy</span><br>        <span class="hljs-comment">//求和：summingInt、summingLong、summingDouble</span><br>        <span class="hljs-comment">//统计以上所有：summarizingInt、summarizingLong、summarizingDouble</span><br>        <span class="hljs-comment">// 求总数</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> personList.stream().collect(Collectors.counting());<br>        <span class="hljs-comment">// 求平均工资</span><br>        <span class="hljs-type">Double</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> personList.stream().collect(Collectors.averagingDouble(Person::getSalary));<br>        <span class="hljs-comment">// 求最高工资</span><br>        Optional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));<br>        <span class="hljs-comment">// 求工资之和</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> personList.stream().collect(Collectors.summingInt(Person::getSalary));<br>        <span class="hljs-comment">// 一次性统计所有信息</span><br>        <span class="hljs-type">DoubleSummaryStatistics</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));<br>        <span class="hljs-comment">//遍历多重list取出子list集合</span><br>        List&lt;List&lt;Person&gt;&gt; personLists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Person&gt;&gt;();<br>        personLists.add(personList);<br>        List&lt;Person&gt; = personLists.stream()<br>        .flatMap(person-&gt; person.stream())<br>        .collect(Collectors.toList());<br><br></code></pre></td></tr></table></figure><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><ul><li>  构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//public StringBuffer()  构造一个没有字符的字符串缓冲区，初始容量为16个字符。</span><br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    System.out.println(<span class="hljs-string">&quot;sb1:&quot;</span> + sb1); <span class="hljs-comment">//StringBuffer重写了toString方法</span><br>    <span class="hljs-comment">//如何获取StringBuffer的容量</span><br>    <span class="hljs-comment">//public int capacity()返回当前容量。</span><br>    System.out.println(<span class="hljs-string">&quot;当前StringBuffer的容量为：&quot;</span> + sb1.capacity());<br>    <span class="hljs-comment">//public int length()返回长度（字符数）。</span><br>    System.out.println(<span class="hljs-string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb1.length());<br> <br>    System.out.println(<span class="hljs-string">&quot;===================================================&quot;</span>);<br>    <span class="hljs-comment">//public StringBuffer(int capacity)  构造一个没有字符的字符串缓冲区和指定的初始容量。</span><br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-number">50</span>);<br>    System.out.println(<span class="hljs-string">&quot;sb2:&quot;</span> + sb2); <span class="hljs-comment">//StringBuffer重写了toString方法</span><br>    <span class="hljs-comment">//如何获取StringBuffer的容量</span><br>    <span class="hljs-comment">//public int capacity()返回当前容量。</span><br>    System.out.println(<span class="hljs-string">&quot;当前StringBuffer的容量为：&quot;</span> + sb2.capacity());<br>    <span class="hljs-comment">//public int length()返回长度（字符数）。</span><br>    System.out.println(<span class="hljs-string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb2.length());<br> <br>    System.out.println(<span class="hljs-string">&quot;===================================================&quot;</span>);<br>    <span class="hljs-comment">//public StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。</span><br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;sb3:&quot;</span> + sb3); <span class="hljs-comment">//StringBuffer重写了toString方法</span><br>    <span class="hljs-comment">//如何获取StringBuffer的容量</span><br>    <span class="hljs-comment">//public int capacity()返回当前容量。</span><br>    System.out.println(<span class="hljs-string">&quot;当前StringBuffer的容量为：&quot;</span> + sb3.capacity()); <span class="hljs-comment">// 21 = 16 + 5</span><br>    <span class="hljs-comment">//public int length()返回长度（字符数）。</span><br>    System.out.println(<span class="hljs-string">&quot;StringBuffer中字符串的长度为：&quot;</span> + sb3.length()); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><ul><li>  添加</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个StringBuffer对象</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br> <br>        <span class="hljs-comment">//public StringBuffer append(String str)</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> sb.append(<span class="hljs-string">&quot;hello&quot;</span>);<br> <br><span class="hljs-comment">//        sb.append(10);</span><br><span class="hljs-comment">//        sb.append(&#x27;a&#x27;);</span><br><span class="hljs-comment">//        sb.append(true);</span><br><span class="hljs-comment">//        sb.append(12.34);</span><br><span class="hljs-comment">//        //无论追加的数据是什么类型，一旦进入到StringBuffer中就是成了字符串</span><br><span class="hljs-comment">//        System.out.println(sb);</span><br><span class="hljs-comment">//        System.out.println(stringBuffer);</span><br> <br>        <span class="hljs-comment">//链式编程追加</span><br>        sb.append(<span class="hljs-number">10</span>).append(<span class="hljs-string">&#x27;a&#x27;</span>).append(<span class="hljs-literal">true</span>).append(<span class="hljs-number">12.34</span>);<br>        System.out.println(sb);<br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        <span class="hljs-comment">//hello10atrue12.34</span><br>        <span class="hljs-comment">//public StringBuffer insert(int offset,String str)</span><br>        <span class="hljs-comment">// 将字符串插入到此字符序列中。返回的是字符串缓冲区本身</span><br>        <span class="hljs-comment">//String参数的String按顺序插入到指定偏移量的该序列中，向上移动原始位于该位置的任何字符，</span><br>        <span class="hljs-comment">// 并将该序列的长度增加到参数的长度。</span><br>        sb.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;hadoop&quot;</span>);<br>        System.out.println(sb);<br>        <span class="hljs-comment">// 如果str是null ，则四个字符&quot;null&quot;被插入到该序列中。</span><br><span class="hljs-comment">//        sb.insert(5,null);</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        sb.insert(<span class="hljs-number">5</span>, o);<br>        System.out.println(sb);<br> <br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  删除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//使用带参数的构造方法创建StringBuffer对象</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;bigdata&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;未做删除操作之前的StringBuffer:&quot;</span> + sb);<br><span class="hljs-comment">//        StringBuffer sb2 = sb.deleteCharAt(3); // 操作的是同一个StringBuffer对象</span><br><span class="hljs-comment">//        System.out.println(sb);</span><br><span class="hljs-comment">//        System.out.println(sb2);</span><br><span class="hljs-comment">//        System.out.println(sb==sb2);</span><br>        sb.deleteCharAt(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;做删除操作之后的StringBuffer:&quot;</span> + sb);<br>        <span class="hljs-comment">//如果 index为负数或大于或等于length() 。</span><br>        <span class="hljs-comment">//index的值最大可以取到实际存储字符串的长度-1</span><br><span class="hljs-comment">//        sb.deleteCharAt(30);</span><br><span class="hljs-comment">//        sb.deleteCharAt(6);</span><br> <br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        <span class="hljs-comment">//public StringBuffer delete(int start,int end)</span><br>        <span class="hljs-comment">//删除此序列的子字符串中的字符。</span><br>        <span class="hljs-comment">// 子串开始于指定start并延伸到字符索引end - 1 ，或如果没有这样的字符存在的序列的结束。</span><br>        <span class="hljs-comment">// 如果start等于end ，则不作任何更改。</span><br>        <span class="hljs-comment">//  start&lt;=index&lt;end</span><br>        <span class="hljs-comment">//bigata</span><br><span class="hljs-comment">//       sb.delete(2,5);</span><br><span class="hljs-comment">//        sb.delete(2,6);</span><br><span class="hljs-comment">//        sb.delete(2,10);</span><br>        <span class="hljs-comment">//注意开始位置一定是已经存在的索引，否则报错</span><br><span class="hljs-comment">//        sb.delete(8,10);</span><br>        System.out.println(sb);<br> <br>        <span class="hljs-comment">//需求：删除StringBuffer中的所有字符</span><br>        sb.delete(<span class="hljs-number">0</span>, sb.length());<br>        System.out.println(<span class="hljs-string">&quot;删除StringBuffer中的所有字符：&quot;</span> + sb);<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个StringBuffer对象</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-comment">//往StringBuffer中添加一些内容</span><br>        sb.append(<span class="hljs-string">&quot;java&quot;</span>).append(<span class="hljs-string">&quot;mysql&quot;</span>).append(<span class="hljs-string">&quot;hadoop&quot;</span>).append(<span class="hljs-string">&quot;hive&quot;</span>).append(<span class="hljs-string">&quot;spark&quot;</span>).append(<span class="hljs-string">&quot;flink&quot;</span>);<br>        System.out.println(sb);<br>        <span class="hljs-comment">//public StringBuffer replace(int start,int end,String str)</span><br>        sb.replace(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&quot;数加学院真好&quot;</span>);<br>        System.out.println(sb);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  反转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        sb.append(<span class="hljs-string">&quot;我爱你中国&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;反转之前：&quot;</span> + sb);<br> <br>        System.out.println(<span class="hljs-string">&quot;反转之后：&quot;</span>);<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> sb.reverse(); <span class="hljs-comment">// 操作的是同一个StringBuffer对象</span><br>        System.out.println(sb);<br>        System.out.println(sb2);<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  截取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        sb.append(<span class="hljs-string">&quot;java&quot;</span>)<br>                .append(<span class="hljs-string">&quot;mysql&quot;</span>)<br>                .append(<span class="hljs-string">&quot;hive&quot;</span>)<br>                .append(<span class="hljs-string">&quot;ETL&quot;</span>)<br>                .append(<span class="hljs-string">&quot;spark&quot;</span>);<br>        System.out.println(sb);<br> <br>        <span class="hljs-comment">//public String substring(int start)</span><br>        <span class="hljs-comment">//不会改变原来StringBuffer中的数据</span><br>        <span class="hljs-comment">//返回值是一个String类型的数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> sb.substring(<span class="hljs-number">4</span>);<br>        System.out.println(<span class="hljs-string">&quot;截取的内容是：&quot;</span>+s1);<br><span class="hljs-comment">//        mysqlhiveETLspark</span><br>        System.out.println(<span class="hljs-string">&quot;StringBuffer的内容为：&quot;</span>+sb);<br><span class="hljs-comment">//StringBuffer的内容为：javamysqlhiveETLspark</span><br> <br>        <span class="hljs-comment">//public String substring(int start,int end) 含头不含尾 [start,end)</span><br>        <span class="hljs-comment">//javamysqlhiveETLspark</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> sb.substring(<span class="hljs-number">9</span>, <span class="hljs-number">13</span>);<br>        System.out.println(<span class="hljs-string">&quot;截取的内容是：&quot;</span>+s2);<br><span class="hljs-comment">//        截取的内容是：hive</span><br>        System.out.println(<span class="hljs-string">&quot;StringBuffer的内容为：&quot;</span>+sb);<br><span class="hljs-comment">//StringBuffer的内容为：javamysqlhiveETLspark</span><br> <br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  String与StringBuffer之间的转换:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//String --&gt; StringBuffer</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">//        StringBuffer sb = s;</span><br>        <span class="hljs-comment">//java: 不兼容的类型: java.lang.String无法转换为java.lang.StringBuffer</span><br><span class="hljs-comment">//        StringBuffer sb = &quot;hello&quot;;</span><br>        <span class="hljs-comment">//方式1：通过构造方法转换</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(s);<br>        System.out.println(s);<br>        System.out.println(sb1);<br>        <span class="hljs-comment">//方式2：通过append()</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        sb2.append(s);<br>        System.out.println(s);<br>        System.out.println(sb2);<br> <br>        System.out.println(<span class="hljs-string">&quot;==============================================&quot;</span>);<br>        <span class="hljs-comment">//StringBuffer --&gt; String</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;bigdata&quot;</span>);<br>        <span class="hljs-comment">//方式1：toString()方法</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> sb3.toString();<br>        System.out.println(sb3);<br>        System.out.println(s1);<br>        <span class="hljs-comment">//方式2：subString</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> sb3.substring(<span class="hljs-number">0</span>);<br>        System.out.println(s2);<br>        System.out.println(sb3);<br>        <span class="hljs-comment">//方式3：String类的构造方法</span><br>        <span class="hljs-comment">//String(StringBuffer buffer)</span><br>        <span class="hljs-comment">//分配一个新的字符串，其中包含当前包含在字符串缓冲区参数中的字符序列。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sb3);<br>        System.out.println(s3);<br>        System.out.println(sb3);<br> <br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h1><p>BeanUtils.copyProperties(source,target);,属性名和属性类型都相同的属性才能被成功拷贝赋值</p><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Optional</span>.ofNullable<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2024/01/25/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/01/25/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="49字母异位词分组"><a href="#49字母异位词分组" class="headerlink" title="49字母异位词分组"></a>49<a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h2><p><strong>思路</strong></p><ul><li>  字母异位词可以利用统计每个字母出现的次数，利用map进行映射，或者通过将每个字符串排序，然后通过hashmap进行映射。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,List&lt;String&gt;&gt;();<br><br>        <span class="hljs-comment">//对每一个字符串进行排序，排序后的进行比对，</span><br>       <span class="hljs-keyword">for</span>(String s:strs)&#123;<br>           <span class="hljs-type">char</span>[] array=s.toCharArray();<br>           Arrays.sort(array);<br>            String key=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array);<br>            List&lt;String&gt; list=map.getOrDefault(key,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>            list.add(s);<br>            map.put(key,list);<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h2><p><strong>错误作答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-comment">//思路：遍历，进函数返回对错</span><br>        <span class="hljs-type">int</span> sn=s.length();<br>        <span class="hljs-type">int</span> pn=p.length();<br>        List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sn-pn+<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(isRight(s.substring(i,i+pn-<span class="hljs-number">1</span>),p))&#123;<br>                list.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">//判断两者是否是异位词</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRight</span><span class="hljs-params">(String a,String b)</span>&#123;<br>        <span class="hljs-type">char</span>[] arraya=a.toCharArray();<br>        Arrays.sort(arraya);<br>        String sa=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arraya);<br>        <span class="hljs-type">char</span>[] arrayb=b.toCharArray();<br>        Arrays.sort(arrayb);<br>        String sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arrayb);<br>        <span class="hljs-keyword">return</span> sa==sb;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p><strong>思路：</strong></p><p>首先把第一个数组加入到set中，利用set中的元素不会重复的原则，然后遍历查找第二个数组中的元素是否在第一个set中，如果在就加入set2中，最后用stream把set变为int数组。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>       <br>       Set&lt;Integer&gt; set1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>       Set&lt;Integer&gt; set2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums1.length;i++)&#123;<br>           set1.add(nums1[i]);<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums2.length;i++)&#123;<br>           <span class="hljs-keyword">if</span>(set1.contains(nums2[i]))&#123;<br>                set2.add(nums2[i]);<br>           &#125;<br>       &#125;<br>        <span class="hljs-keyword">return</span> set2.stream().mapToInt(x-&gt;x).toArray();<span class="hljs-comment">//需要注意的点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h2><p><strong>思路：</strong></p><p>快乐数的寻找主要要把握住，如果是无限循环，那么这个sum一定会反复出现。也就是需要一个set去监控这个sum有没有重复出现。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//如果无限循环，那么sum是会重复的。</span><br>        Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">1</span>&amp;&amp;!set.contains(n))&#123;<br>            <br>            set.add(n);<br>            n=sum(n);<br>           <br>        &#125;<br>        <span class="hljs-keyword">return</span> n==<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p><strong>思路：</strong></p><p>本题不能使用哈希表，可以用双指针。其中a,b,c是nums[i],nums[j],nums[k],要注意的是a，b，c是可以重复的，而a不能和自己重复，首先可以对nums进行排序，然后对a进行去重，用left和right双指针遍历当sum=0时，分别对left和right进行去重。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//去重逻辑：只要找到以后就判断后面和前面有么有重复的。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-comment">//如果排序以后第一个就比0大，直接返回</span><br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>            <span class="hljs-comment">//去重a</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> left=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right=nums.length-<span class="hljs-number">1</span>;<br><br>           <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>               <span class="hljs-type">int</span> sum=nums[i]+nums[left]+nums[right];<br>               <span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>)&#123;<br>                   left++;<br>               &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)&#123;<br>                   right--;<br><br>               &#125;<span class="hljs-keyword">else</span> &#123;<br>                   ans.add(Arrays.asList(nums[i],nums[left],nums[right]));<br>                   <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>])left++;<br>                   <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="hljs-number">1</span>])right--;<br>                   left++;<br>                   right--;<br>               &#125;<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h2><p>思路：和上面的三数之和一样，只不过多列一层for循环。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]&gt;target)&#123;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j&gt;i+<span class="hljs-number">1</span>&amp;&amp;nums[j]==nums[j-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left=j+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> right=nums.length-<span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                    <span class="hljs-type">long</span> sum=(<span class="hljs-type">long</span>)nums[i]+nums[j]+nums[left]+nums[right];<br>                    <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;<br>                        left++;<br>                    &#125;<br><br>                    <span class="hljs-keyword">else</span>&#123;<br>                        ans.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));<br>                        <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>])&#123;<br>                            left++;<br>                        &#125;<br>                        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp; nums[right]==nums[right-<span class="hljs-number">1</span>])&#123;<br>                            right--;<br>                        &#125;<br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h2><p><strong>思路：</strong></p><p>本题和上面的又不一样，本题中是分为了4个数组,其中分别表示a,b,,c,d。如果a+b+c+d=0则为一个元组，不需要考虑重复。统计有多少个taple。把a,b的和作为key，value为出现的次数。然后遍历后面两个数组，如果后面c+d=0-（a+b）那么次数加一，并且统计到count中，也就是最终数量。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        <span class="hljs-comment">//思路：遍历n次</span><br>        Map&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j:nums2)&#123;<br>                map.put(i+j,map.getOrDefault(i+j,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j:nums4)&#123;<br>                count+=map.getOrDefault(<span class="hljs-number">0</span>-i-j,<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见API（JAVA）"><a href="#常见API（JAVA）" class="headerlink" title="常见API（JAVA）"></a>常见API（JAVA）</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p> 1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。</p><p> 2：get方法：get(key)，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。</p><p>  3：remove方法：remove(key)，主要用来删除map中对应的key及其value值。</p><p>4：clear方法，用法：clear()，会清空map中的数据。</p><p>5：containsKey(key)，判断map集合中是否包含某个key。</p><p>6：containsKey(value)，判断map集合中是否包含某个value。</p><p>7：entrySet()：hashmap.entrySet().iterator()，entrySet()的效率比keySet()要高。key和value存储在entry对象里面，遍历的时候，拿到entry对象就可以取到value了。</p><p>8：keySet()：hashmap.keySet().iterator()，keySet是把key放到一个set集合中，通过迭代器遍历，再用hashmap.get(key)来取到value的值。  </p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>  1.add(Object obj)方法（详述）：</p><p>2.size() 方法：</p><p>3.remove(Object  obj)方法 ： </p><p>4.isEmpty()方法 ：</p><p>5.clear() 方法： </p><p>6.iterator() 迭代器：</p><p>7.contains(Object o)方法：</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发控制（一）</title>
    <link href="/2024/01/25/Java%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/01/25/Java%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程就可以视为程序的一个实例。一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行线程作为最小调度单位，进程作为资源分配的最小单位。</p><p><strong>二者对比</strong></p><ul><li>  进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>  进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>  进程间通信较为复杂</li><li>  同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>  不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li><li>  线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>  线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a><strong>并行与并发</strong></h2><ul><li><p>  单核cpu下，线程实际还是串行执行的。线程轮流使用CPU的做法称为并发，concurrent</p></li><li><p>  多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。</p></li><li><p>  并发（concurrent）是同一时间应对（dealing with）多件事情的能力</p></li><li><p>  并行（parallel）是同一时间动手做（doing）多件事情的能力</p></li></ul><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><p>（1）直接使用Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法的参数是给线程指定名字，推荐</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-comment">// run 方法内实现了要执行的任务</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br> log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br> &#125;<br>&#125;;<br>t1.start();<br></code></pre></td></tr></table></figure><p>（2）使用Runnable配合Thread（推荐，在配合线程池方便）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br> &#125;<br>&#125;;<br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>  runnable实际上是用的thread.run创建线程，只有当runnable对象为空的时候才用runnable.run()。    </li></ul><p>（3）FutureTask配合Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask&lt;Integer&gt; task3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;log.debug(<span class="hljs-string">&quot;hello&quot;</span>)；<br> <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;&#125;);<br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task3, <span class="hljs-string">&quot;t3&quot;</span>).start();<br><span class="hljs-comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> task3.get();<br>log.debug(<span class="hljs-string">&quot;结果是:&#123;&#125;&quot;</span>, result);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java并发控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>swagger使用指南</title>
    <link href="/2024/01/25/swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2024/01/25/swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="接口工具postman、swagger、knife4j"><a href="#接口工具postman、swagger、knife4j" class="headerlink" title="接口工具postman、swagger、knife4j"></a>接口工具postman、swagger、knife4j</h1><h2 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h2><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。postman被500万开发者和超100,000家公司用于每月访问1.3亿个API。</p><p>官方网址：<a href="https://www.postman.com/">https://www.postman.com/</a></p><p>解压资料文件夹中的软件，安装即可</p><p><img src="/../images/image-20210413162511873.png" alt="image-20210413162511873"></p><p>通常的接口测试查看请求和响应，下面是登录请求的测试</p><p><img src="/../images/image-20210413162558657.png" alt="image-20210413162558657"></p><h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><p>(1)简介</p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：</p><ol><li><p>使得前后端分离开发更加方便，有利于团队协作</p></li><li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p></li><li><p>功能测试 </p><p> Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p></li></ol><p>(2)SpringBoot集成Swagger</p><ul><li><p>引入依赖,在heima-leadnews-model和heima-leadnews-common模块中引入该依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>只需要在heima-leadnews-common中进行配置即可，因为其他微服务工程都直接或间接依赖即可。</p><ul><li>在heima-leadnews-common工程中添加一个配置类</li></ul><p>新增：com.heima.common.swagger.SwaggerConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.common.swagger;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.PathSelectors;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;<br><span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<br><span class="hljs-keyword">import</span> springfox.documentation.service.Contact;<br><span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<br><span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfiguration</span> &#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">buildDocket</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>              .apiInfo(buildApiInfo())<br>              .select()<br>              <span class="hljs-comment">// 要扫描的API(Controller)基础包</span><br>              .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.heima&quot;</span>))<br>              .paths(PathSelectors.any())<br>              .build();<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">buildApiInfo</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Contact</span> <span class="hljs-variable">contact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;黑马程序员&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>              .title(<span class="hljs-string">&quot;黑马头条-平台管理API文档&quot;</span>)<br>              .description(<span class="hljs-string">&quot;黑马头条后台api&quot;</span>)<br>              .contact(contact)<br>              .version(<span class="hljs-string">&quot;1.0.0&quot;</span>).build();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在heima-leadnews-common模块中的resources目录中新增以下目录和文件</p><p>文件：resources/META-INF/Spring.factories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>  com.heima.common.swagger.SwaggerConfiguration<br></code></pre></td></tr></table></figure><p>（3）Swagger常用注解</p><p>在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：</p><p>@Api：修饰整个类，描述Controller的作用  </p><p>@ApiOperation：描述一个类的一个方法，或者说一个接口  </p><p>@ApiParam：单个参数的描述信息  </p><p>@ApiModel：用对象来接收参数  </p><p>@ApiModelProperty：用对象接收参数时，描述对象的一个字段  </p><p>@ApiResponse：HTTP响应其中1个描述  </p><p>@ApiResponses：HTTP响应整体描述  </p><p>@ApiIgnore：使用该注解忽略这个API  </p><p>@ApiError ：发生错误返回的信息  </p><p>@ApiImplicitParam：一个请求参数  </p><p>@ApiImplicitParams：多个请求参数的描述信息</p><p> @ApiImplicitParam属性：</p><table><thead><tr><th>属性</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>paramType</td><td></td><td>查询参数类型</td></tr><tr><td></td><td>path</td><td>以地址的形式提交数据</td></tr><tr><td></td><td>query</td><td>直接跟参数完成自动映射赋值</td></tr><tr><td></td><td>body</td><td>以流的形式提交 仅支持POST</td></tr><tr><td></td><td>header</td><td>参数在request headers 里边提交</td></tr><tr><td></td><td>form</td><td>以form表单的形式提交 仅支持POST</td></tr><tr><td>dataType</td><td></td><td>参数的数据类型 只作为标志说明，并没有实际验证</td></tr><tr><td></td><td>Long</td><td></td></tr><tr><td></td><td>String</td><td></td></tr><tr><td>name</td><td></td><td>接收参数名</td></tr><tr><td>value</td><td></td><td>接收参数的意义描述</td></tr><tr><td>required</td><td></td><td>参数是否必填</td></tr><tr><td></td><td>true</td><td>必填</td></tr><tr><td></td><td>false</td><td>非必填</td></tr><tr><td>defaultValue</td><td></td><td>默认值</td></tr></tbody></table><p>我们在ApUserLoginController中添加Swagger注解，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/v1/login&quot;)</span><br><span class="hljs-meta">@Api(value = &quot;app端用户登录&quot;, tags = &quot;ap_user&quot;, description = &quot;app端用户登录API&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApUserLoginController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApUserService apUserService;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/login_auth&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;用户登录&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> LoginDto dto)</span>&#123;<br>        <span class="hljs-keyword">return</span> apUserService.login(dto);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LoginDto</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginDto</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiModelProperty(value=&quot;手机号&quot;,required = true)</span><br>    <span class="hljs-keyword">private</span> String phone;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiModelProperty(value=&quot;密码&quot;,required = true)</span><br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动user微服务，访问地址：<a href="http://localhost:51801/swagger-ui.html">http://localhost:51801/swagger-ui.html</a></p><h2 id="knife4j"><a href="#knife4j" class="headerlink" title="knife4j"></a>knife4j</h2><p>(1)简介</p><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p><p>gitee地址：<a href="https://gitee.com/xiaoym/knife4j">https://gitee.com/xiaoym/knife4j</a></p><p>官方文档：<a href="https://doc.xiaominfo.com/">https://doc.xiaominfo.com/</a></p><p>效果演示：<a href="http://knife4j.xiaominfo.com/doc.html">http://knife4j.xiaominfo.com/doc.html</a></p><p>(2)核心功能</p><p>该UI增强包主要包括两大核心功能：文档说明 和 在线调试</p><ul><li>文档说明：根据Swagger的规范说明，详细列出接口文档的说明，包括接口地址、类型、请求示例、请求参数、响应示例、响应参数、响应码等信息，使用swagger-bootstrap-ui能根据该文档说明，对该接口的使用情况一目了然。</li><li>在线调试：提供在线接口联调的强大功能，自动解析当前接口参数,同时包含表单验证，调用参数可返回接口响应内容、headers、Curl请求命令实例、响应时间、响应状态码等信息，帮助开发者在线调试，而不必通过其他测试工具测试接口是否正确,简介、强大。</li><li>个性化配置：通过个性化ui配置项，可自定义UI的相关显示信息</li><li>离线文档：根据标准规范，生成的在线markdown离线文档，开发者可以进行拷贝生成markdown接口文档，通过其他第三方markdown转换工具转换成html或pdf，这样也可以放弃swagger2markdown组件</li><li>接口排序：自1.8.5后，ui支持了接口排序功能，例如一个注册功能主要包含了多个步骤,可以根据swagger-bootstrap-ui提供的接口排序规则实现接口的排序，step化接口操作，方便其他开发者进行接口对接</li></ul><p>(3)快速集成</p><ul><li>在heima-leadnews-common模块中的<code>pom.xml</code>文件中引入<code>knife4j</code>的依赖,如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>创建Swagger配置文件</li></ul><p>在heima-leadnews-common模块中新建配置类</p><p>新建Swagger的配置文件<code>SwaggerConfiguration.java</code>文件,创建springfox提供的Docket分组对象,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.common.knife4j;<br><br><span class="hljs-keyword">import</span> com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Import;<br><span class="hljs-keyword">import</span> springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.PathSelectors;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;<br><span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<br><span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<br><span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-meta">@EnableKnife4j</span><br><span class="hljs-meta">@Import(BeanValidatorPluginsConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Swagger2Configuration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(value = &quot;defaultApi2&quot;)</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">defaultApi2</span><span class="hljs-params">()</span> &#123;<br>        Docket docket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                <span class="hljs-comment">//分组名称</span><br>                .groupName(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .select()<br>                <span class="hljs-comment">//这里指定Controller扫描包路径</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.heima&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>        <span class="hljs-keyword">return</span> docket;<br>    &#125;<br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;黑马头条API文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;黑马头条API文档&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上有两个注解需要特别说明，如下表：</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@EnableSwagger2</code></td><td>该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加</td></tr><tr><td><code>@EnableKnife4j</code></td><td>该注解是<code>knife4j</code>提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加</td></tr></tbody></table><ul><li>添加配置</li></ul><p>在Spring.factories中新增配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>  com.heima.common.swagger.Swagger2Configuration, \<br>  com.heima.common.swagger.SwaggerConfiguration<br></code></pre></td></tr></table></figure><ul><li>访问</li></ul><p>在浏览器输入地址：<code>http://host:port/doc.html</code></p><p><strong>常用api：</strong></p><p>@API</p><p>@ApiOperation</p><p>@ApiModelProperty</p><p>@ApilmplicitParam</p><p>@ApilmplicitParams</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>往数据库插入海量测试数据</title>
    <link href="/2024/01/24/%E5%BE%80%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%B5%B7%E9%87%8F%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/01/24/%E5%BE%80%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%B5%B7%E9%87%8F%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="插入海量数据"><a href="#插入海量数据" class="headerlink" title="插入海量数据"></a>插入海量数据</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量插入用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInsertUsers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>        stopWatch.start();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INSERT_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>        List&lt;User&gt; userList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; INSERT_NUM; i++) &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            user.setUsername(<span class="hljs-string">&quot;天空浮云&quot;</span>+i);<br>            user.setUserAccount(<span class="hljs-string">&quot;天空浮云&quot;</span>+i);<br>            user.setAvatarUrl(<span class="hljs-string">&quot;https://ts1.cn.mm.bing.net/th/id/R-C.0f934d32ccaec7313fe0c863ff837896?rik=xqgS9QMfOvgqxg&amp;riu=http%3a%2f%2fimage.hnol.net%2fc%2f2016-10%2f06%2f15%2f20161006151911351-2127595.jpg&amp;ehk=uWQPlN9EpXkxRsiGr6aqaoqEeUvn%2fp%2fVKeRyuoBJccI%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&quot;</span>);<br>            user.setGender(<span class="hljs-number">0</span>);<br>            user.setUserPassword(<span class="hljs-string">&quot;12345678&quot;</span>);<br>            user.setPhone(<span class="hljs-string">&quot;13450448027&quot;</span>);<br>            user.setEmail(<span class="hljs-string">&quot;123@qq.com&quot;</span>);<br>            user.setTags(<span class="hljs-string">&quot;[]&quot;</span>);<br>            user.setUserStatus(<span class="hljs-number">0</span>);<br>            user.setUserRole(<span class="hljs-number">0</span>);<br>            user.setPlanetCode(<span class="hljs-string">&quot;30000&quot;</span>+i);<br>            userList.add(user);<br>        &#125;<br>        <span class="hljs-comment">// 20 秒 10 万条</span><br>        userService.saveBatch(userList, <span class="hljs-number">10000</span>);<br>        stopWatch.stop();<br>        System.out.println(stopWatch.getTotalTimeMillis());<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIS-Family项目笔记</title>
    <link href="/2024/01/23/MIS-Family%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/23/MIS-Family%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="MIS-Family"><a href="#MIS-Family" class="headerlink" title="MIS-Family"></a>MIS-Family</h1><h2 id="开发日记"><a href="#开发日记" class="headerlink" title="开发日记"></a>开发日记</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>  [ ] 主页的动态页面</li><li>  [ ] 消息页面</li><li>  [ ] 按钮悬浮</li><li>  [ ] 检索组件封装</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>  [x] 创建队伍</li><li>  [x] 修改队伍</li><li>  [x] 查询队伍列表</li><li>  [x] 加入队伍接口</li><li>  [x] 解散队伍</li><li>  [x] 退出队伍</li><li>  [x] 查询我创建的队伍</li><li>  [x] 查询我加入的队伍（所有队伍类型，加密的也是）</li><li>  [ ] 通过tag查找用户和队伍</li><li>  [ ] 发布动态</li><li>  [ ] 聊天（微信聊天类似）</li><li>  [ ] base数据插入进行封装</li></ul><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><ul><li>  找伙伴（√）</li></ul><p><img src="/../images/image-20240124135036206.png" alt="image-20240124135036206"></p><p><img src="/../images/image-20240124135057394.png" alt="image-20240124135057394"></p><p>将主页和队伍放在一个页面，添加一个筛选器，要可以筛选队伍或者伙伴。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/image-20240124135433590.png" alt="image-20240124135433590"></h2><p>搜索功能：既要可以搜索队伍名字、伙伴名字、标签。</p><p>当前只有搜索伙伴的名称功能</p><p><img src="/../images/image-20240124135714574.png" alt="image-20240124135714574"></p><p>主页修改成动态。</p><p><img src="/../images/image-20240124135745342.png" alt="image-20240124135745342"></p><p>添加一个消息（聊天功能）</p><h3 id="查找功能"><a href="#查找功能" class="headerlink" title="查找功能"></a>查找功能</h3><h3 id="用户功能"><a href="#用户功能" class="headerlink" title="用户功能"></a>用户功能</h3><p>用户可以选择自己是否可以被别人看到，</p><h3 id="队伍功能"><a href="#队伍功能" class="headerlink" title="队伍功能"></a>队伍功能</h3><p>找队伍应该 找的是没有加入的队伍</p><h3 id="聊天功能"><a href="#聊天功能" class="headerlink" title="聊天功能"></a>聊天功能</h3><h3 id="发布动态功能"><a href="#发布动态功能" class="headerlink" title="发布动态功能"></a>发布动态功能</h3><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>队伍表</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>用户表</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>用户标签表（×）</p><p>用户和标签是多对多，队伍和用户是多对多，一个队伍有多个标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h2 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h2><p>高级数据结构</p><p><img src="/../images/image-20240130131237731.png" alt="image-20240130131237731"></p><p>Java断言</p><p>redis默认序列化器，换序列化器</p><p>StringRedisTemplate</p><p><img src="/../images/image-20240130131911550.png" alt="image-20240130131911550"></p><p>ctrl+T快速包裹</p><p>f9debug中继续运行。</p><p>ctrl+p查看参数</p><p><img src="/../images/image-20240130133234547.png" alt="image-20240130133234547"></p><p>缓存预热（针对第一次）</p><p>定时任务</p><p><img src="/../images/image-20240130134733725.png" alt="image-20240130134733725"></p><p>每天刷新所有用户的推荐列表</p><p>新增少，总用户量多。</p><p>cron表达式</p><p>白名单不写死</p><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录24-1月</title>
    <link href="/2024/01/23/%E8%AE%B0%E5%BD%9524-1%E6%9C%88/"/>
    <url>/2024/01/23/%E8%AE%B0%E5%BD%9524-1%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<h1 id="24-1-16"><a href="#24-1-16" class="headerlink" title="24-1-16"></a>24-1-16</h1><ul><li><p>  stream，lambda</p></li><li><p>  字符串转json，反序列化和序列化</p></li><li><p>  gson</p></li><li><p>```java<br>  StringUtils.isAnyBlank(userAccount, userPassword, checkPassword, planetCode)</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    用于判断传输过来的参数是否有缺失。</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span>   telnet ip port用于测试端口连接<br><br><span class="hljs-bullet">-</span>   netstat -ano | find &quot;8080&quot;//查询端口<br><br><span class="hljs-bullet">-</span>   taskkill /F /PID <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PID</span>&gt;</span></span> //杀端口<br><br><span class="hljs-section"># 24-1-17</span><br><br><span class="hljs-bullet">-</span>   通过tag来查找用户：情况如下：and或者or，都符合tag还是只有一个符合就可以了<br><br><span class="hljs-bullet">-</span>   <span class="hljs-strong">**`new TypeToken<span class="language-xml">&lt;Set<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span></span>&gt;() &#123;&#125;.getType()`**</span>这是gson处理泛型的技巧。<br><br><span class="hljs-bullet">-</span>   <span class="hljs-code">```</span><br><span class="hljs-code">    tempTagNameSet = Optional.ofNullable(tempTagNameSet).orElse(new HashSet&lt;&gt;());</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure><ol><li> <strong><code>Optional.ofNullable(tempTagNameSet)</code>：</strong> 将 <code>tempTagNameSet</code> 包装为一个 <code>Optional</code> 对象。这意味着，如果 <code>tempTagNameSet</code> 不为 null，将其包装在 <code>Optional</code> 中；如果为 null，<code>Optional</code> 中将包装一个空值（<code>null</code>）。</li><li><strong><code>.orElse(new HashSet&lt;&gt;())</code>：</strong> 如果 <code>Optional</code> 包含一个非空值，那么返回该值；否则，返回提供的默认值，即 <code>new HashSet&lt;&gt;()</code>。<ul><li>  如果 <code>tempTagNameSet</code> 不为 null，<code>orElse</code> 将返回原始的 <code>tempTagNameSet</code>。</li><li>  如果 <code>tempTagNameSet</code> 为 null，<code>orElse</code> 将返回一个新的空的 <code>HashSet&lt;&gt;</code>。</li></ul></li></ol><p>  这种用法可以防止 <code>tempTagNameSet</code> 为 null 时引发空指针异常，并提供一个默认值，以确保后续代码能够正常运行。</p></li><li><p><img src="/../images/image-20240117161029126.png" alt="image-20240117161029126"></p><p>  说明：上面的代码用来stream来处理，stream().fliter(user-&gt;{如果是true则保留，如果是false则删除})</p></li><li><p>  java8 parallelStream的陷阱</p></li></ul><h1 id="24-1-18"><a href="#24-1-18" class="headerlink" title="24-1-18"></a>24-1-18</h1><h2 id="accumulation"><a href="#accumulation" class="headerlink" title="accumulation"></a>accumulation</h2><ul><li>```<br>  @Service<br>  @RequiredArgsConstructor<br>  public class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Order&gt; implements IOrderService {<pre><code class="hljs">  private final IItemService itemService;  private final IOrderDetailService detailService;  private final ICartService cartService;</code></pre>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    上面的这个例子是说如果要提供参数为itemService的构造函数，那么我们可以在类前加上@RequiredArgsConstructor，然后声明final</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span>   ![<span class="hljs-string">image-20240118085225946</span>](<span class="hljs-link">../images/image-20240118085225946.png</span>)<br><br><span class="hljs-code">    上面的模型演示了cart和item作为两个单一模块怎么进行访问，也就是cart如果要用到item模块中的接口数据，可以通过api中心的client进行通讯，@FeignClient(value = &quot;item-service&quot;,configuration = DefaultFeignConfig.class)声明在Client中，但是我们思考一个问题那就是在利用client进行传输的时候，我们需要注意到的就是我们访问的都是controller层，而不是service层</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span>   OpenFeign 是一个基于注解的声明性 HTTP 客户端，它集成了 Ribbon 负载均衡器。Ribbon 是 Netflix 开源的负载均衡器，用于在微服务架构中进行服务实例的负载均衡。<br><br><span class="hljs-bullet">-</span>   工越笔记：<br><br><span class="hljs-bullet">    -</span>   安装<br><br><span class="hljs-bullet">    -</span>   <span class="hljs-code">```</span><br><span class="hljs-code">        cnpm install </span><br></code></pre></td></tr></table></figure></li></ul><h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><ul><li>  事务管理机制 和应用场景</li><li>  跨域怎么传递的，微服务是怎么定位对方的接口的，微服务之间的数据传输就是访问接口吗，不可以访问对方的实体类吗</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="24-1-19"><a href="#24-1-19" class="headerlink" title="24-1-19"></a>24-1-19</h1><h2 id="accumlation"><a href="#accumlation" class="headerlink" title="accumlation"></a>accumlation</h2><ul><li>```<br>  docker run -p 8848:8848 -e MODE=standalone –name nacos -d nacos/nacos-server//在启动nacos的时候要指定运行模式，否则将访问不了.  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span>   解决加密视频无法复制的问题：<span class="hljs-strong">**cmd.exe /c “echo off | clip**</span><br><br><br><span class="hljs-section"># 24-1-22</span><br><br><span class="hljs-section">## accumulation</span><br><br><span class="hljs-bullet">-</span>   查询sqlserver的端口<br><br></code></pre></td></tr></table></figure>  –查询端口号<br>  exec sys.sp_readerrorlog 0, 1, ‘listening’  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">-   </span>命令启动 sentinel<br><br></code></pre></td></tr></table></figure>  java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>-   ```java<br>    reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    //数组部分逆转<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> reverse(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[<span class="hljs-keyword">start</span>];<br>                nums[<span class="hljs-keyword">start</span>] = nums[<span class="hljs-keyword">end</span>];<br>                nums[<span class="hljs-keyword">end</span>] = <span class="hljs-keyword">temp</span>;<br>                <span class="hljs-keyword">start</span> += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">end</span> -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="24-1-23"><a href="#24-1-23" class="headerlink" title="24-1-23"></a>24-1-23</h1><h2 id="accumulation-1"><a href="#accumulation-1" class="headerlink" title="accumulation"></a>accumulation</h2><ul><li><p>```java</p><pre><code class="hljs">char[] chars1 = s.toCharArray();//string转char[]</code></pre>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section"># 24-1-24</span><br><br><span class="hljs-section">## plan</span><br><br><span class="hljs-bullet">-</span>   [ ] 微服务框架学完（要求对资料上面操作熟练并且知道基本原理,总结笔记）3h<br><span class="hljs-bullet">-</span>   [x] 伙伴匹配项目后端搞懂（每个接口都debug一遍，记笔记）1h30min<br><span class="hljs-bullet">-</span>   [x] 伙伴匹配系统视频课（4-6）3h（完成缓存 + 定时任务 + 分布式锁）<br><span class="hljs-bullet">-</span>   [x] 伙伴匹配修改前端（大改，加入自己的想法）1h30min<br><span class="hljs-bullet">-</span>   [ ] 做好代码编写，方法确定（看10篇以上的论文，并且学习其中的方法）1h30min<br><span class="hljs-bullet">-</span>   [ ] 《图解TCPIP》第一章，并且写总结（400字）2h<br><span class="hljs-bullet">-</span>   [ ] 计算机网络408第一章<br><span class="hljs-bullet">-</span>   [ ] 代码随想录哈希表相关题目1h<br><span class="hljs-bullet">-</span>   [ ] Java反射复习、集合总结1h30min<br><span class="hljs-bullet">-</span>   [x] 文件预览功能<br><br><span class="hljs-section">## accumlation</span><br><br><span class="hljs-bullet">-</span>   <span class="hljs-code">```java</span><br><span class="hljs-code">    StringUtils.isAnyBlank(userAccount, userPassword, checkPassword, planetCode)//用于判断是否有空</span><br></code></pre></td></tr></table></figure></li><li><p>```java<br>  // 账户不能包含特殊字符<br>  String validPattern = “[`~!@#$%^&amp;*()+=|{}’:;’,\\[\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|{}【】‘；：”“’。，、？]”;<br>  Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);<br>  if (matcher.find()) {</p><pre><code class="hljs">  return -1;</code></pre><p>  }</p>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>-   ```java<br>    <span class="hljs-comment">// 2. 密码加密</span><br>    String encryptPassword = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigestUtils</span>.</span></span>md5<span class="hljs-constructor">DigestAsHex((SALT + <span class="hljs-params">userPassword</span>)</span>.get<span class="hljs-constructor">Bytes()</span>);<br></code></pre></td></tr></table></figure></li><li><p>```java<br>  // 3. 用户脱敏<br>  User safetyUser = getSafetyUser(user);</p>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>-   ```java<br>    <span class="hljs-comment">// 4. 记录用户的登录态</span><br>    request.get<span class="hljs-constructor">Session()</span>.set<span class="hljs-constructor">Attribute(USER_LOGIN_STATE, <span class="hljs-params">safetyUser</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>  **truncate table **//清空数据表</p></li><li><p>```<br>  //利用v-model绑定</p>  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">-   </span>stopwatch用于倒计时<br><br><span class="hljs-bullet">-   </span>缓存 <span class="hljs-code">+ 定时任务 +</span> 分布式锁<br><br><span class="hljs-bullet">-   </span><span class="hljs-code">```</span><br><span class="hljs-code">    @Scheduled//定时器</span><br></code></pre></td></tr></table></figure></li><li><p>  异步操作<img src="D:\Codefield\projects\selfBlog\source\images\image-20240124212433453.png" alt="image-20240124212433453"></p></li><li><p>  for循环是绝对线性的（并发），并发要注意执行的先后顺序，不要使用非并发类的集合</p></li><li><p>  java默认线程池线程数是CPU核数</p></li><li><p>  <img src="D:\Codefield\projects\selfBlog\source\images\image-20240124213706751.png" alt="image-20240124213706751">面试考点</p></li><li><p>//CPU密集型：分配的核心线程数=CPU-1<br>  //I0密集型：分配的核心线程数可以大于CPU核数</p></li><li><p>  不可以把几万条数据同时传给前端</p></li><li><p>  预加载缓存，定时任务</p></li><li><p>  分布式锁：只有一台机器去执行定时任务</p></li></ul><h1 id="24-1-25"><a href="#24-1-25" class="headerlink" title="24-1-25"></a>24-1-25</h1><h2 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h2><ul><li>  [ ] 微服务框架学完（要求对资料上面操作熟练并且知道基本原理,总结笔记）3h</li><li>  [ ] 伙伴匹配用户功能模块、队伍模块后端1h</li><li>  [ ] 并发控制学习1h30min</li><li>  [ ] 伙伴匹配系统视频课（4-6）3h（完成缓存 + 定时任务 + 分布式锁）</li><li>  [ ] 伙伴匹配修改前端（主页和消息页面）1h30min</li><li>  [ ] 方法确定，学习方法（看10篇以上的论文，并且学习其中的方法）1h30min</li><li>  [ ] 《图解TCPIP》第一章，并且写总结（400字）2h</li><li>  [ ] 计算机网络408第一章</li><li>  [ ] 代码随想录哈希表相关题目1h</li><li>  [ ] Java反射复习、集合总结1h30min</li></ul><h2 id="accumlation-1"><a href="#accumlation-1" class="headerlink" title="accumlation"></a>accumlation</h2><ul><li>  querywapper的常用方法</li></ul><blockquote><p>  queryWrapper.lt（）——小于<br>  queryWrapper.le（）——小于等于<br>  queryWrapper.gt（）——大于<br>  queryWrapper.ge（）——大于等于<br>  queryWrapper.eq（）——等于<br>  queryWrapper.ne（）——不等于<br>  queryWrapper.betweeen（“age”,10,20）——age在值10到20之间<br>  queryWrapper.notBetweeen（“age”,10,20）——age不在值10到20之间<br>  queryWrapper.like（“属性”,“值”）——模糊查询匹配值‘%值%’<br>  queryWrapper.notLike（“属性”,“值”）——模糊查询不匹配值‘%值%’<br>  queryWrapper.likeLeft（“属性”,“值”）——模糊查询匹配最后一位值‘%值’<br>  queryWrapper.likeRight（“属性”,“值”）——模糊查询匹配第一位值‘值%’<br>  queryWrapper.isNull（）——值为空或null<br>  queryWrapper.isNotNull（）——值不为空或null<br>  queryWrapper.in（“属性”，条件，条件 ）——符合多个条件的值<br>  queryWrapper.notIn(“属性”，条件，条件 )——不符合多个条件的值<br>  queryWrapper.or（）——或者<br>  queryWrapper.and（）——和<br>  queryWrapper.orderByAsc(“属性”)——根据属性升序排序<br>  queryWrapper.orderByDesc(“属性”)——根据属性降序排序<br>  queryWrapper.inSql(“sql语句”)——符合sql语句的值<br>  queryWrapper.notSql(“sql语句”)——不符合SQL语句的值<br>  queryWrapper.esists（“SQL语句”）——查询符合SQL语句的值<br>  queryWrapper.notEsists（“SQL语句”）——查询不符合SQL语句的值</p></blockquote><ul><li><p>  HttpServletRequest方法<img src="D:\Codefield\projects\selfBlog\source\images\20200305162823909.jpg" alt="资源分配图"></p></li><li><p>  HttpServletRequest方法<img src="D:\Codefield\projects\selfBlog\source\images\20200305163009658.jpg" alt="资源分配图"></p></li></ul><h1 id="24-1-29"><a href="#24-1-29" class="headerlink" title="24-1-29"></a>24-1-29</h1><h2 id="plan-1"><a href="#plan-1" class="headerlink" title="plan"></a>plan</h2><ul><li>  [x] SpringCloud(Day01)</li><li>  [x] 黑马头条（Day01）</li><li>  [ ] 伙伴匹配项目后端完成3h</li><li>  [ ] 伙伴匹配系统视频课7</li><li>  [ ] 《图解TCPIP》第一章，记笔记1h</li><li>  [x] 代码随想录哈希表相关题目</li><li>  [x] 哈希表总结，包括常见API和底层实现</li><li>  [ ] Java基础所有面经</li></ul><h2 id="accumlation-2"><a href="#accumlation-2" class="headerlink" title="accumlation"></a>accumlation</h2><ul><li><p>  navicat连接不上服务器docker中的mysql，重启docker，重启mysql。</p></li><li><p>  <a href="http://192.168.137.132:8848/nacos/%E8%AE%BF%E9%97%AEnacos%E5%9C%B0%E5%9D%80">http://192.168.137.132:8848/nacos/访问nacos地址</a></p></li><li><pre><code class="java">  //将结果集合转为数组  resSet.stream().mapToInt(x -&gt; x).toArray();  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span>   HashSet中的常用方法<br><br><span class="hljs-code">    1.add(Object obj)方法（详述）：</span><br><span class="hljs-code"></span><br><span class="hljs-code">    2.size() 方法：</span><br><span class="hljs-code"></span><br><span class="hljs-code">    3.remove(Object  obj)方法 ： </span><br><span class="hljs-code"></span><br><span class="hljs-code">    4.isEmpty()方法 ：</span><br><span class="hljs-code"></span><br><span class="hljs-code">    5.clear() 方法： </span><br><span class="hljs-code"></span><br><span class="hljs-code">    6.iterator() 迭代器：</span><br><span class="hljs-code"></span><br><span class="hljs-code">    7.contains(Object o)方法：</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span>   map.put(i+j,map.getOrDefault(i+j,0)+1);在java的map中插入数据。<br><br><span class="hljs-section">## question</span><br><br><span class="hljs-bullet">-</span>   spring的生命周期<br><span class="hljs-bullet">-</span>   spring启动类的原理<br><br><span class="hljs-section"># 24-1-30</span><br><br><span class="hljs-section">## plan</span><br><br><span class="hljs-bullet">-</span>   [x] SpringCloud(Day02)<br><span class="hljs-bullet">-</span>   [ ] 黑马头条（Day02-03）<br><span class="hljs-bullet">-</span>   [x] 伙伴匹配项目后端完成队伍的业务层代码（添加）<br><span class="hljs-bullet">-</span>   [ ] 伙伴匹配系统视频课8-9<br><span class="hljs-bullet">-</span>   [x] 《图解TCPIP》第1章<br><span class="hljs-bullet">-</span>   [x] 代码随想录字符串（有剩余）<br><span class="hljs-bullet">-</span>   [x] 《深入理解Java虚拟机》第一部分<br><span class="hljs-bullet">-</span>   [ ] JavaGuide、小林（计算机网络，JVM，Java基础）<br><br><span class="hljs-section">## accumlation</span><br><br><span class="hljs-bullet">-</span>   卸载redis<br><br></code></pre></td></tr></table></figure>  　　　　rm -rf /usr/local/redis //删除安装目录     　　　　rm -rf /usr/bin/redis-* //删除所有redis相关命令脚本     　　　　rm -rf /root/download/redis-4.0.4 //删除redis解压文件夹  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">-   </span>安装redis<br><br></code></pre></td></tr></table></figure>  docker pull redis  docker run --name my-redis-container -p 6379:6379 -d redis  docker exec -it my-redis-container /bin/bash    <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">-   </span>在配置文件中写路径的时候要看看/还是\<br><br><span class="hljs-bullet">-   </span>查看端口状态，和关闭端口<br><br></code></pre></td></tr></table></figure>  netstat -anp |grep 3306  kill -9 port</code></pre></li><li></li></ul><h1 id="24-1-31"><a href="#24-1-31" class="headerlink" title="24-1-31"></a>24-1-31</h1><h2 id="plan-2"><a href="#plan-2" class="headerlink" title="plan"></a>plan</h2><ul><li>  [x] 伙伴匹配项目控制层代码完成，并且修改逻辑不通的地方。（3小时）</li><li>  [ ] 代码随想录字符串（1小时）</li><li>  [ ] 微服务Day03</li><li>  [ ] 黑马头条项目</li><li>  [ ] </li></ul><h2 id="accumlation-3"><a href="#accumlation-3" class="headerlink" title="accumlation"></a>accumlation</h2><ul><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>日常记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题汇总</title>
    <link href="/2024/01/22/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/01/22/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见配置检索</title>
    <link href="/2024/01/22/%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%A3%80%E7%B4%A2/"/>
    <url>/2024/01/22/%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%A3%80%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>(1)yml书写格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#常见写法</span><br><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">maps:</span><br>   <span class="hljs-attr">key:</span> <span class="hljs-string">value</span><br><span class="hljs-comment">#数组</span><br><span class="hljs-attr">person:</span><br> <span class="hljs-attr">list:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-number">1</span><br> <span class="hljs-bullet">-</span> <span class="hljs-number">2</span><br> <span class="hljs-bullet">-</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>（2）yml多文档方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">prod</span> <span class="hljs-comment">#指定使用哪个环境</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span>  <span class="hljs-comment">#指定属于哪个环境</span><br><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8084</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">prod</span>  <span class="hljs-comment">#指定属于哪个环境</span><br></code></pre></td></tr></table></figure><h2 id="常用的yml"><a href="#常用的yml" class="headerlink" title="常用的yml"></a>常用的yml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 公共配置文件</span><br><span class="hljs-comment"># @author &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span><br><span class="hljs-comment"># @from &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-init</span><br>  <span class="hljs-comment"># 默认 dev 环境</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-comment"># 支持 swagger3</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ant_path_matcher</span><br>  <span class="hljs-comment"># session 配置</span><br>  <span class="hljs-attr">session:</span><br>    <span class="hljs-comment"># todo 取消注释开启分布式 session（须先配置 Redis）</span><br>    <span class="hljs-comment"># store-type: redis</span><br>    <span class="hljs-comment"># 30 天过期</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">2592000</span><br>  <span class="hljs-comment"># 数据库配置</span><br>  <span class="hljs-comment"># todo 需替换配置</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/my_db</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>  <span class="hljs-comment"># Redis 配置</span><br>  <span class="hljs-comment"># todo 需替换配置，然后取消注释</span><br><span class="hljs-comment">#  redis:</span><br><span class="hljs-comment">#    database: 1</span><br><span class="hljs-comment">#    host: localhost</span><br><span class="hljs-comment">#    port: 6379</span><br><span class="hljs-comment">#    timeout: 5000</span><br><span class="hljs-comment">#    password: 123456</span><br>  <span class="hljs-comment"># Elasticsearch 配置</span><br>  <span class="hljs-comment"># todo 需替换配置，然后取消注释</span><br><span class="hljs-comment">#  elasticsearch:</span><br><span class="hljs-comment">#    uris: http://localhost:9200</span><br><span class="hljs-comment">#    username: root</span><br><span class="hljs-comment">#    password: 123456</span><br>  <span class="hljs-comment"># 文件上传</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-comment"># 大小限制</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">address:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8101</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/api</span><br>    <span class="hljs-comment"># cookie 30 天过期</span><br>    <span class="hljs-attr">session:</span><br>      <span class="hljs-attr">cookie:</span><br>        <span class="hljs-attr">max-age:</span> <span class="hljs-number">2592000</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">isDelete</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名</span><br>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值（默认为 1）</span><br>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值（默认为 0）</span><br><span class="hljs-comment"># 微信相关</span><br><span class="hljs-attr">wx:</span><br>  <span class="hljs-comment"># 微信公众平台</span><br>  <span class="hljs-comment"># todo 需替换配置</span><br>  <span class="hljs-attr">mp:</span><br>    <span class="hljs-attr">token:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">aesKey:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">appId:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">secret:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">config-storage:</span><br>      <span class="hljs-attr">http-client-type:</span> <span class="hljs-string">HttpClient</span><br>      <span class="hljs-attr">key-prefix:</span> <span class="hljs-string">wx</span><br>      <span class="hljs-attr">redis:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">Memory</span><br>  <span class="hljs-comment"># 微信开放平台</span><br>  <span class="hljs-comment"># todo 需替换配置</span><br>  <span class="hljs-attr">open:</span><br>    <span class="hljs-attr">appId:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">appSecret:</span> <span class="hljs-string">xxx</span><br><span class="hljs-comment"># 对象存储</span><br><span class="hljs-comment"># todo 需替换配置</span><br><span class="hljs-attr">cos:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">accessKey:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">region:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">bucket:</span> <span class="hljs-string">xxx</span><br><span class="hljs-comment"># 接口文档配置</span><br><span class="hljs-attr">knife4j:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">openapi:</span><br>    <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;接口文档&quot;</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><br>    <span class="hljs-attr">group:</span><br>      <span class="hljs-attr">default:</span><br>        <span class="hljs-attr">api-rule:</span> <span class="hljs-string">package</span><br>        <span class="hljs-attr">api-rule-resources:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">com.yupi.springbootinit.controller</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis-Mysql"><a href="#Mybatis-Mysql" class="headerlink" title="Mybatis+Mysql"></a>Mybatis+Mysql</h2><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-comment">&lt;!--MySQL驱动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--jdbc连接数据库--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Driud--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- MyBatis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- junit测试依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>（2）编写yml配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/powernode</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>  <span class="hljs-comment">#添加 Druid 配置，指定数据源</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span><br>  <span class="hljs-comment">#目的是为了省略resultType里的代码量</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.chf.pojo</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br><br></code></pre></td></tr></table></figure><p>（3）构建实体类（在pojo包下），与表中字段一一对应</p><p><img src="/../images/image-20240122132808689.png" alt="image-20240122132808689"></p><p>（4）创建接口，用来写方法</p><p><img src="/../images/image-20240122132843961.png" alt="image-20240122132843961"></p><p>（5）每一个实体类对应一个<a href="https://so.csdn.net/so/search?q=mapper&spm=1001.2101.3001.7020">mapper</a>映射文件，在resources的mapper包下写映射文件</p><h2 id="MybatisPLus"><a href="#MybatisPLus" class="headerlink" title="MybatisPLus"></a>MybatisPLus</h2><p>（1）导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Mybatis-Plus 注意版本--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>（2）yml配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#控制台打印sql</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">【<span class="hljs-meta">@TableName</span> 】作用于类上<br>    <span class="hljs-meta">@TableName</span>               用于定义表名<br>注：<br>    常用属性：<br>        value                用于定义表名<br><br>【<span class="hljs-meta">@TableId</span>】作用于属性上<br>    <span class="hljs-meta">@TableId</span>                 用于定义表的主键<br>注：<br>    常用属性：<br>        value           用于定义主键字段名<br>        type            用于定义主键类型（主键策略 IdType）<br><br>   主键策略：<br>      IdType.AUTO          主键自增，系统分配，不需要手动输入<br>      IdType.NONE          未设置主键<br>      IdType.INPUT         需要自己输入 主键值。<br>      IdType.ASSIGN_ID     系统分配 ID，用于数值型数据（Long，对应 mysql 中 BIGINT 类型）。<br>      IdType.ASSIGN_UUID   系统分配 UUID，用于字符串型数据（String，对应 mysql 中 varchar(<span class="hljs-number">32</span>) 类型）。<br><br>【<span class="hljs-meta">@TableField</span>】  作用与属性上<br>    <span class="hljs-meta">@TableField</span>            用于定义表的非主键字段。<br>注：<br>    常用属性：<br>        value                用于定义非主键字段名<br>        exist                用于指明是否为数据表的字段， <span class="hljs-literal">true</span> 表示是，<span class="hljs-literal">false</span> 为不是。<br>        fill                 用于指定字段填充策略（FieldFill）。<br>        <br>    字段填充策略：（一般用于填充 创建时间、修改时间等字段）<br>        FieldFill.DEFAULT         默认不填充<br>        FieldFill.INSERT          插入时填充<br>        FieldFill.UPDATE          更新时填充<br>        FieldFill.INSERT_UPDATE   插入、更新时填充。<br><br>【<span class="hljs-meta">@TableLogic</span>】<br>    <span class="hljs-meta">@TableLogic</span>           用于定义表的字段进行逻辑删除（非物理删除）<br>注：<br>    常用属性：<br>        value            用于定义未删除时字段的值<br>        delval           用于定义删除时字段的值<br>        <br>【<span class="hljs-meta">@Version</span>】作用于属性上<br>    <span class="hljs-meta">@Version</span>             用于字段实现乐观锁<br><br></code></pre></td></tr></table></figure><h2 id="Swagger和Knife4j"><a href="#Swagger和Knife4j" class="headerlink" title="Swagger和Knife4j"></a>Swagger和Knife4j</h2><p>knife4j是swagger的增强</p><p>（1）添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加swagger的依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）创建Knife4j配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Swagger2配置信息</span><br><span class="hljs-comment"> * 这里分了两组显示</span><br><span class="hljs-comment"> * 第一组是api，当作用户端接口</span><br><span class="hljs-comment"> * 第二组是admin，当作后台管理接口</span><br><span class="hljs-comment"> * 也可以根据实际情况来减少或者增加组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Eric</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2023-07-30 22:17</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2WebMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Swagger2Config</span> &#123;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">adminApiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;Eric-SpringBoot整合Knife4j-API文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;本文档描述了SpringBoot如何整合Knife4j&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;Eric&quot;</span>, <span class="hljs-string">&quot;https://blog.csdn.net/weixin_47316183?type=blog&quot;</span>, <span class="hljs-string">&quot;ericsyn@foxmail.com&quot;</span>))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">webApiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;Eric-SpringBoot整合Knife4j-API文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;本文档描述了SpringBoot如何整合Knife4j&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;Eric&quot;</span>, <span class="hljs-string">&quot;https://blog.csdn.net/weixin_47316183?type=blog&quot;</span>, <span class="hljs-string">&quot;ericsyn@foxmail.com&quot;</span>))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第一组：api</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">webApiConfig</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Parameter&gt; pars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ParameterBuilder</span> <span class="hljs-variable">tokenPar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterBuilder</span>();<br>        tokenPar.name(<span class="hljs-string">&quot;userId&quot;</span>)<br>                .description(<span class="hljs-string">&quot;用户token&quot;</span>)<br>                <span class="hljs-comment">//.defaultValue(JwtHelper.createToken(1L, &quot;admin&quot;))</span><br>                .defaultValue(<span class="hljs-string">&quot;1&quot;</span>)<br>                .modelRef(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelRef</span>(<span class="hljs-string">&quot;string&quot;</span>))<br>                .parameterType(<span class="hljs-string">&quot;header&quot;</span>)<br>                .required(<span class="hljs-literal">false</span>)<br>                .build();<br>        pars.add(tokenPar.build());<br><br>        <span class="hljs-type">Docket</span> <span class="hljs-variable">webApi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;用户端接口&quot;</span>)<br>                .apiInfo(webApiInfo())<br>                .select()<br>                <span class="hljs-comment">//只显示api路径下的页面</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.eric.springbootknife4j&quot;</span>))<br>                .paths(PathSelectors.regex(<span class="hljs-string">&quot;/api/.*&quot;</span>))<br>                .build()<br>                .globalOperationParameters(pars);<br>        <span class="hljs-keyword">return</span> webApi;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第二组：admin</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">adminApiConfig</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Parameter&gt; pars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ParameterBuilder</span> <span class="hljs-variable">tokenPar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterBuilder</span>();<br>        tokenPar.name(<span class="hljs-string">&quot;adminId&quot;</span>)<br>                .description(<span class="hljs-string">&quot;用户token&quot;</span>)<br>                .defaultValue(<span class="hljs-string">&quot;1&quot;</span>)<br>                .modelRef(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelRef</span>(<span class="hljs-string">&quot;string&quot;</span>))<br>                .parameterType(<span class="hljs-string">&quot;header&quot;</span>)<br>                .required(<span class="hljs-literal">false</span>)<br>                .build();<br>        pars.add(tokenPar.build());<br><br>        <span class="hljs-type">Docket</span> <span class="hljs-variable">adminApi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;后台接口&quot;</span>)<br>                .apiInfo(adminApiInfo())<br>                .select()<br>                <span class="hljs-comment">//只显示admin路径下的页面</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.eric.springbootknife4j&quot;</span>))<br>                .paths(PathSelectors.regex(<span class="hljs-string">&quot;/admin/.*&quot;</span>))<br>                .build()<br>                .globalOperationParameters(pars);<br>        <span class="hljs-keyword">return</span> adminApi;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>（3）使用Knife4J</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 菜单实体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ApiModel(value = &quot;菜单实体&quot;,description = &quot;菜单实体&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span> &#123;<br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;主键&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;菜单名称&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <br> <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户控制器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;用户控制器&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/getUsers&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;查询所有用户&quot;, notes = &quot;查询所有用户信息&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getAllUsers</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setId(<span class="hljs-number">100</span>);<br>        user.setName(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        user.setAge(<span class="hljs-number">20</span>);<br>        user.setAddress(<span class="hljs-string">&quot;bj&quot;</span>);<br>        List&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(user);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>plan-24</title>
    <link href="/2024/01/21/plan-24/"/>
    <url>/2024/01/21/plan-24/</url>
    
    <content type="html"><![CDATA[<h1 id="Total"><a href="#Total" class="headerlink" title="Total"></a>Total</h1><p>今年几件大事：</p><p>1、找到Java后端的工作：#双休 #8小时 #总包15w</p><p>2、25考研985计算机11408考到430+（初试第一）</p><p>3、坚持健身，保持作息和饮食</p><p>4、做一个个人大项目，要足够新颖，并且有市场需求的</p><p>5、坚持写作，坚持在知识星球打卡，坚持看书</p><p>6、雅思7.5，CET6（600+）</p><p>7、软考中级，CSP400+，PAT甲级满分</p><h2 id="Plan-Each"><a href="#Plan-Each" class="headerlink" title="Plan-Each"></a>Plan-Each</h2><h3 id="（1）Java后端"><a href="#（1）Java后端" class="headerlink" title="（1）Java后端"></a>（1）Java后端</h3><p>首先说一下现在自身的能力和buff。</p><p>可以说无竞赛（只有一个省三）、无论文、项目正在产出，24考研失利，编码能力下降，计算机基础不好。目前想通过过年这段时间准备春招，投简历时间定为2月中旬-4月，也就是只有一个月的时间，在这一个月里我需要做到像春招简历上面的技术能力，因为时间比较紧所以很多基础不能重新学，只能以面经为主，通过面经去发现自己的不足。</p><p>大概的学习路线：</p><p><strong>基础</strong></p><ul><li>  计算机网络</li><li>  操作系统</li><li>  计算机组成原理</li><li>  设计模式</li></ul><p><strong>Java技术栈</strong></p><ul><li>  Java基础</li><li>  JVM和并发控制</li><li>  Linux+Docker+Nginx+Maven+Git</li><li>  Mysql+Redis</li><li>  SSM+SpringBoot+Mybatis-Plus</li><li>  SpringSecurity</li><li>  微服务框架</li><li>  运维相关</li></ul><p><strong>项目</strong></p><ul><li>  伙伴匹配项目</li><li>  API开放平台</li><li>  OJ判题系统</li><li>  智能促销推荐平台（注重算法调优）</li></ul><h3 id="（2）11408（430-）"><a href="#（2）11408（430-）" class="headerlink" title="（2）11408（430+）"></a>（2）11408（430+）</h3><h3 id="（3）大项目"><a href="#（3）大项目" class="headerlink" title="（3）大项目"></a>（3）大项目</h3><h3 id="（4）健身、作息"><a href="#（4）健身、作息" class="headerlink" title="（4）健身、作息"></a>（4）健身、作息</h3><h3 id="（5）写作、打卡、看书"><a href="#（5）写作、打卡、看书" class="headerlink" title="（5）写作、打卡、看书"></a>（5）写作、打卡、看书</h3><hr><h2 id="January"><a href="#January" class="headerlink" title="January"></a>January</h2><h3 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h3><p><strong>基础</strong></p><ul><li>  [ ] 计算机网络（22-28）</li><li>  [ ] 操作系统（一个小项目）（29-04）</li></ul><p><strong>Java技术栈</strong></p><ul><li>  [ ] 微服务框架（22-24）</li><li>  [ ] Java基础（空闲时间看）</li><li>  [ ] JVM和并发控制（25-28）</li></ul><p><strong>项目</strong></p><ul><li>  [ ] 伙伴匹配项目完成（要有自己的）</li><li>  [ ] 微服务项目（随便找）</li></ul><p><strong>论文</strong></p><ul><li>  [ ] 做好代码编写，方法确定</li><li>  [ ] 机器学习学习（预测类的算法和模型）</li></ul><p><strong>书籍</strong></p><ul><li>  [ ] 《计算机网络自顶向下》</li><li>  [ ] 《图解TCPIP》</li></ul><p><strong>比赛</strong></p><ul><li>  [ ] 《算法笔记》刷一遍（从不会的开始刷）</li><li>  [ ] 代码随想录（数组、链表、哈希表、字符串、双指针）</li></ul><p><strong>英语</strong></p><ul><li>  [ ] 口语加听力</li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>plan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3实现移动端的pdf、docx、xlsx、ppt的预览</title>
    <link href="/2024/01/19/Vue3%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84pdf%E3%80%81docx%E3%80%81xlsx%E3%80%81ppt%E7%9A%84%E9%A2%84%E8%A7%88/"/>
    <url>/2024/01/19/Vue3%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84pdf%E3%80%81docx%E3%80%81xlsx%E3%80%81ppt%E7%9A%84%E9%A2%84%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h2 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h2><p>利用pdfh5实现，原链接<a href="https://gitee.com/gjTool/pdfh5">https://gitee.com/gjTool/pdfh5</a></p><p>(1)添加依赖</p><p><img src="/../images/image-20240119104238387.png" alt="image-20240119104238387"></p><p>(2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div id=&quot;app&quot;&gt;<br>      &lt;div id=&quot;pdfdemo&quot;&gt;&lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/template&gt;<br>  &lt;script&gt;<br>    import Pdfh5 from &quot;pdfh5&quot;;<br>    export default &#123;<br>      name: &#x27;FjPdf&#x27;,<br>      data() &#123;<br>        return &#123;<br>          pdfh5: null<br>        &#125;;<br>      &#125;,<br>      mounted() &#123;<br>          //实例化<br>        this.pdfh5 = new Pdfh5(&quot;#pdfdemo&quot;, &#123;<br>          pdfurl: &quot;http://115.231.196.26:8001/ZC_LGKY/UploadFiles/2024-01/DM8 Install_202411617610408.pdf&quot;,<br>        &#125;);<br>        //监听完成事件<br>        this.pdfh5.on(&quot;complete&quot;, function (status, msg, time) &#123;<br>          console.log(&quot;状态：&quot; + status + &quot;，信息：&quot; + msg + &quot;，耗时：&quot; + time + &quot;毫秒，总页数：&quot; + this.totalNum)<br>          //禁止手势缩放<br>          this.pdfh5.zoomEnable(false);<br>        &#125;)<br>      &#125;<br>    &#125;<br>  &lt;/script&gt;<br>  <br>  &lt;style&gt;<br>      @import &quot;pdfh5/css/pdfh5.css&quot;;<br>      *&#123;<br>      padding: 0;<br>      margin: 0;<br>      &#125;<br>      html,body,#app &#123;<br>      width: 100%;<br>      height: 100%;<br>      &#125;<br>  &lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="word"><a href="#word" class="headerlink" title="word"></a>word</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cnpm <span class="hljs-keyword">install</span> docx-preview<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;fileRef&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;preview-container&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Axios</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> fileRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">getPdfCode</span>();</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getPdfCode</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Axios</span>.<span class="hljs-title function_">get</span>(</span><br><span class="language-javascript">        <span class="hljs-string">&quot;http://115.231.196.26:8001/ZC_ZJIET/UploadFiles/2024-01/12312312_202412314182559.docx&quot;</span>,</span><br><span class="language-javascript">        &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">responseType</span>: <span class="hljs-string">&quot;blob&quot;</span>,</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    );</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> data = response.<span class="hljs-property">data</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (fileRef.<span class="hljs-property">value</span>) &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> &#123; renderAsync &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;docx-preview&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-title function_">renderAsync</span>(data, fileRef.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Invalid DOM element:&quot;</span>, fileRef.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125; <span class="hljs-keyword">catch</span> (error) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error fetching or rendering docx:&quot;</span>, error);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.preview-container</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">&#125;</span><br><span class="language-css">::v-deep .docx-wrapper&#123;</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css">::v-deep .docx-wrapper&gt;section.docx &#123;</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">72pt</span> <span class="hljs-number">171pt</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">595.3pt</span>;</span><br><span class="language-css">  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">841.9pt</span>;</span><br><span class="language-css">  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">21.25pt</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>存在问题：首先docx-preview是一个网页项目，移动端显示不好，无法调节样式。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>春招简历</title>
    <link href="/2024/01/18/%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86/"/>
    <url>/2024/01/18/%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><p>目标是中厂，人数小于20不考虑，总包在15W+。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>  [ ] 计算机网络（面经）</li><li>  [ ] 操作系统（做一个小型的操作系统）</li><li>  [ ] 计算机组成原理（408）</li><li>  [ ] 数据结构（leetcode先和代码随想录敲一遍，争取每题都要有深度理解）</li></ul><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li>  [ ] Java基础（把之前总结的笔记看完，然后把Java的知识点补齐）</li><li>  [ ] JVM和并发控制（每天晚上花1小时学习）</li><li>  [ ] HTML+CSS+Javascript+Ajax+Jquery+VUE（主要是熟练一下VUE可以自己DIY）(Vue需要多练习)</li><li>  [ ] Linux+Docker+Nginx+Maven+Git（在实战中积累，找工作之前突击）</li><li>  [ ] Mysql+Oracle+Redis（Oracle不要求，其他需要熟练）</li><li>  [ ] SSM+SpringBoot+Mybatis-Plus（重中之重）</li><li>  [ ] SpringSecurity（亮点）</li><li>  [ ] Netty+Dubbo+SpringCloud+ElasticSearch+RabbitMQ+KafKa+Zookeeper（微服务）</li><li>  [ ] K8s</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul><li>  [ ] 伙伴匹配项目</li><li>  [ ] API开放平台</li><li>  [ ] OJ判题系统</li><li>  [x] 智能促销推荐平台（需要魔改）</li><li>  [ ] 。。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>  [ ] CET6</li><li>  [ ] 数学建模省三</li><li>  [ ] CSP400+</li><li>  [ ] PAT甲级满分</li></ul><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前已经是1月中旬了，一些企业的春招已经快开始了，目前打算每天花10h+用于冲刺offer，时间确实不太够，打算过年前就是要把这个简历完善好，然后过完年就投一下杭州或者广州的后端工程师岗位，实习期间需要做一个项目，当然还有毕业论文，那个是机器学习方向的，每天抽2个小时来写就可以了。关于技术的学习我认为现在最需要的就是性价比和速度，对于一些bug我觉得没有必要太执着，那些听过的课有个影响就可以了，把时间都放在开发项目上。现在每天需要做的事情有以下：</p><ul><li>  学习技术方向的理论——上午</li><li>  做项目——下午</li><li>  健身半小时到1小时（中午控制饮食）——下班后</li><li>  学习基础方向的知识、毕业设计——晚上</li><li>  学英语，口语（找点素材跟着读）、单词（不背单词专业八级单词）、阅读（公众号）、听力（2天精听一篇）【1雄小时】——晚上睡前</li></ul><h1 id="作息"><a href="#作息" class="headerlink" title="作息"></a>作息</h1><p>早上7点起，晚上1点前睡，保证6小时。（番茄钟严格⏲）</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>大不了送外卖，反正我觉得我可以脱下孔乙己的长衫，过渡一年，考研。</p>]]></content>
    
    
    
    <tags>
      
      <tag>春招</tag>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未来一年的打算（2024年）</title>
    <link href="/2024/01/17/%E6%9C%AA%E6%9D%A5%E4%B8%80%E5%B9%B4%E7%9A%84%E6%89%93%E7%AE%97%EF%BC%882024%E5%B9%B4%EF%BC%89/"/>
    <url>/2024/01/17/%E6%9C%AA%E6%9D%A5%E4%B8%80%E5%B9%B4%E7%9A%84%E6%89%93%E7%AE%97%EF%BC%882024%E5%B9%B4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="2024"><a href="#2024" class="headerlink" title="2024"></a>2024</h1><p>我想通过2023年的磨练，在2024这一年中我一定会有非常巨大的变化，并且可能是有史以来的最明显的一次蜕变。那么在2024年有几件大事：</p><ul><li>  找到总包20w的工作</li><li>  985计算机类研究生初试400+</li><li>  开创一个副业（钱多少不是问题，就算亏了也没关系，重要的是养成经商的思路）</li><li>  雅思7.5、CET600+</li><li>  坚持在知识星球打卡</li><li>  坚持健身</li><li>  坚持看书（戒掉手机或者电子娱乐）</li></ul><h2 id="1月-2月（春招准备期-实验期）"><a href="#1月-2月（春招准备期-实验期）" class="headerlink" title="1月-2月（春招准备期+实验期）"></a>1月-2月（春招准备期+实验期）</h2><h3 id="春招！！！（所说的实验也就是把自己处于超高压下，迸发出无限潜力）"><a href="#春招！！！（所说的实验也就是把自己处于超高压下，迸发出无限潜力）" class="headerlink" title="春招！！！（所说的实验也就是把自己处于超高压下，迸发出无限潜力）"></a>春招！！！（所说的实验也就是把自己处于超高压下，迸发出无限潜力）</h3><p>1月份到2月中旬的主要任务，年后就要开始投简历。</p><p>把握好这一个月</p><p>基础篇（每天晚上）</p><p>项目（下午）</p><ul><li>  伙伴匹配项目</li><li>  OJ项目</li><li>  工越项目</li><li>  。。。</li></ul><p>框架篇（上午）</p>]]></content>
    
    
    <categories>
      
      <category>年度计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垂死挣扎——PAT备考进行时（八）</title>
    <link href="/2023/09/13/%E5%9E%82%E6%AD%BB%E6%8C%A3%E6%89%8E%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2023/09/13/%E5%9E%82%E6%AD%BB%E6%8C%A3%E6%89%8E%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="LAST-TIME"><a href="#LAST-TIME" class="headerlink" title="LAST TIME"></a>LAST TIME</h1><p>本篇文章是对23年秋季PAT的赛题进行预测，通过分析最近几年的试卷，第一题主要就是模拟题、数学问题或者字符串处理，第二三题就是经典的数据结构，最近特别喜欢考树的遍历（重点看、最喜欢考了，每年基本都有而且出现在后面两题，分值大）、链表、并查集。最后一题基本上要不就是图论（最短路径Dijkstra+DFS）、要不就是DFS、要不就是高级数据结构（最近考树的遍历很多很多一定要重视再重视）。</p><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><h2 id="Dijkstra-DFS"><a href="#Dijkstra-DFS" class="headerlink" title="Dijkstra+DFS"></a>Dijkstra+DFS</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构专题——PAT备考进行时（七）</title>
    <link href="/2023/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2023/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h2><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1032-Sharing（静态链表）（⭐）"><a href="#1032-Sharing（静态链表）（⭐）" class="headerlink" title="1032 Sharing（静态链表）（⭐）"></a><strong>1032 Sharing</strong>（静态链表）（⭐）</h2><p><strong>题目：</strong></p><blockquote><p>To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, <code>loading</code> and <code>being</code> are stored as showed in Figure 1.</p><p><img src="https://images.ptausercontent.com/ef0a1fdf-3d9f-46dc-9a27-21f989270fd4.jpg" alt="fig.jpg"></p><p>Figure 1</p><p>You are supposed to find the starting position of the common suffix (e.g. the position of <code>i</code> in Figure 1).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive <em>N</em> (≤105), where the two addresses are the addresses of the first nodes of the two words, and <em>N</em> is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by −1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><figure class="highlight purebasic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs purebasic">&gt;Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span><br></code></pre></td></tr></table></figure><p>where<code>Address</code> is the position of the node, <code>Data</code> is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output <code>-1</code> instead.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;11111 22222 9<br>&gt;67890 i 00002<br>&gt;00010 a 12345<br>&gt;00003 g -1<br>&gt;12345 D 67890<br>&gt;00002 n 00003<br>&gt;22222 B 23456<br>&gt;11111 L 00001<br>&gt;23456 e 67890<br>&gt;00001 o 00010<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;67890<br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;00001 00002 4<br>&gt;00001 a 10001<br>&gt;10001 s -1<br>&gt;00002 a 10002<br>&gt;10002 t -1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;-1<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  本题因为地址范围小利用静态链表就可以完成操作。</li><li>  步骤一：在定义结构体的时候要加上一个flag用于说明该节点在第一条链表中已经出现过。</li><li>  步骤二：从第一条链表的首个地址出发，遍历一遍链表记录flag=1；然后从第二条链表的收个地址出发，遍历一边链表，判断flag是否等于1；如果是就退出遍历，输出该节点。如果最后遍历完没有发现共同节点，就返回-1.</li><li>  注意节点遍历完的判断条件是next节点是否为-1.</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">char</span> data;<br><span class="hljs-type">int</span> next;<br><span class="hljs-type">bool</span> flag;<br>&#125;vn[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> f,s,n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;f,&amp;s,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)&#123;<br>vn[i].flag=<span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-type">int</span> address,next;<br><span class="hljs-type">char</span> data;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c %d&quot;</span>,&amp;address,&amp;data,&amp;next);<br>vn[address].data=data;<br>vn[address].next=next;<br><br>&#125;<br><span class="hljs-type">int</span> p;<br><span class="hljs-keyword">for</span>(p=f;p!=<span class="hljs-number">-1</span>;p=vn[p].next)&#123;<br>vn[p].flag=<span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(p=s;p!=<span class="hljs-number">-1</span>;p=vn[p].next)&#123;<br><span class="hljs-keyword">if</span>(vn[p].flag==<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,p);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1052-Linked-List-Sorting（链表）（⭐⭐）"><a href="#1052-Linked-List-Sorting（链表）（⭐⭐）" class="headerlink" title="1052 Linked List Sorting（链表）（⭐⭐）"></a><strong>1052 Linked List Sorting</strong>（链表）（⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer <code>key</code> and a <code>Next</code> pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each case, the first line contains a positive <em>N</em> (&lt;105) and an address of the head node, where <em>N</em> is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1.</p><p>  Then <em>N</em> lines follow, each describes a node in the format:</p>  <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Address</span> <span class="hljs-built_in">Key</span> <span class="hljs-built_in">Next</span><br></code></pre></td></tr></table></figure><p>  where <code>Address</code> is the address of the node in memory, <code>Key</code> is an integer in [−105,105], and <code>Next</code> is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, the output format is the same as that of the input, where <em>N</em> is the total number of nodes in the list and all the nodes must be sorted order.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">5 00001<br>11111 100 -1<br>00001 0 22222<br>33333 100000 11111<br>12345 -1 33333<br>22222 1000 12345<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs out">5 12345<br>12345 -1 00001<br>00001 0 11111<br>11111 100 22222<br>22222 1000 33333<br>33333 100000 -1<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  题目意思：对链表排序，然后输出升序。</li><li>  步骤一：同样的我们需要定义一个struct，然后里面需要有一个flag用于判断该节点是否在链表中，因为给的数据中会有一些节点不在链表中，所以我们需要将链表中的那些有效的值排序到数组的前面，然后将有效的值按照data进行排序。</li><li>  注意点：输出的格式需要用到%05d，但是要注意-1要进行特判。</li><li>  当数据里面全部都是无效的时候就需要进行特判处理，输出“0 -1”.</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> address;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> next;<br>    <span class="hljs-type">bool</span> flag;<span class="hljs-comment">//节点是否在链表上</span><br>&#125;node[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a,Node b)</span></span>&#123;<br>    <span class="hljs-comment">//有效的放在前面，然后按照data进行排序</span><br>    <span class="hljs-keyword">if</span>(a.flag==<span class="hljs-literal">false</span>||b.flag==<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-keyword">return</span> a.flag&gt;b.flag;<br>&#125;<br>        <br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> a.data&lt;b.data;<br>    &#125;<br><br><br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)&#123;<br>        node[i].flag=<span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> n,head;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;head);<br>    <span class="hljs-type">int</span> address,data,next;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;address,&amp;data,&amp;next);<br>        node[address].address=address;<br>        node[address].data=data;<br>        node[address].next=next;<br>    &#125;<br>    <span class="hljs-type">int</span> p=head;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-number">-1</span>)&#123;<br>        node[p].flag=<span class="hljs-literal">true</span>;<br>        count++;<br>        p=node[p].next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 -1&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sort</span>(node,node+MAXN,cmp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %05d\n&quot;</span>,count,node[<span class="hljs-number">0</span>].address);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i!=count<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,node[i].address,node[i].data,node[i+<span class="hljs-number">1</span>].address);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>,node[i].address,node[i].data);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表题的模板"><a href="#链表题的模板" class="headerlink" title="链表题的模板"></a>链表题的模板</h2><ul><li><p>首先是struct结构体的定义：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> address;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> next;<br>    XXX xxx;<span class="hljs-comment">//该位是记录该链表的特点，例如可以用来判断节点是否是在链表中，注意要初始化。</span><br>&#125;node[MAXN];<br></code></pre></td></tr></table></figure></li><li><p>对特殊变量的初始化：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)&#123;<br>       node[i].flag=<span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>对特殊变量的赋值：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(p!=<span class="hljs-number">-1</span>)&#123;<br>       node[p].flag=<span class="hljs-literal">true</span>;<br>       count++;<br>       p=node[p].next;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>疯狂的刷题——PAT备考进行时（六）</title>
    <link href="/2023/09/04/%E7%96%AF%E7%8B%82%E7%9A%84%E5%88%B7%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2023/09/04/%E7%96%AF%E7%8B%82%E7%9A%84%E5%88%B7%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="打表技巧"><a href="#打表技巧" class="headerlink" title="打表技巧"></a>打表技巧</h1><h2 id="1093-Count-PAT’s（空间换时间）（⭐⭐）"><a href="#1093-Count-PAT’s（空间换时间）（⭐⭐）" class="headerlink" title="1093 Count PAT’s（空间换时间）（⭐⭐）"></a><strong>1093 Count PAT’s</strong>（空间换时间）（⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  The string <code>APPAPT</code> contains two <code>PAT</code>‘s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.</p><p>  Now given any string, you are supposed to tell the number of <code>PAT</code>‘s contained in the string.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only <code>P</code>, <code>A</code>, or <code>T</code>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, print in one line the number of <code>PAT</code>‘s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">APPAPT<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">2<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  题目要求我们统计其中按照顺序排列的PAT有几个，</li><li>  通过分析我们如果直接用暴力会超时，那么就需要利用空间换时间，利用数组记录每一个A的左边有几个P，右边有几个T，然后把P和T的数相乘得到每个位子上的A有几个组合，然后把每个A上的数据相加。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD=<span class="hljs-number">1000000007</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>string str;<br>cin&gt;&gt; str;<br><span class="hljs-type">int</span> len=str.<span class="hljs-built_in">length</span>(),ans=<span class="hljs-number">0</span>,countp=<span class="hljs-number">0</span>,countt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br><span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;T&#x27;</span>)&#123;<br>countt++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br><span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;P&#x27;</span>)countp++;<br><span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;T&#x27;</span>)countt--;<br><span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;A&#x27;</span>)ans=(ans+(countt*countp)%MOD)%MOD;<br><br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>给出的代码利用countt，countp记录该位子上的T和P有几个然后相乘。</p><h2 id="1101-Quick-Sort（打表，快速排序）（⭐⭐）"><a href="#1101-Quick-Sort（打表，快速排序）（⭐⭐）" class="headerlink" title="1101 Quick Sort（打表，快速排序）（⭐⭐）"></a><strong>1101 Quick Sort</strong>（打表，快速排序）（⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  There is a classical process named <strong>partition</strong> in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given <em>N</em> distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?</p><p>  For example, given <em>N</em>=5 and the numbers 1, 3, 2, 4, and 5. We have:</p><ul><li>  1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;</li><li>  3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;</li><li>  2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;</li><li>  and for the similar reason, 4 and 5 could also be the pivot.</li></ul><p>  Hence in total there are 3 pivot candidates.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤105). Then the next line contains <em>N</em> distinct positive integers no larger than 109. The numbers in a line are separated by spaces.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">5<br>1 3 2 4 5<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">3<br>1 4 5<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  题目要求我们找出所有的符合作为主元的元素（主元就是左边的所有小于右边所有）。</li><li>  和上面一题相似，我们可以用数组记录下该位子左边最大的数和右边最小的数，然后进行比较，如果符合就加入结果中。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-type">int</span> num[n];<br><span class="hljs-type">int</span> left[n];<br><span class="hljs-type">int</span> right[n];<br><span class="hljs-type">int</span> ans[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num[i]);<br>&#125;<br>left[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>left[i]=<span class="hljs-built_in">max</span>(left[i<span class="hljs-number">-1</span>],num[i<span class="hljs-number">-1</span>]);<br>&#125;<br>right[n<span class="hljs-number">-1</span>]=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>right[i]=<span class="hljs-built_in">min</span>(right[i+<span class="hljs-number">1</span>],num[i+<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(num[i]&gt;left[i]&amp;&amp;num[i]&lt;right[i])&#123;<br>ans[count++]=num[i];<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,count);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans[i]);<br><span class="hljs-keyword">if</span>(i!=count<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>  第一位最大值为0，最后一位最小值为INF。</li></ul><hr><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="1062-Talent-and-Virtue（重写sort-cmp）-⭐⭐⭐"><a href="#1062-Talent-and-Virtue（重写sort-cmp）-⭐⭐⭐" class="headerlink" title="1062 Talent and Virtue（重写sort-cmp）(⭐⭐⭐)"></a><strong>1062 Talent and Virtue</strong>（重写sort-cmp）(⭐⭐⭐)</h2><p><strong>题目：</strong></p><blockquote><p>  About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people’s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a “sage（圣人）”; being less excellent but with one’s virtue outweighs talent can be called a “nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man is better than a “small man（小人）” who prefers talent than virtue.</p><p>  Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang’s theory.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. Each case first gives 3 positive integers in a line: <em>N</em> (≤105), the total number of people to be ranked; <em>L</em> (≥60), the lower bound of the qualified grades – that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and <em>H</em> (&lt;100), the higher line of qualification – that is, those with both grades not below this line are considered as the “sages”, and will be ranked in non-increasing order according to their total grades. Those with talent grades below <em>H</em> but virtue grades not are considered as the “noblemen”, and are also ranked in non-increasing order according to their total grades, but they are listed after the “sages”. Those with both grades below <em>H</em>, but with virtue not lower than talent are considered as the “fool men”. They are ranked in the same way but after the “noblemen”. The rest of people whose grades both pass the <em>L</em> line are ranked after the “fool men”.</p><p>  Then <em>N</em> lines follow, each gives the information of a person in the format:</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ID_Number Virtue_Grade Talent_Grade</span><br></code></pre></td></tr></table></figure><p>  where <code>ID_Number</code> is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  The first line of output must give <em>M</em> (≤<em>N</em>), the total number of people that are actually ranked. Then <em>M</em> lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID’s.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs in">14 60 80<br>10000001 64 90<br>10000002 90 60<br>10000011 85 80<br>10000003 85 80<br>10000004 80 85<br>10000005 82 77<br>10000006 83 76<br>10000007 90 78<br>10000008 75 79<br>10000009 59 90<br>10000010 88 45<br>10000012 80 100<br>10000013 90 99<br>10000014 66 60<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs out">12<br>10000013 90 99<br>10000012 80 100<br>10000003 85 80<br>10000011 85 80<br>10000004 80 85<br>10000007 90 78<br>10000006 83 76<br>10000005 82 77<br>10000002 90 60<br>10000014 66 60<br>10000008 75 79<br>10000001 64 90<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  要求进行对一列人的排序，根据德才的分数。</li><li>  如果要排序我们可以自然而然的想到用sort函数，本题的重点也就是对sort函数进行重写。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">1、给出一行人来进行德才排序，根据她们的成绩</span><br><span class="hljs-comment">进行降序 </span><br><span class="hljs-comment">2、 sages：智商情商都高于 H；</span><br><span class="hljs-comment"> noblemen：情商高H智商低于H。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> name;<br><span class="hljs-type">int</span> v;<br><span class="hljs-type">int</span> t;<br><span class="hljs-type">int</span> sum;<br><span class="hljs-type">int</span> flag;<br>&#125;; <br>vector&lt;Node&gt; vn;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a,Node b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.flag!=b.flag)&#123;<br><span class="hljs-keyword">return</span> a.flag&lt;b.flag;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.sum!=b.sum)&#123;<br><span class="hljs-keyword">return</span> a.sum&gt;b.sum;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.v!=b.v)&#123;<br><span class="hljs-keyword">return</span> a.v&gt;b.v;<br><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.name&lt;b.name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n,l,h;<br><span class="hljs-type">int</span> zero=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;l,&amp;h);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>Node node;<br>node.flag=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;node.name,&amp;node.v,&amp;node.t);<br>node.sum=node.v+node.t;<br>vn.<span class="hljs-built_in">push_back</span>(node);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(vn[i].v&gt;=l&amp;&amp;vn[i].t&gt;=l)&#123;<br><span class="hljs-keyword">if</span>(vn[i].v&gt;=h&amp;&amp;vn[i].t&gt;=h)&#123;<br>vn[i].flag=<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vn[i].v&gt;=h&amp;&amp;vn[i].t&lt;h)&#123;<br>vn[i].flag=<span class="hljs-number">2</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vn[i].v&gt;=vn[i].t)&#123;<br>vn[i].flag=<span class="hljs-number">3</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>vn[i].flag=<span class="hljs-number">4</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>zero++;<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(vn.<span class="hljs-built_in">begin</span>(),vn.<span class="hljs-built_in">end</span>(),cmp);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-zero);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=zero;i&lt;n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,vn[i].name,vn[i].v,vn[i].t);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>  注意else if语句的书写。</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1172-1175套题——PAT备考进行时（五）</title>
    <link href="/2023/09/03/1172-1175%E5%A5%97%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2023/09/03/1172-1175%E5%A5%97%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1172-Panda-and-PP-Milk"><a href="#1172-Panda-and-PP-Milk" class="headerlink" title="1172 Panda and PP Milk"></a><strong>1172 Panda and PP Milk</strong></h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论——PAT备考进行时（四）</title>
    <link href="/2023/08/26/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/08/26/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><p>利用邻接矩阵或者邻接表进行实现。</p><p>对于无向图来说，邻接矩阵是对称矩阵，矩阵比较好写，但是如果定点数太大，会超出内存限制，所以一般只用于1000以下的题目。</p><p>在C++中可以利用vector实现邻接表，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; Adj[N];<br></code></pre></td></tr></table></figure><p>Adj[]数组是一个vector&lt;int&gt;数组，数组的下标代表几号顶点，vector可以看成一个链表。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li>  利用邻接表实现：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;  Adj[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>    vis[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Adj[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> v=Adj[u][i];<br>        <span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-built_in">DFS</span>(v,depth+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>广度优先搜索，每次以外扩的方式访问顶点。</p><ul><li>  用邻接矩阵实现BFS</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,G[MAXN][MAXN];<br><span class="hljs-type">bool</span> inq[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<span class="hljs-comment">//u表示所在的连通块</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    inq[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br>            <span class="hljs-keyword">if</span>(inq[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br>                q.<span class="hljs-built_in">push</span>(v);<br>                inq[v]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFSTrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br><span class="hljs-keyword">if</span>(inq[u]==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-built_in">BFS</span>(u);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  用邻接表实现BFS</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; Adj[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> inq[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    inq[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Adj[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> v=Adj[u][i];<br>            q.<span class="hljs-built_in">push</span>(v);<br>            inq[v]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1034-Head-of-a-Gang（图的深度遍历，STL）（⭐⭐⭐⭐）"><a href="#1034-Head-of-a-Gang（图的深度遍历，STL）（⭐⭐⭐⭐）" class="headerlink" title="1034 Head of a Gang（图的深度遍历，STL）（⭐⭐⭐⭐）"></a><strong>1034 Head of a Gang</strong>（图的深度遍历，STL）（⭐⭐⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between <em>A</em> and <em>B</em>, we say that <em>A</em> and <em>B</em> is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold <em>K</em>. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive numbers <em>N</em> and <em>K</em> (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then <em>N</em> lines follow, each in the following format:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&gt;<span class="hljs-symbol">Name1</span> <span class="hljs-symbol">Name2</span> Time<br></code></pre></td></tr></table></figure><p>where <code>Name1</code> and <code>Name2</code> are the names of people at the two ends of the call, and <code>Time</code> is the length of the call. A name is a string of three capital letters chosen from <code>A</code>-<code>Z</code>. A time length is a positive integer which is no more than 1000 minutes.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;8 59<br>&gt;AAA BBB 10<br>&gt;BBB AAA 20<br>&gt;AAA CCC 40<br>&gt;DDD EEE 5<br>&gt;EEE DDD 70<br>&gt;FFF GGG 30<br>&gt;GGG HHH 20<br>&gt;HHH FFF 10<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;2<br>&gt;AAA 3<br>&gt;GGG 3<br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;8 70<br>&gt;AAA BBB 10<br>&gt;BBB AAA 20<br>&gt;AAA CCC 40<br>&gt;DDD EEE 5<br>&gt;EEE DDD 70<br>&gt;FFF GGG 30<br>&gt;GGG HHH 20<br>&gt;HHH FFF 10<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;0<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  本题作为压轴题，但其实并不是很难，只要掌握了图的深度搜索遍历就可以非常轻松的做出来。</li><li>  首先题目要求我们最终输出的是犯罪团伙的头目和人数，那么我们先考虑一下要怎么样去输出，是不是可以用<code>map&lt;string,int&gt;</code>保存头目和人数信息。这题非常明显的就是图的遍历，但是如果没有定位是图的遍历，那就没话说了，自己先去学习深搜。</li><li>  如果定位了图的遍历，那就可以用图的深度搜索的代码模板了，只不过要在遍历单连通图的时候通过比较记录下谁是头目（用点权进行比较）和人数以及总权数（要&gt;k）才是犯罪团伙，输入到gang团伙map中，等待最后的输出。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">数据存储准备：</span><br><span class="hljs-comment">用于将邻接矩阵的编号和名字对应，当然需要通过名字查找编号。 </span><br><span class="hljs-comment">map&lt;int,string&gt; intToString;</span><br><span class="hljs-comment">map&lt;string,int&gt; stringToInt;</span><br><span class="hljs-comment">记录头目和人数：</span><br><span class="hljs-comment">map&lt;string,int&gt;  gang;</span><br><span class="hljs-comment">一个记录点权值的数组：</span><br><span class="hljs-comment">int weight[maxn]=&#123;0&#125;; </span><br><span class="hljs-comment">一个记录边权值的矩阵:</span><br><span class="hljs-comment">int G[maxn][maxn]=&#123;0&#125;;</span><br><span class="hljs-comment">一个用于遍历图的判断数组：</span><br><span class="hljs-comment">bool vis[max]=&#123;false&#125;;</span><br><span class="hljs-comment">int k;下限</span><br><span class="hljs-comment">int peopleNum;记录人数，在输入的时候进行记录。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">思路：主要就是先将输入的东西先进行人名和编号对应放到G矩阵中，</span><br><span class="hljs-comment">人名对应的时候要同时更新编号和人名对应。</span><br><span class="hljs-comment"> 一共有三个函数：</span><br><span class="hljs-comment"> 1、输入：屏幕中的一系列人名的对应关系，记录到两个map中，</span><br><span class="hljs-comment"> 并且要将边权值记录到 G矩阵中,记录点权值。 </span><br><span class="hljs-comment"> 2、遍历整个图，获取每个连通图的信息，如果vis为false就是未被访问则进入dfs</span><br><span class="hljs-comment"> 遍历，寻找单联通区域的头目、人数和总边权，和k进行比较。</span><br><span class="hljs-comment"> 3、遍历单连通区域，记录 头目、人数、总边权、weight数组 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br>map&lt;<span class="hljs-type">int</span>,string&gt; intToString;<br>map&lt;string,<span class="hljs-type">int</span>&gt; stringToInt;<br>map&lt;string,<span class="hljs-type">int</span>&gt;  gang;<br><span class="hljs-type">int</span> weight[maxn]=&#123;<span class="hljs-number">0</span>&#125;; <br> <span class="hljs-type">int</span> G[maxn][maxn]=&#123;<span class="hljs-number">0</span>&#125;;<br> <span class="hljs-type">bool</span> vis[maxn]=&#123;<span class="hljs-literal">false</span>&#125;;<br> <span class="hljs-type">int</span> k;<br> <span class="hljs-type">int</span> peopleNum;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> nowVisit,<span class="hljs-type">int</span>&amp; head,<span class="hljs-type">int</span>&amp; numMember,<span class="hljs-type">int</span>&amp; totalValue)</span></span>&#123;<br> numMember++;<br> vis[nowVisit]=<span class="hljs-literal">true</span>;<br> <span class="hljs-keyword">if</span>(weight[nowVisit]&gt;weight[head])&#123;<br> head=nowVisit;<br> <br> &#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;peopleNum;i++)&#123;<br><span class="hljs-keyword">if</span>(G[nowVisit][i]&gt;<span class="hljs-number">0</span>)&#123;<br>totalValue+=G[nowVisit][i];<br>G[nowVisit][i]=G[i][nowVisit]=<span class="hljs-number">0</span>;<span class="hljs-comment">//删除已经统计过的边。</span><br><span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-built_in">DFS</span>(i,head,numMember,totalValue);<br>&#125;<br>        &#125;<br>    &#125;<br>  &#125;<br> <br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFSTrave</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;peopleNum;i++)&#123;<br> <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-literal">false</span>)&#123;<br> <span class="hljs-type">int</span> head=i,numMember=<span class="hljs-number">0</span>,totalValue=<span class="hljs-number">0</span>;<br> <span class="hljs-built_in">DFS</span>(i,head,numMember,totalValue);<br><span class="hljs-keyword">if</span>(numMember&gt;<span class="hljs-number">2</span> &amp;&amp; totalValue&gt;k)&#123;<br>gang[intToString[head]]=numMember;<br>&#125;<br> &#125;<br> &#125;<br> &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(string str)</span></span>&#123;<br> <span class="hljs-keyword">if</span>(stringToInt.<span class="hljs-built_in">find</span>(str)!=stringToInt.<span class="hljs-built_in">end</span>())&#123;<br> <span class="hljs-keyword">return</span> stringToInt[str];<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br> stringToInt[str] =peopleNum;<br> intToString[peopleNum]=str; <br> <span class="hljs-keyword">return</span> peopleNum++;<br> &#125; <br> &#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n&gt;&gt;k;<br>string s1,s2;<br><span class="hljs-type">int</span> temp;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;temp;<br><span class="hljs-type">int</span> l1=<span class="hljs-built_in">change</span>(s1);<br><span class="hljs-type">int</span> l2=<span class="hljs-built_in">change</span>(s2);<br>weight[l1]+=temp;<br>weight[l2]+=temp;<br>G[l1][l2]+=temp;<br>G[l2][l1]+=temp;<br><br>&#125;<br><br><span class="hljs-built_in">DFSTrave</span>();<br>cout&lt;&lt;gang.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>map&lt;string,<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it=gang.<span class="hljs-built_in">begin</span>();it!=gang.<span class="hljs-built_in">end</span>();it++)&#123;<br>cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>  需要注意的是在进行单连通遍历的时候记录totalValue时要及时对已经记录过的边权进行删除，不然会重复统计。</li><li>  最后map输出的时候利用迭代器。</li></ul><h3 id="思考：如何利用邻接表实现。"><a href="#思考：如何利用邻接表实现。" class="headerlink" title="思考：如何利用邻接表实现。"></a>思考：如何利用邻接表实现。</h3><p><strong>代码：</strong></p><h2 id="1076-Forwards-on-Weibo（图的BFS遍历）（⭐⭐⭐）"><a href="#1076-Forwards-on-Weibo（图的BFS遍历）（⭐⭐⭐）" class="headerlink" title="1076 Forwards on Weibo（图的BFS遍历）（⭐⭐⭐）"></a><strong>1076 Forwards on Weibo</strong>（图的BFS遍历）（⭐⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only <em>L</em> levels of indirect followers are counted.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers: <em>N</em> (≤1000), the number of users; and <em>L</em> (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each in the format:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;M<span class="hljs-selector-attr">[i]</span> user_list<span class="hljs-selector-attr">[i]</span><br></code></pre></td></tr></table></figure><p>where <code>M[i]</code> (≤100) is the total number of people that <code>user[i]</code> follows; and <code>user_list[i]</code> is a list of the <code>M[i]</code> users that followed by <code>user[i]</code>. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.</p><p>Then finally a positive <em>K</em> is given, followed by <em>K</em> <code>UserID</code>‘s for query.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>UserID</code>, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only <em>L</em> levels of indirect followers are counted.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;7 3<br>&gt;3 2 3 4<br>&gt;0<br>&gt;2 5 6<br>&gt;2 3 1<br>&gt;2 3 4<br>&gt;1 4<br>&gt;1 5<br>&gt;2 2 6<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;4<br>&gt;5<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  本题主要难点在于读懂题目，说实话我觉得现在我最大的问题就是不会读题目，题目中要求我们在给定N个用户和L层找到一个微博用户发送的信息最多可以被转发多少次。</li><li>  解题的关键是在于建立有向图，那么代码中我利用的是邻接表记录，注意的是如果一个图中有权值，并且需要用到邻接表进行记录，那么邻接表中可以利用定义一个struct记录节点的编号和权重。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1010</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">数据存储：</span><br><span class="hljs-comment">邻接表，记录图 </span><br><span class="hljs-comment">vector&lt;int&gt; Adj[MAXN];</span><br><span class="hljs-comment">层数：</span><br><span class="hljs-comment">int lever;</span><br><span class="hljs-comment">最大转发数：</span><br><span class="hljs-comment">int count;</span><br><span class="hljs-comment">查询列表：</span><br><span class="hljs-comment">vector&lt;int&gt; ans; </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">解题步骤：</span><br><span class="hljs-comment">1、建立图，注意箭头指向是从被关注者到关注者。</span><br><span class="hljs-comment">2、输入查询的节点，从该节点开始寻找，记录层数</span><br><span class="hljs-comment">和转发量。返回转发量，存入查询列表中。 </span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> layer;<br>&#125;;<br>vector&lt;Node&gt; Adj[MAXN];<br><span class="hljs-type">bool</span> inq[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> L)</span></span>&#123;<br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>queue&lt;Node&gt; q;<br>Node start;<br>start.id=u;<br>start.layer=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(start);<br>inq[start.id]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>Node node=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> s=node.id;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Adj[s].<span class="hljs-built_in">size</span>();i++)&#123;<br>Node next=Adj[s][i];<br>next.layer=node.layer+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(inq[next.id]==<span class="hljs-literal">false</span>&amp;&amp;next.layer&lt;=L)&#123;<br>q.<span class="hljs-built_in">push</span>(next);<br>inq[next.id]=<span class="hljs-literal">true</span>;<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> N,L;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;N,&amp;L);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br><span class="hljs-type">int</span> nums;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums;j++)&#123;<br><span class="hljs-type">int</span> num;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>Node newNode;<br>newNode.id=i;<br>newNode.layer=<span class="hljs-number">0</span>;<br>Adj[num].<span class="hljs-built_in">push_back</span>(newNode);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> searchNum;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;searchNum);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;searchNum;i++)&#123;<br><span class="hljs-built_in">memset</span>(inq,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(inq));<span class="hljs-comment">//为何要这句？？？ </span><br><span class="hljs-type">int</span> start;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;start);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">BFS</span>(start,L));<br>&#125;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>  因为每次进入BFS之前inq数组可能已经有上一次遍历的信息所以可以在进入BFS之前先对inq进行一个重置。</li></ul><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h2 id="1003-Emergency（Dijkstra）（⭐⭐⭐⭐）"><a href="#1003-Emergency（Dijkstra）（⭐⭐⭐⭐）" class="headerlink" title="1003 Emergency（Dijkstra）（⭐⭐⭐⭐）"></a><strong>1003 Emergency</strong>（Dijkstra）（⭐⭐⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to <em>N</em>−1), <em>M</em> - the number of roads, <em>C</em>1 and <em>C</em>2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers <em>c</em>1, <em>c</em>2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <em>C</em>1 to <em>C</em>2.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, print in one line two numbers: the number of different shortest paths between <em>C</em>1 and <em>C</em>2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs in">5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">2 4<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  本题我个人感觉难度还是比较大的，首先是题目的理解，主要是要把题目中的城市中的救援队抽象成点权，把路抽象成边权，所以我们应该是在找最短路的同时将点权之和进行记录，也就是更新每个点的点权值之和，具体的内容就是在Dijkstra算法中修改，其实这么分析下来就不难了，最后输出的时候是输出条数而不是权值，这是一个小陷阱，以后得认真读题。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">数据存储：</span><br><span class="hljs-comment">用于记录城市的数量n,路的条数m,开始的城市c1</span><br><span class="hljs-comment">结束的城市c2.</span><br><span class="hljs-comment">int n,m,c1,c2;</span><br><span class="hljs-comment">记录图信息，</span><br><span class="hljs-comment">int G[MAXN][MAXN];</span><br><span class="hljs-comment">记录点权：</span><br><span class="hljs-comment">int weigh[MAXN]; </span><br><span class="hljs-comment">记录每点到起始点的边权值。</span><br><span class="hljs-comment">int d[MAXN];</span><br><span class="hljs-comment">记录点权之和</span><br><span class="hljs-comment">int w[MAXN]; </span><br><span class="hljs-comment">记录是否访问</span><br><span class="hljs-comment">bool vis[MAXN]=&#123;false&#125;; </span><br><span class="hljs-comment">记录最短路径的条数 </span><br><span class="hljs-comment">int num[MAXN]; </span><br><span class="hljs-comment">解题思路：</span><br><span class="hljs-comment">1、处理图利用邻接矩阵存储。weight记录点权 </span><br><span class="hljs-comment">2、利用Dijkstra算法计算d数组、在更新d数组</span><br><span class="hljs-comment">的时候更新w数组、num数组、.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> n,m,c1,c2;<br><span class="hljs-type">int</span> G[MAXN][MAXN];<br><span class="hljs-type">int</span> weight[MAXN]; <br><span class="hljs-type">int</span> d[MAXN];<br><span class="hljs-type">int</span> w[MAXN]; <br><span class="hljs-type">int</span> num[MAXN];<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br><span class="hljs-built_in">fill</span>(w,w+MAXN,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">fill</span>(num,num+MAXN,<span class="hljs-number">0</span>);<br>d[s]=<span class="hljs-number">0</span>;<br>w[s]=weight[s];<br>num[s]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">-1</span>,MIN=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br><span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;<br>u=j;<br>MIN=d[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(u==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ;<br>vis[u]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br><span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br><span class="hljs-keyword">if</span>(d[u]+G[u][v]&lt;d[v])&#123;<br>d[v]=d[u]+G[u][v];<br>w[v]=w[u]+weight[v];<br>num[v]=num[u];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+G[u][v]==d[v])&#123;<br><span class="hljs-keyword">if</span>(w[u]+weight[v]&gt;w[v])&#123;<br>w[v]=w[u]+weight[v];<br><br>&#125;<br>num[v]+=num[u];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;m,&amp;c1,&amp;c2);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;weight[i]);<br>&#125;<br><span class="hljs-built_in">fill</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>G[a][b]=c;<br>G[b][a]=c;<br>&#125;<br><span class="hljs-built_in">Dijkstra</span>(c1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,num[c2],w[c2]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意点</strong>：</p><ul><li>  对二维数组进行fill()操作的时候需要<code>fill(G[0],G[0]+MAXN*MAXN,INF);</code>。</li><li>  记住Dijkstra算法可以同时维护多个标尺。</li></ul><h2 id="利用DFS改进1003"><a href="#利用DFS改进1003" class="headerlink" title="利用DFS改进1003"></a>利用DFS改进1003</h2><p>上面的题目只是给出了简单的计算权值的方法，要是稍微复杂一点可能就无法得到正确的结果，因为不一定满足最优子结构。所以我们可以利用DFS加持。</p><p>上面我们的思路是用pre数组记录下最短路，这需要在进行Dijkstra算法的时候进行严密的逻辑。其实有一个更加简单的方式：<strong>先在Dijkstra算法中记录下所有最短路经（只考虑距离），然后从这些最短路径中选出一条第二标尺最优的路径。</strong></p><p>①使用Dijkstra算法记录下所有的最短路径。</p><p>之前我们是使用pre数组进行记录，但是记录下所有路径，使用<code>vector&lt;int&gt; pre[MAXN]</code>，（如果需要查询某个顶点u是否在顶点v的前驱中，可以使用<code>set&lt;int&gt;</code>，此时使用<code>pre[v].count()</code>查询比较方便）</p><ul><li>  Pre数组的求解代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br>    d[s]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">-1</span>;MIN=INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;<br>                u=j;<br>                MIN=d[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(u==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ;<br>        vis[u]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br><span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br>                <span class="hljs-keyword">if</span>(d[u]+G[u][v]&lt;d[v])&#123;<br>                    d[v]=d[u]+G[u][v];<br>                    pre[v].<span class="hljs-built_in">clear</span>();<br>                    pre[v].<span class="hljs-built_in">push_back</span>(u);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+G[u][v]==d[v])&#123;<br>                    pre[v].<span class="hljs-built_in">push_back</span>(u);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②遍历所有最短路径，找出一条第二标尺最优的路径</p><p>现在我们已经pre数组，记录了每个节点中所有的最短路径的前驱节点，在每个pre[]中记录的是所有前前驱，故需要用到DFS进行求解。</p><p>必须要有的是：</p><ul><li>  作为全局变量的第二标尺最优值optValue。</li><li>  记录最优路径的数组path（使用vector记录）</li><li>  临时记录DFS遍历到叶子节点的路径tempPath（使用vector数组存储）</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> optValue;<br>vector&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; path,tempPath;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">if</span>(v==st)&#123;<br>        tempPath.<span class="hljs-built_in">push_back</span>(v);<br>        <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">if</span>(value优于optValue)&#123;<br>            optValue=value;<br>            path=tempPath;<br>        &#125;<br>        tempPath.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    tempPath.<span class="hljs-built_in">push_back</span>(v);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pre[v].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-built_in">DFS</span>(pre[v][i]);<br>    &#125;<br>    tempPath.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>  题目中的第二标尺比较简单的情况下使用第一种题解比较方便。</li></ul><h2 id="1030-Travel-Plan（Dijkstra）（⭐⭐⭐⭐）"><a href="#1030-Travel-Plan（Dijkstra）（⭐⭐⭐⭐）" class="headerlink" title="1030 Travel Plan（Dijkstra）（⭐⭐⭐⭐）"></a><strong>1030 Travel Plan</strong>（Dijkstra）（⭐⭐⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</p><h3 id="Input-Specification-3"><a href="#Input-Specification-3" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. Each case starts with a line containing 4 positive integers <em>N</em>, <em>M</em>, <em>S</em>, and <em>D</em>, where <em>N</em> (≤500) is the number of cities (and hence the cities are numbered from 0 to <em>N</em>−1); <em>M</em> is the number of highways; <em>S</em> and <em>D</em> are the starting and the destination cities, respectively. Then <em>M</em> lines follow, each provides the information of a highway, in the format:</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">City1 City2 <span class="hljs-built_in">Distance</span> Cost<br></code></pre></td></tr></table></figure><p>  where the numbers are all integers no more than 500, and are separated by a space.</p><h3 id="Output-Specification-3"><a href="#Output-Specification-3" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">4 5 0 3<br>0 1 1 20<br>1 3 2 30<br>0 3 4 10<br>0 2 2 20<br>2 3 1 20<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">0 2 3 3 40<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><p>本题就是一个规规矩矩的利用Dijkstra算法进行求解，如果不熟练Dijkstra，没有办法在10分钟内写出完整的DK算法的话本题具有一定难度，Dijksta算法的模板较为单一，同时如果遇到多个标尺可以使用DFS进行求解，总之如果不懂，就背下来。</p><p><strong>代码：</strong>（利用DFS求解）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">数据存储：</span><br><span class="hljs-comment">用于存储城市、路、起点和重点。</span><br><span class="hljs-comment">int n,m,s,e;</span><br><span class="hljs-comment">用于存储图结构</span><br><span class="hljs-comment">int G[MAXN][MAXN];</span><br><span class="hljs-comment">用于记录最优路径节点的前驱。</span><br><span class="hljs-comment">vector&lt;int&gt; pre;</span><br><span class="hljs-comment">用于存储 </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> m,n,st,e;<br><span class="hljs-type">int</span> G[MAXN][MAXN],cost[MAXN][MAXN];<br><span class="hljs-type">int</span> d[MAXN];<br><br><span class="hljs-type">int</span> minCost=INF;<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; path,tempPath;<br>vector&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br>d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">-1</span>,MIN=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br><span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;<br>MIN=d[j];<br>u=j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(u==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;<br>vis[u]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br><span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br><span class="hljs-keyword">if</span>(d[u]+G[u][v]&lt;d[v])&#123;<br>d[v]=d[u]+G[u][v];<br>pre[v].<span class="hljs-built_in">clear</span>();<br>pre[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+G[u][v]==d[v])&#123;<br>pre[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">if</span>(v==st)&#123;<br>tempPath.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-type">int</span> tempCost=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=tempPath.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-type">int</span> id=tempPath[i],idNext=tempPath[i<span class="hljs-number">-1</span>];<br>tempCost+=cost[id][idNext];<br>&#125;<br><span class="hljs-keyword">if</span>(tempCost&lt;minCost)&#123;<br>minCost=tempCost;<br>path=tempPath;<br>&#125;<br>tempPath.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>tempPath.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pre[v].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-built_in">DFS</span>(pre[v][i]);<br>&#125;<br>tempPath.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;m,&amp;st,&amp;e);<br><span class="hljs-type">int</span> u,v;<br><span class="hljs-built_in">fill</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-built_in">fill</span>(cost[<span class="hljs-number">0</span>],cost[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;G[u][v],&amp;cost[u][v]);<br>G[v][u]=G[u][v];<br>cost[v][u]=cost[u][v];<br>&#125;<br><span class="hljs-built_in">Dijkstra</span>(st);<br><span class="hljs-built_in">DFS</span>(e);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,path[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,d[e],minCost);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="1018-Public-Bike-Management（Dijkstra）-⭐⭐⭐⭐⭐"><a href="#1018-Public-Bike-Management（Dijkstra）-⭐⭐⭐⭐⭐" class="headerlink" title="1018 Public Bike Management（Dijkstra）(⭐⭐⭐⭐⭐)"></a><strong>1018 Public Bike Management</strong>（Dijkstra）(⭐⭐⭐⭐⭐)</h2><p><strong>题目：（原题看官网）</strong></p><blockquote><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">10 3 3 5<br>6 7 0<br>0 1 1<br>0 2 1<br>0 3 3<br>1 3 1<br>2 3 1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">3 0-&gt;2-&gt;3 0<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  利用Dijkstra算法加上DFS进行求解会方便一些。</li><li>  首先利用Dijkstra算法先把pre数组和最短路进行求解，然后利用</li></ul><p><strong>代码：</strong>(不是满分·)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><br><span class="hljs-type">int</span> G[MAXN][MAXN];<br><span class="hljs-type">int</span> d[MAXN];<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-type">int</span> weight[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; path,tempPath;<br><br><span class="hljs-type">int</span> c_max,n,sp,m;<br><span class="hljs-type">int</span> minNeed=INF,minRemain=INF;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br>d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">-1</span>,min=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br><span class="hljs-keyword">if</span>(d[j]&lt;min&amp;&amp;vis[j]==<span class="hljs-literal">false</span>)&#123;<br>min=d[j];<br>u=j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(u==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ;<br>vis[u]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;=n;v++)&#123;<br><span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br><span class="hljs-keyword">if</span>(d[u]+G[u][v]&lt;d[v])&#123;<br>d[v]=d[u]+G[u][v];<br>pre[v].<span class="hljs-built_in">clear</span>();<br>pre[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+G[u][v]==d[v])&#123;<br>pre[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">if</span>(v==<span class="hljs-number">0</span>)&#123;<br>tempPath.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-type">int</span> need=<span class="hljs-number">0</span>,remain=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=tempPath.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-type">int</span> id=tempPath[i];<br><span class="hljs-keyword">if</span>(weight[id]&gt;<span class="hljs-number">0</span>)&#123;<br>remain+=weight[id];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(remain&gt;<span class="hljs-built_in">abs</span>(weight[id]))&#123;<br>remain-=<span class="hljs-built_in">abs</span>(weight[id]);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>need+=(<span class="hljs-built_in">abs</span>(weight[i])-remain);<br>remain=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(need&lt;minNeed)&#123;<br>minNeed=need;<br>minRemain=remain;<br>path=tempPath; <br>&#125; <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(need==minNeed&amp;&amp;remain&lt;minRemain)&#123;<br>minRemain=remain;<br>path=tempPath;<br>&#125;<br>tempPath.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>tempPath.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pre[v].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-built_in">DFS</span>(pre[v][i]);<br>&#125;<br>tempPath.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;c_max,&amp;n,&amp;sp,&amp;m);<br><span class="hljs-type">int</span> u,v;<br><span class="hljs-built_in">fill</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;weight[i]);<br>weight[i]-=c_max/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;G[u][v]);<br>G[v][u]=G[u][v]; <br>&#125;<br><span class="hljs-built_in">Dijkstra</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">DFS</span>(sp);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,minNeed);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,path[i]);<br><span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,minRemain);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Bellman-ford算法"><a href="#Bellman-ford算法" class="headerlink" title="Bellman-ford算法"></a>Bellman-ford算法</h2><p>Dijkstra算法可以很好的解决无负权的最短路问题，但是对于有负权边，就需要使用Bellman算法。</p><p>Bellman算法需要设置一个数组d用来记录源点到达各个顶点的最短距离。并且将Bellman算法返回一个bool值，如果存在从源点可达的负环，那么函数将返回false。松弛操作不超过V-1次。</p><p><strong>代码：（利用邻接表实现）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> v,dis;<br>&#125;<br>vector&lt;Node&gt; Adj[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> d[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Bellman</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(d,d+MAXN,INf);<br>    d[s]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Adj[u].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> v=Adj[u][j].v;<br>                <span class="hljs-type">int</span> dis=Adj[u][j].dis;<br>                <span class="hljs-keyword">if</span>(d[u]+dis&lt;d[v])&#123;<br>                    d[v]=d[u]+dis;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Adj[u].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-type">int</span> v=Adj[u][j].v;<br>            <span class="hljs-type">int</span> dis=Adj[u][j].dis;<br>            <span class="hljs-keyword">if</span>(d[u]+dis&lt;d[v])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用Bellman-Ford编写A1003"><a href="#利用Bellman-Ford编写A1003" class="headerlink" title="利用Bellman-Ford编写A1003"></a>利用Bellman-Ford编写A1003</h2><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> v,dis;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _v,<span class="hljs-type">int</span> _dis) :<span class="hljs-built_in">v</span>(_v),<span class="hljs-built_in">dis</span>(_dis)&#123;&#125;<br>&#125;<br><span class="hljs-type">int</span> n,m,c1,c2;<br>vector&lt;Node&gt; Adj[MAXN];<br><span class="hljs-type">int</span> weight[MAXN]; <br><span class="hljs-type">int</span> d[MAXN];<br><span class="hljs-type">int</span> w[MAXN]; <br><span class="hljs-type">int</span> num[MAXN];<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;; <br>set&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bellman</span> <span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(d,d+MAXN.INF);<br>    <span class="hljs-built_in">fill</span>(num,num+MAXN,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">fill</span>(w,w+MAXN,<span class="hljs-number">0</span>);<br>    d[s]=<span class="hljs-number">0</span>;<br>    w[s]=weight[s];<br>    num[s]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Adj[u].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> v=Adj[u][j].v;<br>                <span class="hljs-type">int</span> dis=Adj[u][j].dis;<br>                <span class="hljs-keyword">if</span>(d[u]+dis&lt;d[v])&#123;<br>                    d[v]=d[u]+dis;<br>                    w[v]=w[u]+weight[v];<br>                    num[v]=num[u];<br>                    pre[v].<span class="hljs-built_in">clear</span>();<br>                    pre[v].<span class="hljs-built_in">insert</span>(u);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+dis==d[v])&#123;<br>                    <span class="hljs-keyword">if</span>(w[u]+weight[v]&gt;w[v])&#123;<br>                        w[v]=w[u]+weight[v];<br>                    &#125;<br>                    pre[v].<span class="hljs-built_in">insert</span>(u);<br>                    num[v]=<span class="hljs-number">0</span>;<br>                    set&lt;<span class="hljs-type">int</span>&gt;::isterator it;<br>                    <span class="hljs-keyword">for</span>(it=pre[v].<span class="hljs-built_in">begin</span>();it!=pre[v].<span class="hljs-built_in">end</span>();it++)&#123;<br>                        num[v]+=num[*it];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br><br><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;m,&amp;c1,&amp;c2);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;weight[i]);<br>&#125;<br><span class="hljs-built_in">fill</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>Adj[a].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Node</span>(b,c));<br>        Adj[b].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Node</span>(a,c));<br>&#125;<br><span class="hljs-built_in">Bellman</span>(c1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,num[c2],w[c2]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>通过上面的作答发现只有当某个点的d[u]值发生变化的时候，从它出发的边的邻接点v的d[v]值才可能变化，所以可以建立一个队列，每次将队头u取出，然后对u出发的所有u-v边进行松弛处理，如果松弛处理后，也就是d[v]获得了更优的值，但是此时v不在队列中，就把v加入队列，这样操作直到队列为空或者某个顶点的入队次数超过了V-1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;Node&gt; Adj[MAXN];<br><span class="hljs-type">int</span> n,d[MAXN],num[MAXN];<br><span class="hljs-type">bool</span> inq[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(inq,inq+MAXN,<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">fill</span>(num,num+MAXN,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br>    queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>    Q.<span class="hljs-built_in">push</span>(s);<br>    inq[s]=<span class="hljs-literal">true</span>;<br>    num[s]++;<br>    d[s]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u=Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        inq[u]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Adj[u].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-type">int</span> v=Adj[u][j].v;<br>            <span class="hljs-type">int</span> dis=Adj[u][j].dis;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>客观评价模型——数学建模（四）</title>
    <link href="/2023/08/26/%E5%AE%A2%E8%A7%82%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/08/26/%E5%AE%A2%E8%A7%82%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="客观评价"><a href="#客观评价" class="headerlink" title="客观评价"></a>客观评价</h1><p>在数学建模中，经常会遇到评价类问题，在评价类模型的选择中要尽量规避主观模型，如层次分析法、模糊综合评价法、灰色关联分析法。潜台词是如果用这三种，评委老师是绝对不会给你高分。</p><p>那么在客观评价方面，我们也有许多模型可以使用，如主成分分析法、因子分析法、Topsis分析法、神经网络分析法等，接下去我将一一进行介绍和实际案例。</p><h2 id="主成分分析法"><a href="#主成分分析法" class="headerlink" title="主成分分析法"></a>主成分分析法</h2><p>**主成分分析（PCA)**是一种比较基础的数据降维方法，也是多元统计中的重要部分，在数据分析、机器学习等方面具有广泛应用。主成分分析目的是用较少的变量来代替原来较多的变量，并可以反映原来多个变量的大部分信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>评价类赛题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>竞赛C++使用——PAT备考进行时（二）</title>
    <link href="/2023/08/26/%E7%AB%9E%E8%B5%9BC-%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/08/26/%E7%AB%9E%E8%B5%9BC-%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C-使用指南"><a href="#C-C-使用指南" class="headerlink" title="C/C++使用指南"></a>C/C++使用指南</h1><ul><li>  基本数据类型</li></ul><table><thead><tr><th>类型</th><th>大致范围</th></tr></thead><tbody><tr><td>int</td><td>$-2<em>10^9$~$2</em>10^9$</td></tr><tr><td>longlong</td><td>$-9<em>10^{18}$~$9</em>10^{18}$</td></tr><tr><td>float</td><td>实际精度在6~7位</td></tr><tr><td>double</td><td>实际精度在15~16位</td></tr><tr><td>char</td><td>-128~+127</td></tr><tr><td>bool</td><td>0 or 1</td></tr></tbody></table><ul><li><p><strong>注：</strong></p><ul><li>  绝对值在$10^9$之内的整数都可以定义为int。</li><li>  不要用float，浮点数都用double。</li><li>  字符常量要用‘’括起来。</li></ul></li><li><p>  强制类型转换</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">（新类型）变量名<br></code></pre></td></tr></table></figure><ul><li><p>  getchar和putchar用来输入输出单个字符。</p></li><li><p>  数组的大小在$10^6$数量级的时候需要定义在主函数外面。</p></li><li><p>  memset用法：对数组中的每一个元素赋相同的值。memset需要加上cstring。使用memset赋值0或者-1，如果要赋值其他数字用fill函数。</p></li><li><p>  cstring和string不是同一个。</p></li><li><p>  gets和puts用来输入输出一行字符串。</p></li><li><p>cstring中的函数：</p><table><thead><tr><th>函数名</th><th>用法</th></tr></thead><tbody><tr><td>strlen()</td><td>得到字符串数组中第一个’\0’前的字符个数。</td></tr><tr><td>strcmp(s1,s2)</td><td>比较两个字符串</td></tr><tr><td>strcpy(s1,s2)</td><td>2复制到1</td></tr><tr><td>strcat(s1,s2)</td><td>2接到1后</td></tr></tbody></table></li><li><p>  sscanf和sprintf，sscanf是把字符数组中的内容传到n中，sprintf就是将值传入数组中。</p></li><li><p>  只有在string和vector中可以用vi.begin()+i这种迭代器加上整数的写法。</p></li><li><p>  除了vector和string之外的STL容器都不支持*(it+i)的访问方式。</p></li><li><p>  除了string的迭代器可以不写内部的容器，其他都要写：string ::iterator ,vector&lt;int&gt;::iterator。</p></li><li><p>  输入输出整个字符串，只能用cin,cout</p></li><li><p>  但是printf可以用c_str()函数将string类型转换为字符数组进行输出。</p></li><li><p>  map的键值对是唯一对应的，如果要一键对应多个值可以使用multimap。unorder_map速度比map速度要块。</p></li><li><p>priority_queue优先队列的用法：</p><ul><li><p>```c++<br>  priority_queue<int> q;<br>  priority_queue&lt;int ,vector<int>,less<int> &gt; q;//&gt;&gt;要分开</p><p>  默认优先级是数字大优先级越高，less<int>表示数字大的优先级的大，greater<int>表示数字小的优先级越大。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>-   对于结构体的优先级：<br><br>    ```c++<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">fruit</span>&#123;<br>        string name;<br>        <span class="hljs-type">int</span> price;<br>        <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;<br>            <span class="hljs-keyword">return</span> f1.price&lt;f2.price;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>  重载&lt;，不可以重载&gt;，return里和cmp函数相反，也就是&lt;表示价格高优先级高，&gt;表示价格高度优先级低。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学问题</title>
    <link href="/2023/08/22/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/08/22/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h1><h2 id="1069"><a href="#1069" class="headerlink" title="1069"></a>1069</h2><p><strong>题目：</strong></p><blockquote><p>  For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number <code>6174</code> – the <strong>black hole</strong> of 4-digit numbers. This number is named Kaprekar Constant.</p><p>  For example, start from <code>6767</code>, we’ll get:</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">7766</span> <span class="hljs-bullet">-</span> <span class="hljs-number">6677</span> <span class="hljs-string">=</span> <span class="hljs-number">1089</span><br><span class="hljs-number">9810</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0189</span> <span class="hljs-string">=</span> <span class="hljs-number">9621</span><br><span class="hljs-number">9621</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1269</span> <span class="hljs-string">=</span> <span class="hljs-number">8352</span><br><span class="hljs-number">8532</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2358</span> <span class="hljs-string">=</span> <span class="hljs-number">6174</span><br><span class="hljs-number">7641</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1467</span> <span class="hljs-string">=</span> <span class="hljs-number">6174</span><br><span class="hljs-string">...</span> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>  Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case which gives a positive integer <em>N</em> in the range (0,104).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  If all the 4 digits of <em>N</em> are the same, print in one line the equation <code>N - N = 0000</code>. Else print each step of calculation in a line until <code>6174</code> comes out as the difference. All the numbers must be printed as 4-digit numbers.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">6767<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">7766 - 6677 = 1089<br>9810 - 0189 = 9621<br>9621 - 1269 = 8352<br>8532 - 2358 = 6174<br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">2222<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">2222 - 2222 = 0000<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><p>这是一个简单题，但是坑还是挺多的，对于我这种菜鸡用了半小时，首先直接看到例子，都不用看题目，给出一个4位数，然后要求将其排序，要求一个将该数递增-该数递减，求出的数字用于作为下一个数字。</p><p>首先看到要用到排序，但是现在没法排序，因为也就是要把int转换为int[]，但是int[]又没法进行比较。所以还要转换成int进行比较。那么这样一来就需要先写两个函数，一个用于整数转整形数组，一个将数组转换成整数。</p><p>第二步，用一个循环判断number数是否是7641或者0，如果不是就一直循环下去。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">to_number</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span></span>&#123;<br><span class="hljs-type">int</span> number=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>number=number*<span class="hljs-number">10</span>+array[i];<br>&#125;<br><span class="hljs-keyword">return</span> number;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">to_array</span><span class="hljs-params">(<span class="hljs-type">int</span> number,<span class="hljs-type">int</span> array[])</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>array[i]=number%<span class="hljs-number">10</span>;<br>number/=<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> number,max,min;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;number);<br><span class="hljs-type">int</span> array[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">to_array</span>(number,array);<br><span class="hljs-built_in">sort</span>(array,array+<span class="hljs-number">4</span>,cmp);<span class="hljs-comment">//指向数组首地址 </span><br> max=<span class="hljs-built_in">to_number</span>(array);<br> <span class="hljs-built_in">sort</span>(array,array+<span class="hljs-number">4</span>);<br> min=<span class="hljs-built_in">to_number</span>(array);<br> number=max-min;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d - %04d = %04d\n&quot;</span>,max,min,number);<br> <span class="hljs-keyword">if</span>(number==<span class="hljs-number">6174</span>||number==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>  将数组传入函数体时，只需要传入数组首地址就可以，用数组形式接收。</li><li>  注意输出形式，如果要求4位，并且补全0，即为<code>%04d</code></li></ul><hr><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><p>记住以下结论和代码就可以了：</p><ul><li>  <strong>最大公约数：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> !b?a:<span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  <strong>最小公倍数</strong>就是<code>ab/d</code>（d为最大公约数）</li></ul><hr><h2 id="分数的表示和简化"><a href="#分数的表示和简化" class="headerlink" title="分数的表示和简化"></a>分数的表示和简化</h2><p>用一个结构体存储分数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fraction</span>&#123;<br>    <span class="hljs-type">int</span> up,down;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>规则如下：</strong></p><ul><li>  down为非负数，如果分数为负数，令up为负数。</li><li>  如果该分数为0，那么规定分子为0，分母为1。</li><li>  分子和分母没有除了1以外的公约数。</li></ul><p><strong>分母简化的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Fraction <span class="hljs-title">reduction</span><span class="hljs-params">(Fraction result)</span></span>&#123;<br><span class="hljs-keyword">if</span>(result.down&lt;<span class="hljs-number">0</span>)&#123;<br>result.up=-result.up;<br>result.down=-result.down;<br>&#125;<br><span class="hljs-keyword">if</span>(result.up=<span class="hljs-number">0</span>)&#123;<br>result.down=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> d=<span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(result.up),<span class="hljs-built_in">abs</span>(result.down));<br>result.up/=d;<br>result.down/=d;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分数加法：</strong><br>$$<br>result=\frac{f1.up<em>f2.down+f2.up</em>f1.down}{f1.down*f2.down}<br>$$<br><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//分数加法</span><br><span class="hljs-function">Fraction <span class="hljs-title">add</span><span class="hljs-params">(Fraction f1,Fraction f2)</span></span>&#123;<br>Fraction result;<br>result.up=f1.up*f2.down+f2.up*f1.down;<br>result.down=f1.down*f2.down;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">reduction</span>(result);<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>分数的输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showResult</span><span class="hljs-params">(Fraction r)</span></span>&#123;<br>r=<span class="hljs-built_in">reduction</span>(r);<br><span class="hljs-keyword">if</span>(r.down==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,r.up);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(r.up)&gt;r.down)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d/%d&quot;</span>,r.up /r.down,<span class="hljs-built_in">abs</span>(r.up)%r.down,r.down);<br><br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/%d&quot;</span>,r.up,r.down);<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注意：分子分母最好用longlong存储。</strong></p><hr><h2 id="素数和质因子"><a href="#素数和质因子" class="headerlink" title="素数和质因子"></a>素数和质因子</h2><p><strong>素数：</strong></p><ul><li>  素数的判断到$\sqrt{n}$即可。</li><li>  如果是用<code>i*i</code>作为上界判断，注意用longlong。</li><li>  利用筛法进行求解素数。</li></ul><p><strong>质因子：</strong></p><ul><li><p>  1不是素数，没有质因子。</p></li><li><p>fac数组只需要开到10</p><ul><li><p>fac数组的结构体：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">factor</span>&#123;<br>    <span class="hljs-type">int</span> x,cnt;<br>&#125;fac[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure></li></ul></li><li><p>  如果存在1和本身之外的因子，一定实在sqrt(n)的左右成对出现。</p></li><li><p>解题思路：</p><ul><li>  枚举1-sqrt(n)的所有质因子p，判断p是否是n的因子。</li><li>  如果p是n的因子，就给fac数组增加质因子p，并且初始化个数为0，然后，只要p还是n的因子，就让n不断的除以p，每次操作p 的个数+1，知道p不再是n的因子。</li><li>  如果p不是n的因子，就直接跳过。</li><li>  如果上面步骤结束以后n还是&gt;1,说明n有且仅有一个大于sqrt(n)的质因子，这时候把这个质因子加入fac数组，并且令其个数为1。</li></ul></li></ul><h2 id="1059"><a href="#1059" class="headerlink" title="1059"></a>1059</h2><p><strong>题目：</strong></p><blockquote><p>  Given any positive integer <em>N</em>, you are supposed to find all of its prime factors, and write them in the format <em>N</em> = $p1^{k1}<em>p2^{k2}</em>…*pm^{km}$</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case which gives a positive integer <em>N</em> in the range of <strong>long int</strong>.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  Factor <em>N</em> in the format <em>N</em> <code>=</code> <em>p</em>1<code>^</code><em>k</em>1<code>*</code><em>p</em>2<code>^</code><em>k</em>2<code>*</code>…<code>*</code><em>p**m</em><code>^</code><em>k**m</em>, where <em>p**i</em>‘s are prime factors of <em>N</em> in increasing order, and the exponent <em>k**i</em> is the number of <em>p**i</em> – hence when there is only one <em>p**i</em>, <em>k**i</em> is 1 and must <strong>NOT</strong> be printed out.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">97532468<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">97532468=2^2*11*17*101*1291<br></code></pre></td></tr></table></figure></blockquote><p><strong>单词积累：</strong></p><p>prime factors——素因子</p><p><strong>分析：</strong></p><ul><li>  题目中给的素数的范围是int范围，所以素数表只需要$10^5$就可以。</li><li>  当n==1的时候，需要特判。</li><li>   在处理完质因子后要判断n是否是1，如果不是1，则需要处理大于sqrt(n)的部分。</li></ul><p><strong>步骤：</strong></p><p>（1）生成素数表。</p><p>（2）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">//判断是否是素数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> sqr=(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>*n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=sqr;i++)&#123;<br><br><span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br><br><span class="hljs-comment">//素数表</span><br><span class="hljs-type">int</span> prime[maxn],pNum=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Prime</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;maxn;i++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(i)==<span class="hljs-literal">true</span>)&#123;<br>prime[pNum++]=i;<br>&#125;<br>&#125;<br>&#125; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">factor</span>&#123;<br><span class="hljs-type">int</span> x,cnt;<br>&#125;fac[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">Find_Prime</span>();<br><span class="hljs-type">int</span> n , num =<span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1=1&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d=&quot;</span>,n);<br><span class="hljs-type">int</span> sqr=(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>*n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pNum&amp;&amp;prime[i]&lt;=sqr;i++)&#123;<br><span class="hljs-keyword">if</span>(n%prime[i]==<span class="hljs-number">0</span>)&#123;<br>fac[num].x=prime[i];<br>fac[num].cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n%prime[i]==<span class="hljs-number">0</span>)&#123;<br>fac[num].cnt++;<br>n/=prime[i];<br>&#125;<br>num++;<br>&#125;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br><br>&#125;<br><span class="hljs-keyword">if</span>(n!=<span class="hljs-number">1</span>)&#123;<br>fac[num].x=n;<br>fac[num++].cnt=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br><span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,fac[i].x);<br><span class="hljs-keyword">if</span>(fac[i].cnt&gt;<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;^%d&quot;</span>,fac[i].cnt);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>  <code>int sqr=(int)sqrt(1.0*n);</code>平方根的时候要这么写，记住就好。</li></ul><hr><h2 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h2><ul><li>  大整数使用数组进行记录即可。整数的高位存储在数组的高位，整数的低位存储在数组的低位。但是在读入的时候需要进行反转。</li></ul><p><strong>代码：（A+B）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bignum</span>&#123;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-built_in">bignum</span>()&#123;<br><span class="hljs-built_in">memset</span>(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(nums));<br>len=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function">bignum <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>&#123;<br>bignum a;<br>a.len=<span class="hljs-built_in">strlen</span>(str);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.len;i++)&#123;<br>a.nums[i]=str[a.len-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function">bignum <span class="hljs-title">add</span><span class="hljs-params">(bignum a,bignum b)</span></span>&#123;<br>bignum c;<br><span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;<br><span class="hljs-type">int</span> temp=a.nums[i]+b.nums[i]+carry;<br>c.nums[c.len++]=temp%<span class="hljs-number">10</span>;<br>carry=temp/<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(carry!=<span class="hljs-number">0</span>)&#123;<br>c.nums[c.len++]=carry;<br><br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(bignum a)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a.nums[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">char</span> str1[<span class="hljs-number">1000</span>],str2[<span class="hljs-number">1000</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s&quot;</span>,str1,str2);<br>bignum a=<span class="hljs-built_in">change</span>(str1);<br>bignum b=<span class="hljs-built_in">change</span>(str2);<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">add</span>(a,b));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据预处理——数学建模（三）</title>
    <link href="/2023/08/17/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/08/17/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="数据归一化处理"><a href="#数据归一化处理" class="headerlink" title="数据归一化处理"></a>数据归一化处理</h2><p>数据归一化是为了使得不同量纲通过归一化调整到同一量纲，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。</p><h3 id="归一化方法"><a href="#归一化方法" class="headerlink" title="归一化方法"></a>归一化方法</h3><p>1、<em>Min-max normalization</em> (Rescaling)：<br>$$<br>x’=\frac{x-min(x)}{max(x)-min(x)}<br>$$<br>归一化后的数据范围为 [0, 1]，其中 min(x)、max(x)分别求样本数据的最小值和最大值。</p><p>2、Mean normalization：<br>$$<br>x’=\frac{x-mean(x)}{max(x)-min(x)}<br>$$<br>归一化后的数据范围为 [-1, 1]，其中 mean(x)为样本数据的平均值。</p><p>3、Z-score normalization (Standardization)：<br>$$<br>x’=\frac{x-\mu}{\sigma}<br>$$<br>归一化后的数据范围为实数集，其中 μ、σ 分别为样本数据的均值和标准差。</p><ol><li><p>非线性归一化：</p><ul><li>  对数归一化：</li></ul><p> $$<br>x’=\frac{\lg x}{\lg max(x)}<br> $$</p><ul><li>  反正切函数归一化：</li></ul><p> $$<br> x’=\arctan(x)*\frac{2}{\pi}<br> $$</p><p> 归一化后的数据范围为 [-1, 1]。</p><ul><li>  小数定标标准化:</li></ul><p> $$<br> x’=\frac{x}{10^j}<br> $$</p><p> 归一化后的数据范围为 [-1, 1]，j为使max(|x′|)&lt;1的最小整数。</p></li></ol><h3 id="归一化和标准化总结"><a href="#归一化和标准化总结" class="headerlink" title="归一化和标准化总结"></a>归一化和标准化总结</h3><ul><li><p>  Min-max归一化和mean归一化适合在<strong>最大最小值明确不变</strong>的情况下使用。如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。</p></li><li><p>  Z-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。</p></li><li><p>  standardization其实就是z-score normalization，所以标准化就是归一化的一种。</p></li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/normalization/basic_normalization.html">https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/normalization/basic_normalization.html</a></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>数据预处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相关性分析方法——数学建模（二）</title>
    <link href="/2023/08/17/%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/08/17/%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="相关性分析"><a href="#相关性分析" class="headerlink" title="相关性分析"></a>相关性分析</h1><p>相关分析是统计学和数据分析领域中常用的方法，用于确定两个或多个变量之间的关系以及它们之间的相互影响程度。以下是一些常见的相关分析方法：</p><ol><li> <strong>皮尔逊相关系数：</strong> 皮尔逊相关系数衡量了两个连续变量之间的线性关系强度和方向。它的取值范围在 -1 到 1 之间，其中 -1 表示完全负相关，1 表示完全正相关，0 表示无相关性。</li><li> <strong>斯皮尔曼等级相关系数：</strong> 斯皮尔曼相关系数是一种用于衡量两个变量之间的单调关系的方法，而不仅仅是线性关系。它基于变量的等级而不是具体的数值，因此对于非线性关系也适用。</li><li> <strong>判定系数（R²）：</strong> 判定系数是用于衡量一个回归模型对观测数据的拟合程度。它的取值范围在0到1之间，越接近1表示模型拟合得越好。</li><li> <strong>卡方检验：</strong> 卡方检验主要用于分析分类变量之间的关系，特别是在两个或多个分类变量之间是否存在统计显著的关联。</li><li> <strong>ANOVA（方差分析）：</strong> 方差分析用于比较多个组之间的均值差异是否显著，适用于一个因变量和一个或多个分类变量的情况。</li><li> <strong>回归分析：</strong> 回归分析用于建立一个或多个自变量与因变量之间的关系模型，可以帮助预测因变量的值。</li><li> <strong>因子分析：</strong> 因子分析用于确定隐藏在观测数据背后的潜在因子，从而帮助简化数据集并揭示变量之间的模式。</li><li> <strong>主成分分析：</strong> 主成分分析旨在将高维数据降维到较低维度，同时保留尽可能多的原始数据变异性。</li></ol><h2 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h2><p>Pearson相关系数公式如下：</p><p><img src="/../images/95c7b4484dc46f28390c4de96c83b915_1440w.webp" alt="img"></p><p>协方差是一个反映两个<strong>随机变量</strong>相关程度的指标：<br><img src="https://picx.zhimg.com/80/0dfac74fd0cc7e4670fc04e15a5d79e2_1440w.webp?source=1940ef5c" alt="img"></p><p>pearson是一个介于-1和1之间的值，当两个变量的线性关系增强时，相关系数趋于1或-1；当一个变量增大，另一个变量也增大时，表明它们之间是正相关的，相关系数大于0；如果一个变量增大，另一个变量却减小，表明它们之间是负相关的，相关系数小于0；如果相关系数等于0，表明它们之间不存在线性相关关系。</p><p>pearson系数通常同于两个连续性变量之间的相关性。</p><h2 id="斯皮尔曼等级相关系数"><a href="#斯皮尔曼等级相关系数" class="headerlink" title="斯皮尔曼等级相关系数"></a>斯皮尔曼等级相关系数</h2><p>若两变量中包含等级变量，或变量不符合正态分布，或变量分布类型未知时，可以采用另一种相关性分析方法——Spearman等级相关性分析。</p><p><strong>适用条件</strong></p><ul><li>  变量包含等级变量、或变量不服从正态分布或分布类型未知。</li><li>  两变量之间存在单调关系。</li></ul><p><strong>统计量计算</strong></p><p>计算Spearman相关系数$r_{s}$的过程为:</p><ul><li>  先将变量<em>X</em>、<em>Y</em>分别从小到大排序编秩，用秩次<em>RX</em>和<em>RY</em>表示。</li></ul><p><img src="/../images/image-20230824103217446.png" alt="image-20230824103217446"></p><ul><li>  与Pearson相关系数的计算公式对比， Spearman相关系数的计算公式只是将Pearson相关系数公式中的<em>X</em>、<em>Y</em>替换为了<em>R**X</em>、<em>R**Y</em>.</li></ul><p><strong>假设检验</strong></p><p>样本含量<em>n</em>的大小有两种方法,查表法和t检验。</p><p><strong>参考文献：</strong></p><p><a href="https://mengte.online/archives/1879">https://mengte.online/archives/1879</a></p><h2 id="决定系数（R²）"><a href="#决定系数（R²）" class="headerlink" title="决定系数（R²）"></a>决定系数（R²）</h2><p>对于简单线性回归而言，决定系数为样本相关系数的平方。当加入其他回归自变量后，决定系数相应地变为多重相关系数的平方。</p><p><img src="/../images/image-20230824104619549.png" alt="image-20230824104619549"></p><h2 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h2><p><strong>什么是独立性卡方检验？</strong></p><p>独立性卡方检验是一种统计学上的假设检验，用于确定两个分类型或名义型变量是否可能相关。</p><p><strong>何时可以使用该检验？</strong></p><p>当您有两个分类型变量的值计数时，您可以使用独立性卡方检验。</p><p><strong>如果有一个频数计数表格，是否可以使用该检验？</strong></p><p>是的。如果您只有一个表格，其中的值显示频数计数，您可以使用独立性卡方检验。</p><p><strong>参考文献：</strong></p><p><a href="https://www.jmp.com/zh_cn/statistics-knowledge-portal/chi-square-test/chi-square-test-of-independence.html">https://www.jmp.com/zh_cn/statistics-knowledge-portal/chi-square-test/chi-square-test-of-independence.html</a></p><h2 id="ANOVA（方差分析）"><a href="#ANOVA（方差分析）" class="headerlink" title="ANOVA（方差分析）"></a>ANOVA（方差分析）</h2><h3 id="单因素方差分析（one-way-ANOVA"><a href="#单因素方差分析（one-way-ANOVA" class="headerlink" title="单因素方差分析（one-way ANOVA)"></a>单因素方差分析（one-way ANOVA)</h3>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>相关性分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>层次分析法——数学建模（一）</title>
    <link href="/2023/08/13/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/08/13/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h1><p><img src="/../images/fb4a24c19b1bb68aab3ccea101551815.png" alt="img"></p><h2 id="AHP层次分析法过程"><a href="#AHP层次分析法过程" class="headerlink" title="AHP层次分析法过程"></a>AHP层次分析法过程</h2><p>层次分析法就是将一个决策事件分解为<em>目标层</em>（例如选择旅游地），<em>准则层</em>（影响决策的因素，例如景色、交通、费用等）以及<em>方案层</em>（指的是方案，例如去广州、桂林等地旅游）。</p><p><img src="/../images/30dd8e4cdafed2d56d337794fa610dcb.png" alt="img"></p><p><strong>建立步骤：</strong></p><ol><li> 层次结构模型的构建。</li><li> 构造判断矩阵</li><li> 层次单排序及其一致性检验</li><li> <em>层次总排序</em>及其一致性检验</li></ol><p><strong>PS:</strong></p><p>一致性检验的含义用于确定构建的判断矩阵是否存在逻辑问题。</p><h3 id="1-层次结构模型的构建。"><a href="#1-层次结构模型的构建。" class="headerlink" title="1.层次结构模型的构建。"></a>1.层次结构模型的构建。</h3><p>确认整个决策事件的<em>目标层、准则层、方案层</em></p><p><img src="/../images/6e02b047d20c941c29e57c4a356f7571.png" alt="img"></p><p>目标层：最优旅游地选择</p><p>准则层：景色、费用、居住、饮食、旅途</p><p>方案层：西安、云南、西藏、青海</p><p>如果有多层：</p><p><img src="/../images/d476b972c13221d3e1223b1fd5d6782b.png" alt="img"></p><h3 id="2-构造判断矩阵"><a href="#2-构造判断矩阵" class="headerlink" title="2.构造判断矩阵"></a>2.构造判断矩阵</h3><p>通过各要素之间相互两两比较，并确定各准则层对目标层的权重。</p><p><img src="/../images/ea5d74f7b48afd3f446c78866c212d09.png" alt="img"></p><p>建立一个矩阵：</p><p><img src="/../images/25047e173e25a3d231b007b305247000.png" alt="img"></p><p>A中元素满足：</p><img src="../images/f92cd151513ab425201d920e35c56b98.png" alt="img" style="zoom: 50%;" /><h3 id="3-层次单排序与一致性检验"><a href="#3-层次单排序与一致性检验" class="headerlink" title="3.层次单排序与一致性检验"></a>3.层次单排序与一致性检验</h3><ul><li>  <strong>step1：层次单排序</strong></li></ul><p>指针对上一层某元素将本层中所有元素两两评比，并开展层次排序， 进行重要顺序的排列。</p><p>具体计算可依据判断矩阵 A 进行，计算中确保其能够符合 <strong>AW=𝜆𝑚𝑎𝑥𝑊</strong>的特征根和特征向量条件。在此，A 的最大特征根为<strong>λmax</strong>，对应λmax的正规化的特征向量为 <strong>W</strong>，𝑤𝑖为 W 的分量，其指的是权值，与其相应元素单排序对应。 利用判断矩阵计算各因素𝑎𝑖𝑗对目标层的权重（权系数）。</p><p><img src="/../images/f8b7627588f5b4c005b46c91ddcc5762.png" alt="img"></p><ul><li>  step2：求解最大特征根与CI值</li></ul><p><img src="/../images/8f9edf32bb6445d16b6c8009929d4868.png" alt="img"></p><p>C.I.=0 表示判断矩阵完全一致，C.I.越大，判断矩阵的不一致性程度越严重。</p><ul><li>  step3：根据CI、RI值求解CR值，判断其一致性是否通过</li></ul><p> 模拟 1000 次得到的随机一致性指标 R.I.取值表：</p><p><img src="/../images/ea5f4db7cb5744c1fc697ee8ca95c4f2.png" alt="img"></p><p>当 C.R.&lt;0.1 时，表明判断矩阵 A 的一致性程度被认为在容许的范围内，此时可 用 A 的特征向量开展权向量计算；若 C.R.≥0.1, 则应考虑对判断矩阵 A 进行修正。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>层次分析法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒杀模拟题——PAT备考进行时（一）</title>
    <link href="/2023/08/11/%E7%A7%92%E6%9D%80%E6%A8%A1%E6%8B%9F%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/08/11/%E7%A7%92%E6%9D%80%E6%A8%A1%E6%8B%9F%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟题不简单"><a href="#模拟题不简单" class="headerlink" title="模拟题不简单"></a>模拟题不简单</h1><h2 id="1042-Shuffling-Machine"><a href="#1042-Shuffling-Machine" class="headerlink" title="1042 Shuffling Machine"></a><strong>1042 Shuffling Machine</strong></h2><p><strong>题目：</strong></p><blockquote><p>  Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ <strong>automatic shuffling machines</strong>. Your task is to simulate a shuffling machine.</p><p>  The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p>  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">S1</span></span>, S2, ..., S13, <br><span class="hljs-function"><span class="hljs-title">H1</span></span>, H2, ..., H13, <br><span class="hljs-function"><span class="hljs-title">C1</span></span>, C2, ..., C13, <br><span class="hljs-function"><span class="hljs-title">D1</span></span>, D2, ..., D13, <br>J1, J2<br></code></pre></td></tr></table></figure><p>  where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the <em>i</em>-th position is <em>j</em>, it means to move the card from position <em>i</em> to position <em>j</em>. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each case, the first line contains a positive integer <em>K</em> (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">2<br>36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><p>首先是英语的阅读，会造成一定的困扰，所以一开始读题目就可以去看给的例子，然后代入题目去理解，注意所有细节，包括但是不限于数据格式，大小。</p><p>这题的难度其实不大，就是一个简单的模拟题，但是，找准next和end数组非常关键。要注意花色和编号的对应关系，，并且注意格式输出，包括空格。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> size=<span class="hljs-number">54</span>;<br><span class="hljs-type">char</span> flower[<span class="hljs-number">5</span>]=&#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;H&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;J&#x27;</span>&#125;;<br><span class="hljs-type">int</span> start[size+<span class="hljs-number">1</span>],next[size+<span class="hljs-number">1</span>],end[size+<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>        start[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;next[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>        end[next[i]]=start[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>            start[i]=end[i];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        start[i]--;<span class="hljs-comment">//看这里</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%d&quot;</span>,flower[start[i]/<span class="hljs-number">13</span>],start[i]%<span class="hljs-number">13</span>+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中主要注意标记处，为什么要start[i]–;因为举个例子，标号为13的对应是S13,但是如果进行start[i]/13,就会得到1。不过也可以进行下面的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%d&quot;</span>,flower[(start[i]<span class="hljs-number">-1</span>)/<span class="hljs-number">13</span>],(start[i]<span class="hljs-number">-1</span>)%<span class="hljs-number">13</span>+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="1046-Shortest-Distance"><a href="#1046-Shortest-Distance" class="headerlink" title="1046 Shortest Distance"></a><strong>1046 Shortest Distance</strong></h2><p><strong>题目：</strong></p><blockquote><p>The task is really simple: given <em>N</em> exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <em>N</em> (in [3,105]), followed by <em>N</em> integer distances <em>D</em>1 <em>D</em>2 ⋯ <em>D**N</em>, where <em>D**i</em> is the distance between the <em>i</em>-th and the (<em>i</em>+1)-st exits, and <em>D**N</em> is between the <em>N</em>-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer <em>M</em> (≤104), with <em>M</em> lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to <em>N</em>. It is guaranteed that the total round trip distance is no more than 107.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print your results in <em>M</em> lines, each contains the shortest distance between the corresponding given pair of exits.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;5 1 2 4 14 9<br>&gt;3<br>&gt;1 3<br>&gt;2 5<br>&gt;4 1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;3<br>&gt;10<br>&gt;7<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><p>一个圆中要找到两个点之间最近的路无非是两个路径看看谁的长，但是本题中数据较大，所以需要对数据进行预处理，否则拿不了最后一个测试点。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> dis[MAXN],A[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,query,n,left,right;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;A[i]);<br>        sum+=A[i];<br>        dis[i]=sum;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;query);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;query;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;left,&amp;right);<br>        <span class="hljs-keyword">if</span>(left&gt;right)<span class="hljs-built_in">swap</span>(left,right);<br>        <span class="hljs-type">int</span> temp=dis[right<span class="hljs-number">-1</span>]-dis[left<span class="hljs-number">-1</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">min</span>(temp,sum-temp));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="1001-A-B-Format"><a href="#1001-A-B-Format" class="headerlink" title="1001 A+B Format"></a>1001 <strong>A+B Format</strong></h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学模型与常用算法汇总</title>
    <link href="/2023/07/03/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/2023/07/03/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>数学建模常用算法汇总</p><h2 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h2><p><img src="https://img-blog.csdnimg.cn/ff05f94f8a7d4f3790dac84aa43b2b3a.png" alt="ff05f94f8a7d4f3790dac84aa43b2b3a.png"></p><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p><img src="https://img-blog.csdnimg.cn/20200831100037916.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200831100112161.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模2023--知耻而后勇</title>
    <link href="/2023/06/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A12023-%E7%9F%A5%E8%80%BB%E8%80%8C%E5%90%8E%E5%8B%87/"/>
    <url>/2023/06/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A12023-%E7%9F%A5%E8%80%BB%E8%80%8C%E5%90%8E%E5%8B%87/</url>
    
    <content type="html"><![CDATA[<h1 id="2023数学建模国赛预备"><a href="#2023数学建模国赛预备" class="headerlink" title="2023数学建模国赛预备"></a>2023数学建模国赛预备</h1><h2 id="总结失败"><a href="#总结失败" class="headerlink" title="总结失败"></a>总结失败</h2><p>从上一年的比赛中，看出了非常多的问题，首先是队友配合不默契，加上前期的准备不充分，造成了从开始比赛到结束的整一个过程中都非常的混乱。最后只有一个小奖。下面就是我对上一年的失败总结。</p><p>关于团队，如果一个团队没有一个好的领导能力的人进行统筹兼顾，那将会造成一个非常严重的问题，那就是做事没有节奏和秩序。关于队员的分工，按照论文手、建模手、编程手来分会造成严重的错误，那就是各自不知道对方在说什么，同时也会造成论文表达的错误，在之前一次的数学建模比赛中我们就出现了这样类似的严重的错误。所以本次比赛，我想的是最好采用各分其职，但是互相交互。也就是论文手也需要准备算法的了解，但是可以不必深入，只是需要知道这个算法是干什么的。当然，这里我们不详细讨论分工，下文会详细说明。</p><p>还有就是在比赛的时候的时间分配以及题目的选择，关于题目，最好选自己最熟悉的或者有思路的题目，一旦开始解题就不要轻易改变，绝对一点，别改题目，会出大事。这就需要前期的大量练习来得知自己最熟练哪些题目。</p><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><p>既然是一个团队比赛，那就必须要进行一个合理的分工，前面我讲到不能够分而治之，而是要互相交互。同样的，总的来说来说还是要进行明确的分工，也就是建模手、编程手、论文手。接下去我就讲讲我认为每个职位对应的职责。</p><h3 id="论文手"><a href="#论文手" class="headerlink" title="论文手"></a>论文手</h3><p>虽然我没有当过论文手，但是我足以知道一个好的论文手需要具备哪些能力。论文其实大家都没怎么写过，当然佬除外。先说说数学建模中一篇好论文意味着什么？</p><p>好吧，意味着一切。因为评分就是看论文（手动狗头）。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>大学比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>还分不清Session、Cookie、Token？进来看</title>
    <link href="/2023/06/27/%E8%BF%98%E5%88%86%E4%B8%8D%E6%B8%85Session%E3%80%81Cookie%E3%80%81Token%EF%BC%9F%E8%BF%9B%E6%9D%A5%E7%9C%8B/"/>
    <url>/2023/06/27/%E8%BF%98%E5%88%86%E4%B8%8D%E6%B8%85Session%E3%80%81Cookie%E3%80%81Token%EF%BC%9F%E8%BF%9B%E6%9D%A5%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如果给你每天一个小时学技术，怎么学最高效</title>
    <link href="/2023/06/24/%E5%A6%82%E6%9E%9C%E7%BB%99%E4%BD%A0%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%AD%A6%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AD%A6%E6%9C%80%E9%AB%98%E6%95%88/"/>
    <url>/2023/06/24/%E5%A6%82%E6%9E%9C%E7%BB%99%E4%BD%A0%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%AD%A6%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AD%A6%E6%9C%80%E9%AB%98%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h1 id="怎么学技术最快"><a href="#怎么学技术最快" class="headerlink" title="怎么学技术最快"></a>怎么学技术最快</h1><p>今天我们来聊一聊怎么学习一门技术，从只有听说过或者了解到到快速入门、精通原理。</p><p>说实话，其实我的学习能力真的太弱了，学习一个基础知识或者语言框架都太慢了，甚至会出现拖沓的现象，特别是最近在准备研究生考试，感觉每天根本抽不出时间来学习，每次都是打开idea，打开虚拟机，打开官方文档，然后就半小时过去了，既没有学习到东西又浪费了时间。而且有时候可能一个bug就会消耗几个小时，这些问题对于现在的我都是致命的，所以我们就来讨论一下怎么可以及快速又准确的学会知识。</p><h2 id="一切服务于代码"><a href="#一切服务于代码" class="headerlink" title="一切服务于代码"></a>一切服务于代码</h2><p>为什么我们学东西慢，要追究这个问题，我认为还得是中国的教育问题，因为我们就好像已经适应了先去学习理论，一定要等到理论满分才开始实践，这重学习方法在编程领域绝对是100%的错误，因为没有一个人能够从那些晦涩难懂的厚重的教材中快速的找到应该掌握的知识，当然，现在非常多的教育机构和视频课程手把手的教学编程，可是你扪心自问，那些课听了以后有收获吗？我这里说的是只听课，把听课当作是刷剧的那些人，真的能够学到知识吗，当然几个月之前的我就是这样子的。</p><p>编程的核心是什么？是数据结构与算法。哈哈哈哈，但是这里说的是学习新的框架技术。学习框架技术这些最最最需要的是什么，是实践，是实打实的敲代码。</p><h2 id="如果快速入门一门编程技术"><a href="#如果快速入门一门编程技术" class="headerlink" title="如果快速入门一门编程技术"></a>如果快速入门一门编程技术</h2><p>当然我口头说的大家会觉得没有用，我接下来会在每天的9点到10点进行编程的学习，就是学习我之前没有接触过的技术，并且每天都会更新学习动态。其实我一直都想深入的学习一下Redis，但是每次都是浅浅的学习和使用，可以说我还是停留在应用阶段，所以接下去的一个星期我会进行Redis的系统学习，一下就是我的计划：</p><ul><li>  Day1：以黑马点评项目入手，看懂Redis在这个项目中的应用，并且对关键的代码进行复刻和总结。</li><li>  Day2：重复Day1的工作，并且完成重点和难点分析，追踪源码进行大概分析如何实现。</li><li>  Day3：对照项目和官方文档，进行系统的基础梳理和归纳（目标是快速编写总结博客），基础入门结束。</li><li>  Day4-Day6：Redis官方进阶文档并且查找实际项目案例。</li><li>  Day7：Redis面试题进行查漏补缺，并且进行总结性文档编写。</li></ul>]]></content>
    
    
    <categories>
      
      <category>聊一聊技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闲聊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaIO机制全解——Java基础篇（七）</title>
    <link href="/2023/06/18/JavaIO%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2023/06/18/JavaIO%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java接口和内部类全解——Java基础篇（六）</title>
    <link href="/2023/06/18/Java%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2023/06/18/Java%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><ul><li>接口是由全局常量和公共抽象方法组成，接口中集合了抽象方法，在java8之前，我们可以把接口理解为100%的抽象类，即接口中的方法都是抽象方法，Java设计接口的目的在于解决Java无法多继承，但是接口在实际的使用中常常是用来制定标准的。</li><li>一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。</li><li>接口不能被实例，但是可以被实现，实现类需要100%实现一个接口中所有的方法。</li><li>如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：<strong>抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类</strong>）</li><li>接口被用来实现抽象，而抽象类也被用来实现抽象，为什么一定要用接口呢？接口和抽象类之间又有什么区别呢？原因是抽象类内部可能包含非final的变量，但是在接口中存在的变量一定是final，public,static的。</li><li>一个类可以实现多个接口。</li><li>一个接口可以继承另一个接口，或者另一些接口，也就是可以多继承。</li><li>接口也可以用来实现解耦。</li></ul><h2 id="接口中的多态"><a href="#接口中的多态" class="headerlink" title="接口中的多态"></a>接口中的多态</h2><p>举一个小例子：</p><p>​    现在我们要对空调进行接口统一的管理，有一个“节能”的功能，或者说”节能”就是一个接口，这个接口中有一个方法叫做”变频方法“，任何节能空调，都需要实现这个接口，并且要实现”变频方法“这个方法。当某个空调实现了这样一个”节能“接口后，该空调就具有节能的功能。这时候，我们不需要用空调类引用指向空调对象，而是可以用“节能接口”引用的遥控器去指向空调对象。也就是多态，通过向上转型，我们去通过操作遥控器的“变频方法”去命令空调调用“变频”方法。</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类顾名思义就是在类里的类。</p><h2 id="为什么使用内部类"><a href="#为什么使用内部类" class="headerlink" title="为什么使用内部类"></a>为什么使用内部类</h2><ul><li>内部类方法可以访问该类定义所在的作用域的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码的时候，使用匿名内部类比较便捷。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java继承全解——Java基础篇（五）</title>
    <link href="/2023/06/18/Java%E7%BB%A7%E6%89%BF%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2023/06/18/Java%E7%BB%A7%E6%89%BF%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是面向对象编程的三大特性之一。继承主要就是子类从父类继承特性与行为使得子类对象拥有父类的实例方法和属性。</p><h2 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h2><p>通过继承可以快速创建新的类，实现代码的重用，提高程序的可维护性，节省大量创建新类的时间，提高开发效率和开发质量。</p><h2 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h2><ul><li>子类不能选择性继承父类，子类会继承父类的所有方法和属性。</li><li>Java没有C++的多继承，但是Java中可以进行多级继承，并且Java提供了接口用于克服单继承的缺点，一个类的可以实现多个接口。</li><li>构造方法不会被继承，但是子类可以调用父类的构造方法。</li><li>final类或者方法不可以被继承或者重写。将类或者方法名定义为final的目的是确保他们不会在子类中改变语义。例如Calendar类中的getTime和setTime都声明为final。这表明Calendar类不允许子类处理和Date类之间的转换。</li><li>将一个子类的引用赋给一个父类变量，编译器是允许的。但是把一个父类的引用赋给一个子类变量，必须进行类型转换。</li><li>在进行类型转换前，需要进行instanceof检验看看能否成功转换，不然会产生一个ClassCastException异常。一般情况下，应该少用类型转换和instanceof运算符。</li><li>子类不能访问父类的私有域或者私有方法。</li><li>父类受保护的域或者方法可以直接被子类调用，详见Object类中的clone方法。</li></ul><h2 id="Object类：所有类的超类"><a href="#Object类：所有类的超类" class="headerlink" title="Object类：所有类的超类"></a>Object类：所有类的超类</h2><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p> 简单来说，equals方法是用来判断两个对象是否相等。Object类提供的判断依据是两个对象的引用地址是否相同。所以一般引用类型的比较都是用equals()方法。</p><p>equals方法具有以下几个特点(在自行编写的类中如果要覆盖Object类的equals方法，要求都符合以下特征)：</p><p>1、自反性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>2、对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(y) == y.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>3、传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))<br>    x.equals(z); <span class="hljs-comment">// true;</span><br></code></pre></td></tr></table></figure><p>4、一致性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(y) == x.equals(y); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>5、对于任意非空引用x，x.equals(null)应该返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(<span class="hljs-literal">null</span>); <span class="hljs-comment">// false;</span><br></code></pre></td></tr></table></figure><p>注意：TimeStamp类继承java.utils.Date，但是后者的equals方法使用一个instanceof测试，这样使得无法覆盖equals使之同时做到对称性。也就是不能用TimeStamp类中的equals方法去和Date比较。</p><p><strong>如何编写equals</strong>：</p><p>1、检查this和otherObject是否引用同一个对象。</p><p>2、检查otherObject是否为null，如果为null返回false。</p><p>3、比较this和otherObject是否属于同一个类。如果equals的语义在每个子类中有所改动则用getClass检测，如果所有的子类都拥有统一的语义就用instanceof检测。</p><p>4、将otherObject转换为相应的类变量。</p><p>5、对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。如果匹配就返回true，否则返回false。</p><p><strong>提示</strong>：对于数组类型的域，可以利用静态的Arrays.equals方法进行检测。</p><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object otherObject)</span> &#123;<br>      <span class="hljs-comment">//1、检查this和otherObject是否引用同一个对象。</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == otherObject) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">//2、检查otherObject是否为null，如果为null返回false。</span><br>      <span class="hljs-keyword">if</span> (otherObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">//3、比较this和otherObject是否属于同一个类。</span><br>     <span class="hljs-keyword">if</span> (getClass() != otherObject.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//每个子类中有所改动</span><br>     <span class="hljs-keyword">if</span> (!(otherObject <span class="hljs-keyword">instanceof</span> EqualExample)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//所有的子类都拥有统一的语义</span><br>      <span class="hljs-comment">//4、将otherObject转换为相应的类变量。</span><br>      <span class="hljs-type">EqualExample</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (EqualExample) otherObject;<br>      <span class="hljs-comment">//5、对所有需要比较的域进行比较。</span><br><span class="hljs-keyword">return</span> x=other.x &amp;&amp; Objects.equals(y,other.y);<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>默认输出ClassName@散列码的无符号十六进制表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><p>clone() 是 Object 的 protected 方法，如果要调用该类实例的clone()方法，必须要去显示的重写。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h4><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h4><p>拷贝对象和原始对象的引用类型引用不同对象。需要将对象里所有的元素全部克隆到新的空间。</p><h4 id="clone-的替代方案"><a href="#clone-的替代方案" class="headerlink" title="clone() 的替代方案"></a><strong>clone() 的替代方案</strong></h4><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><h2 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h2><p>将int，long，float，double等基础类型转换成类的手段叫做<strong>对象包装器</strong>。对象包装器是不可变的，对象包装器类是final。</p><p>有一个对象数组列表ArrayList&lt;&gt;，因为尖括号中不能有基础类型，所以这里就用到了Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">//Java SE 5.0改进了添加元素的操作，下面的调用</span><br>list.add(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//将自动变换为</span><br>list.add(Integer.valueOf(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>这种变换叫<strong>自动装箱</strong>，自动装箱那就有自动拆箱。</p><p>注意：自动装箱和自动拆箱是编译器认可的，而不是JVM。</p><h2 id="参数数量可变"><a href="#参数数量可变" class="headerlink" title="参数数量可变"></a>参数数量可变</h2><ul><li>一个方法只能有一个可变的参数,并且这个参数必须是该方法的最后一个参数</li><li>如果重载了可变参数的方法, 优先调用匹配定长参数的方法,不定参数的那个重载方法是最后被选中的。</li><li>对于可变参数的方法,既可以接受多个形式参数类型的参数,也可以接受形式参数类型的数组; 但是方法参数为数组只能接受数组.</li><li>方法调用时,同时满足两个方法,编译器将会产生错误</li><li>对于继承,子类将父类方法的参数列表数组形式改为可变参数数量属于重写,但是指向子类的父类调用该方法是形参列表由父类决定.</li><li>如果向可变长参数的方法传入空参的话,将会new一个对应类型的数组,且长度为0.</li></ul><h2 id="枚举类-需要补充进阶枚举"><a href="#枚举类-需要补充进阶枚举" class="headerlink" title="枚举类(需要补充进阶枚举)"></a>枚举类(需要补充进阶枚举)</h2><p>枚举类主要是为了进行信息分类，枚举是一种特殊类。枚举是有固定实例个数的类型，我们可以把枚举理解成有固定个数实例的多例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//枚举类型，使用关键字enum</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    MONDAY, TUESDAY, WEDNESDAY,<br>    THURSDAY, FRIDAY, SATURDAY, SUNDAY<br>&#125;<br><span class="hljs-keyword">enum</span> 枚举名 &#123;<br>    第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常处理全解——Java基础篇（四）</title>
    <link href="/2023/06/18/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/06/18/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Java异常是Java提供的一种识别及响应错误的一致性机制，保证程序的健壮性。</p><h2 id="异常是什么？"><a href="#异常是什么？" class="headerlink" title="异常是什么？"></a>异常是什么？</h2><p>异常在Java中是以类的形式存在的，每一个异常类都可以创建异常对象，并且也可以自定义异常类。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p><img src="https://img-blog.csdnimg.cn/20210503143543377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>从异常的结构图中可以看出，所有异常都是由Throwable继承而来，但是在下一层分为了<strong>Error</strong>和<strong>Exception</strong>。</p><h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>Error类层次结构范畴描述的是Java在运行时系统内部错误和资源消耗，遇到Error，除了通告用户，并且尽力使程序安全地终止外，在没有办法，但是这种情况出现的概率很低。</p><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>我们作为程序员就关注Exception层次结构就可以了，这个层次分为两个分支：<strong>RuntimeException</strong>和<strong>其他异常</strong>。这两个分支对应的异常种类就是<strong>运行时异常</strong>和<strong>编译时异常</strong>。</p><ul><li><p><strong>运行时异常</strong></p><p>  如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。如果出现这类异常，那一定是程序员的问题。</p></li><li><p><strong>编译时异常</strong></p><p>  从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p></li></ul><p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为<strong>未检查异常</strong>，所有其他的异常成为<strong>已检查异常</strong>。</p><h4 id="已检查异常"><a href="#已检查异常" class="headerlink" title="已检查异常"></a>已检查异常</h4><p>一个方法必须声明所有可能抛出的已检查异常，而未检查异常要么不可控（Error），要么就应该避免发生（RuntimeException），如果方法没有声明所有可能发生的已检验异常，编译器就会给出一个错误信息，在IDE中就是直接报错提醒。</p><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h2><ul><li><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><strong>throw</strong> – 用于抛出异常。</li><li><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h3 id="异常的声明"><a href="#异常的声明" class="headerlink" title="异常的声明"></a>异常的声明</h3><p>异常的声明是当程序运行时，如果方法存在异常，但是在方法并没有对其进行捕获，那必须在方法头中显示声明该异常，以便告知方法调用者此方法有问题。具体的操作就是在方法头使用关键字throws，后面加上要声明的异常。若声明多个异常，则使用逗号分割。通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, FileNotFoundException&#123;<br>    <span class="hljs-comment">//something statements</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Throws抛出异常的规则：</p><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h3><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>(<span class="hljs-string">&quot;参数不能为0&quot;</span>); <span class="hljs-comment">//抛出一个运行时异常</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5.0</span> / value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span>&#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-built_in">super</span>(msg);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><p>异常捕获处理的方法通常有：</p><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h4><ul><li>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</li><li>同一个 catch 也可以捕获多种类型异常，用 | 隔开</li></ul><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p><img src="https://www.pdai.tech/images/java/java-basic-exception-2.jpg" alt="img"></p><h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h4><p>try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。</p><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h4 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h4><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryWithResourceTest</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;c:/abc&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>))&#123;<br>        <span class="hljs-comment">// code</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        <span class="hljs-comment">// handle exception</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>看下Scanner</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;String&gt;, Closeable &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Closeable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p><h2 id="常用的异常"><a href="#常用的异常" class="headerlink" title="常用的异常"></a>常用的异常</h2><ul><li><strong>RuntimeException</strong><ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li><strong>IOException</strong><ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li><strong>其他</strong><ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul><h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><h3 id="只针对不正常的情况才使用异常"><a href="#只针对不正常的情况才使用异常" class="headerlink" title="只针对不正常的情况才使用异常"></a>只针对不正常的情况才使用异常</h3><p>《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p><p>主要原因有三点：</p><ul><li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。</li><li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。</li><li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li></ul><h3 id="在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="在 finally 块中清理资源或者使用 try-with-resource 语句"></a>在 finally 块中清理资源或者使用 try-with-resource 语句</h3><ul><li>方法一：使用 finally 代码块</li></ul><p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeResourceInFinally</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>        inputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        log.error(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                inputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法二：Java 7 的 try-with-resource 语法</li></ul><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">automaticallyCloseResource</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);) &#123;<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        log.error(e);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        log.error(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="尽量使用标准的异常"><a href="#尽量使用标准的异常" class="headerlink" title="尽量使用标准的异常"></a>尽量使用标准的异常</h3><p>Java标准异常中有几个是经常被使用的异常。如下表格：</p><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table><h3 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h3><blockquote><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p></blockquote><h3 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h3><p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p><p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p><p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p><h3 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h3><p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p><h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><p>现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p><p>合理的做法是至少要记录异常的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAnException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        log.error(<span class="hljs-string">&quot;This should never happen: &quot;</span> + e); <span class="hljs-comment">// see this line</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h3><p>仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p><h3 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="包装异常时不要抛弃原始的异常"></a>包装异常时不要抛弃原始的异常</h3><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrapException</span><span class="hljs-params">(String input)</span> <span class="hljs-keyword">throws</span> MyBusinessException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBusinessException</span>(<span class="hljs-string">&quot;A message that describes the error.&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h3><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h3 id="不要在finally块中使用return。"><a href="#不要在finally块中使用return。" class="headerlink" title="不要在finally块中使用return。"></a>不要在finally块中使用return。</h3><p>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。</p><p>如下是一个反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkReturn</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// x等于1，此处不返回</span><br>        <span class="hljs-keyword">return</span> ++x;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 返回的结果是2</span><br>        <span class="hljs-keyword">return</span> ++x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射全解——Java基础篇（三）</title>
    <link href="/2023/06/18/Java%E5%8F%8D%E5%B0%84%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/06/18/Java%E5%8F%8D%E5%B0%84%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射就是把java类中的各种成分映射成一个个的Java对象。在了解反射机制之前我们需要先明白Class类这个概念。</p><h2 id="反射优点和缺点"><a href="#反射优点和缺点" class="headerlink" title="反射优点和缺点"></a>反射优点和缺点</h2><p>优点：可以动态的创建和使用对象，使用灵活，反射机制是框架的灵魂。</p><p>缺点：使用反射基本上是解释执行，对执行速度有影响。</p><h2 id="反射调优"><a href="#反射调优" class="headerlink" title="反射调优"></a>反射调优</h2><p>反射调用优化-关闭访问检查</p><p>Method和Field、Constructor对象都有setAccessible()方法，通过设置访问安全检查的开关实现关闭访问检查，参数值为true是关闭访问检查。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><ul><li>Class类是一个实实在在的类，存在于JDK的java.lang包中。</li><li>Class对象表示某个类加载在堆中的对象。</li><li>Class类对象不是new出来的，而是系统创建出来的。</li><li>对于某个类的Class类对象，在内存中只有一份，因为类加载只发生一次。</li><li>每个Java类实例都会记得自己是由哪一个Class实例生成。</li><li>通过Class对象可以完整的得到一个类的完整结构，也就是通过Class类对象去创建对象、Method、Constructor、Field类对象，通过一系列API来操作类。</li><li>类的字节码二进制数据是存放在方法区的，</li><li>Class类对象创建和new对象是一样的都是通过ClassLoader类加载。</li></ul><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><ol><li><p><strong>前提</strong>：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获得，可能会抛出<code>ClassNotFoundException</code>。</p><p> <strong>实例</strong>：<code>Class cls=Class.forName(&quot;java.lang.Cat&quot;);</code></p><p> <strong>应用场景</strong>：多用于配置文件，读取类全路径，加载类。</p></li><li><p><strong>前提</strong>：若已知具体的类，通过类的class获得，该方式最为安全可靠，程序性能最高。</p><p> <strong>实例</strong>：<code>Class cls2=Cat.class;</code></p><p> <strong>应用场景</strong>：对用于参数传递，比如通过反射得到对应构造器对象。</p></li><li><p><strong>前提</strong>：已知某个类的实例，调用该类的getClass()方法获取Class对象。</p><p> <strong>实例</strong>：Class cls3=对象。getClass();</p><p> <strong>应用场景</strong>：通过创建好的对象，获取Class对象。</p></li><li><p><strong>其他方法</strong>：</p><p> ClassLoader cl=对象.getClass().getClassLoader();</p><p> Class cls=cl.loadClass(“类的全类名”)；</p></li></ol><p><img src="/../images/image-20230111225922995-1687074638374.png" alt="image-20230111225922995"></p><p>如下类型有Class对象：</p><p><img src="/../images/image-20230111230013149-1687074638374.png" alt="image-20230111230013149"></p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。</p><ul><li><p>静态加载：编译时加载相关的类，如果则报错，依赖性太强。</p></li><li><p>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性。</p>  <img src="../../../../../相册/typora/image-20230111231713708.png" alt="image-20230111231713708" style="zoom: 67%;" /></li></ul><p>类加载过程图：</p><p><img src="/../images/image-20230111231015989-1687074638374.png" alt="image-20230111231015989"></p><p><img src="/../images/image-20230111231901886-1687074638375.png" alt="image-20230111231901886"></p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>JVM在该阶段的主要目的时将字节码从不同的数据源（可能是class文件、jar包、网络文件）转化成二进制字节流加载到内存中，并生成一个代表该类的Class对象。</p><h3 id="连接阶段-验证"><a href="#连接阶段-验证" class="headerlink" title="连接阶段-验证"></a>连接阶段-验证</h3><ul><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。</li><li>验证包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证、字节码验证和符号引用验证。</li><li><strong>注意</strong>：可以用-Xverify：none参数来关闭大部分的类验证措施，缩短虚拟机加载时间。</li></ul><h3 id="连接阶段-准备"><a href="#连接阶段-准备" class="headerlink" title="连接阶段-准备"></a>连接阶段-准备</h3><p>JVM会在该阶段对静态变量，分配内存并且默认初始化（如：0，0L，null，false等）。这些变量所使用的内存都将在方法区中进行分配。</p><p><strong>注意</strong>：实例变量在这个阶段不会分配内存，静态变量会分配内存并且默认初始值（这个初始化不是给静态变量赋值，真正的赋值是在初始化阶段），static final静态常量在这个阶段会初始化，也就是赋值就不变了。</p><h3 id="连接阶段-解析"><a href="#连接阶段-解析" class="headerlink" title="连接阶段-解析"></a>连接阶段-解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>此阶段才是真正的执行类中定义的Java程序代码，此阶段是执行&lt;clinit&gt;方法的过程。</li><li>&lt;clinit&gt;方法是由编译器按语句出现的顺序，依次将类中的所有静态变量的赋值和静态代码块的合并。</li><li>JVM会保证一个类的&lt;clinit&gt;方法在多线程的环境下被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个方法，其他线程需要阻塞等待，直到线程执行完毕。</li></ul><h2 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a>通过反射获取类的结构信息</h2><h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>forName()</td><td>(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。</td></tr><tr><td></td><td>(2)为了产生Class引用，forName()立即就进行了初始化。</td></tr><tr><td>Object-getClass()</td><td>获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td></tr><tr><td>getName()</td><td>得到<strong>全类名</strong>，即类的完整名字。</td></tr><tr><td>getSimpleName()</td><td>获取类名(<strong>不包括包名</strong>)</td></tr><tr><td>getCanonicalName()</td><td>获取全限定的类名(包括包名)</td></tr><tr><td>isInterface()</td><td>判断Class对象是否是表示一个接口</td></tr><tr><td>getInterfaces()</td><td>返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td></tr><tr><td>getSupercalss()</td><td>返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td></tr><tr><td>newInstance()</td><td>返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td></tr><tr><td>getFields()</td><td>获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。</td></tr><tr><td>getDeclaredFields</td><td>获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。</td></tr></tbody></table><p><strong>getName、getCanonicalName与getSimpleName的区别</strong>：</p><ul><li><code>getSimpleName</code>：只获取类名</li><li><code>getName</code>：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如<code>Class.forName</code>。</li><li><code>getCanonicalName</code>：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。</li></ul><h3 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h3><p>Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。</p><p>获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>static Class&lt;?&gt;</td><td>forName(String className)</td><td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td></tr><tr><td>Constructor</td><td>getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、具有public访问权限的构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getConstructors()</td><td>返回所有具有public访问权限的构造函数的Constructor对象数组</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、所有声明的（包括private）构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getDeclaredConstructors()</td><td>返回所有声明的（包括private）构造函数对象</td></tr><tr><td>T</td><td>newInstance()</td><td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td></tr></tbody></table><p><strong>Constructor类本身一些常用方法</strong>如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Class</td><td>getDeclaringClass()</td><td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td></tr><tr><td>String</td><td>getName()</td><td>以字符串形式返回此构造方法的名称。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td></tr><tr><td>T</td><td>newInstance(Object… initargs)</td><td>使用此 Constructor对象表示的构造函数来创建新实例</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Constructor 的字符串，其中包括类型参数。</td></tr></tbody></table><h3 id="Field类及其用法"><a href="#Field类及其用法" class="headerlink" title="Field类及其用法"></a>Field类及其用法</h3><p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p><p>Class类与Field对象相关方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Field</td><td>getDeclaredField(String name)</td><td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td></tr><tr><td>Field[]</td><td>getDeclaredFields()</td><td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td></tr><tr><td>Field</td><td>getField(String name)</td><td>获取指定name名称、具有public修饰的字段，包含继承字段</td></tr><tr><td>Field[]</td><td>getFields()</td><td>获取修饰符为public的字段，包含继承字段</td></tr></tbody></table><p><strong>注意</strong>：如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField/getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField/getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。</p><p>Field类还有其他常用的方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>void</td><td>set(Object obj, Object value)</td><td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td></tr><tr><td>Object</td><td>get(Object obj)</td><td>返回指定对象上此 Field 表示的字段的值</td></tr><tr><td>Class&lt;?&gt;</td><td>getType()</td><td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td></tr><tr><td>boolean</td><td>isEnumConstant()</td><td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回一个描述此 Field（包括其一般类型）的字符串</td></tr><tr><td>String</td><td>getName()</td><td>返回此 Field 对象表示的字段的名称</td></tr><tr><td>Class&lt;?&gt;</td><td>getDeclaringClass()</td><td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td></tr><tr><td>void</td><td>setAccessible(boolean flag)</td><td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td></tr></tbody></table><p>上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如<code>setInt()/getInt()</code>、<code>setBoolean()/getBoolean</code>、<code>setChar()/getChar()</code>等等方法。</p><h3 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h3><p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。</p><p>Class类获取Method对象相关的方法：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>Method[]</td><td>getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td>Method</td><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>Method[]</td><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr></tbody></table><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Object</td><td>invoke(Object obj, Object… args)</td><td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td></tr><tr><td>Class&lt;?&gt;</td><td>getReturnType()</td><td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td></tr><tr><td>Type</td><td>getGenericReturnType()</td><td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td></tr><tr><td>String</td><td>getName()</td><td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td></tr><tr><td>boolean</td><td>isVarArgs()</td><td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Method 的字符串，包括类型参数。</td></tr></tbody></table><p><code>getReturnType方法/getGenericReturnType方法</code>都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Type</span> &#123;<br>    <span class="hljs-comment">//1.8新增</span><br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">getTypeName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>getParameterTypes/getGenericParameterTypes</code>也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。</p><h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h2><ol><li>调用类中public无参构造器</li><li>调用类中指定构造器</li><li>Class类的相关方法<ul><li>newInstance：调用类中无参构造器，获取对应类的对象。</li><li>getConstructor(Class cls)：根据参数列表，获取对应的public构造器对象。</li><li>getDecalaredConstructor(Class cls)：根据参数列表，获取对应的所有构造器。</li></ul></li><li>Constructor类相关方法<ul><li>setAccessible：暴破</li><li>newInstance(Object obj)：调用构造器</li></ul></li></ol><p><strong>使用例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 先获取到 User 类的 Class 对象</span><br>Class&lt;?&gt; userClass = Class.forName(<span class="hljs-string">&quot;com.hspedu.reflection.User&quot;</span>);<br><span class="hljs-comment">//2. 通过 public 的无参构造器创建实例</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> userClass.newInstance();<br>System.out.println(o);<br><span class="hljs-comment">//3. 通过 public 的有参构造器创建实例</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">constructor 对象就是</span><br><span class="hljs-comment">public User(String name) &#123;//public 的有参构造器</span><br><span class="hljs-comment">this.name = name;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//3.1 先得到对应构造器</span><br>Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);<br><span class="hljs-comment">//3.2 创建实例，并传入实参</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">hsp</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;hsp&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;hsp=&quot;</span> + hsp);<br><span class="hljs-comment">//4. 通过非 public 的有参构造器创建实例</span><br><span class="hljs-comment">//4.1 得到 private 的构造器对象</span><br>Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="hljs-type">int</span>.class, String.class);<br><span class="hljs-comment">//4.2 创建实例</span><br><span class="hljs-comment">//暴破【暴力破解】 , 使用反射可以访问 private 构造器/方法/属性, 反射面前，都是纸老虎</span><br>constructor1.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> constructor1.newInstance(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;张三丰&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;user2=&quot;</span> + user2);<br></code></pre></td></tr></table></figure><h3 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h3><p><img src="/../images/image-20230112002408993-1687074638375.png" alt="image-20230112002408993"></p><p><img src="/../images/image-20230112002419569-1687074638375.png" alt="image-20230112002419569"></p><h2 id="反射调用流程（具体内容看java全栈知识体系，待补充学习）"><a href="#反射调用流程（具体内容看java全栈知识体系，待补充学习）" class="headerlink" title="反射调用流程（具体内容看java全栈知识体系，待补充学习）"></a>反射调用流程（具体内容看java全栈知识体系，待补充学习）</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型全解——Java基础篇（二）</title>
    <link href="/2023/06/18/Java%E6%B3%9B%E5%9E%8B%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/06/18/Java%E6%B3%9B%E5%9E%8B%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的用处"><a href="#泛型的用处" class="headerlink" title="泛型的用处"></a>泛型的用处</h2><p>意义：适用于多种数据类型执行相同的代码。泛型主要的用途就是代码复用。</p><p>本质：泛型的本质是为了参数化类型，也就是通过泛型指定不同的类型来控制形参具体限制的类型。在使用中，操作的类型被指定为一个具体的参数，可以用在类、接口、方法中，被称为泛型类、泛型接口、泛型方法。</p><h3 id="用处一：减少代码的复用"><a href="#用处一：减少代码的复用" class="headerlink" title="用处一：减少代码的复用"></a>用处一：减少代码的复用</h3><p>减少代码的复用就是对于不同的数据类型，我们可以通过泛型的方式来复合的定义一个方法。</p><h3 id="用处二：不需要强制转换"><a href="#用处二：不需要强制转换" class="headerlink" title="用处二：不需要强制转换"></a>用处二：不需要强制转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>list.add(<span class="hljs-string">&quot;xxString&quot;</span>);<br>list.add(<span class="hljs-number">100d</span>);<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<br></code></pre></td></tr></table></figure><p>如上的代码，如果按照这样的写法，会出现list元素的对象都是Object对象，所以当我们需要取其中的某一个元素时，我们需要将其强制转化为对应的类型，就会出现java.lang.ClassCastException的异常。</p><h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&lt;T&gt;&#123;         <span class="hljs-comment">// 此处可以随便写标识符号，T是type的简称  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;     <span class="hljs-comment">// var的类型由T指定，即：由外部指定  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 返回值的类型由外部决定  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <span class="hljs-comment">// 设置的类型也由外部决定  </span><br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="多元泛型"><a href="#多元泛型" class="headerlink" title="多元泛型"></a>多元泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="hljs-comment">// 此处指定了两个泛型类型  </span><br>    <span class="hljs-keyword">private</span> K key ;     <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">private</span> V value ;   <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(K key)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.key = key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.value = value ;  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;        <span class="hljs-comment">// 在接口上定义泛型  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span> ; <span class="hljs-comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>  定义泛型方法</li></ul><p><img src="https://www.pdai.tech/images/java/java-basic-generic-4.png" alt="img"></p><ul><li>  方法调用</li></ul><p><img src="https://www.pdai.tech/images/java/java-basic-generic-5.png" alt="img"></p><p><strong>为什么要用变量c来创建对象呢？</strong></p><p>既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p><h3 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h3><p>为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<code>&lt;? extends A&gt;</code>表示该类型参数可以是A(上边界)或者A的子类类型。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>  <?> 无限制通配符 </li><li>  <? extends E>extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类 。</li><li>  <? super E>super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类 </li></ul><p> <strong>使用原则《Effictive Java》：</strong></p><ul><li>  为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</li><li>  如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;</li><li>  如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;； </li><li>  如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</li></ul><h4 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span>  &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> E&gt;&gt; E <span class="hljs-title function_">max</span><span class="hljs-params">(List&lt;? extends E&gt; e1)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e1 == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//迭代器返回的元素属于 E 的某个子类型</span><br>    Iterator&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">E</span>&gt; iterator = e1.iterator();<br>    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iterator.next();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>        <span class="hljs-keyword">if</span> (next.compareTo(result) &gt; <span class="hljs-number">0</span>)&#123;<br>            result = next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中E的参数范围是<code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code>。以下进行分析：</p><ul><li><p>  首先E是可以进行比较的类所以需要 <code>extends Comparable&lt;…&gt;</code></p></li><li><p>  <code>Comparable&lt; ? super E&gt;</code> 要对 E 进行比较，即 E 的消费者，所以需要用 super</p></li><li><p>  而参数 <code>List&lt; ? extends E&gt;</code> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大</p></li></ul><h4 id="多个限制"><a href="#多个限制" class="headerlink" title="多个限制"></a>多个限制</h4><p>多个限制只用&amp;符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Staff</span>&amp;Passenger&gt;<br></code></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] list11 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误，非法创建 </span><br>List&lt;String&gt;[] list12 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误，需要强转类型 </span><br>List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK，但是会有警告 </span><br>List&lt;?&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误，非法创建 </span><br>List&lt;?&gt;[] list15 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK </span><br>List&lt;String&gt;[] list6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK，但是会有警告</span><br></code></pre></td></tr></table></figure><h4 id="合理使用"><a href="#合理使用" class="headerlink" title="合理使用"></a>合理使用</h4>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多态全解——Java基础篇（一）</title>
    <link href="/2023/06/18/Java%E5%A4%9A%E6%80%81%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/06/18/Java%E5%A4%9A%E6%80%81%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态分为编译时多态和运行时多态:</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>在这里我们只要讲的是运行时多态。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>继承</li><li>要有方法的重写</li><li>父类引用指向子类对象：Animal a=new Cat();（向上转型）</li><li>多态中，编译看左，运行看右</li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.tedu.oop2;<br><span class="hljs-comment">/*本类用作多态的入门案例*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//Cat类对象的地址值交给父类型变量a2来保存</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//Dog类对象的地址值交给父类型变量a3来保存</span><br>        <span class="hljs-comment">//8.测试多态对象</span><br>        <span class="hljs-comment">/*4.口诀2：编译看左边，运行看右边</span><br><span class="hljs-comment">        * 解释：必须要在父类定义这个方法，才能通过编译，把多态对象看作是父类类型</span><br><span class="hljs-comment">        *      必须要在子类重写这个方法，才能满足多态，实际干活的是子类*/</span><br>        a2.eat();<span class="hljs-comment">//小猫爱吃小鱼干~，多态对象使用的是父类的定义，子类的方法体</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*1.多态的前提：继承+重写*/</span><br><span class="hljs-comment">//1.创建父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//3.创建父类的普通方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小动物Animal吃啥都行~&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//2.1创建子类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//4.1添加重写的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小猫爱吃小鱼干~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5.1添加子类的特有功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jump</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小猫Cat跳的老高啦~&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//2.2创建子类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//4.2添加重写的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小狗爱吃肉骨头~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5.2添加子类的特有功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小狗Dog跑的老快啦~&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><ol><li>多态可以让我们不用关心某个对象到底具体是什么类型,就可以使用该对象的某些方法，也就是不用关心子类的具体方法，而是把子类看成父类进行使用。</li><li>提高了程序的可扩展性和可维护性</li><li>多态可以统一调用标准</li></ol><h2 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h2><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p><strong>本质</strong>：父类的引用指向子类对象。</p><p><strong>语法</strong>：父类类型 引用名 = new 子类类型()；</p><p><strong>特点</strong>：编译类型看左边，运行类型看右边。可以调用父类中的所有成员（须遵守访问权限），不能调用子类中特有成员，最终运行效果看子类的具体实现。</p><h3 id="向下转型（很少）"><a href="#向下转型（很少）" class="headerlink" title="向下转型（很少）"></a>向下转型（很少）</h3><p>语法：子类类型 引用名 = (子类类型) 父类引用；</p><p>特点：只能强转父类的引用，不能强转父类对象；要求父类的引用必须指向的是当前目标类型的对象；当向下转型后，可以调用子类类型中的所欲成员。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树解析</title>
    <link href="/2023/06/15/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/06/15/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>红黑树是平衡二叉树的一种，可以保证在最坏的情况下基本动态集合操作的时间复杂度为O(lgn)。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>红黑树的每个节点包含有5个属性，color、key、left、right、parent。</p><p>红黑树满足的性质：</p><p>（1）每个节点或者是黑色，或者是红色。</p><p>（2）根节点是黑色。</p><p>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p><p>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</p><p>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><p><img src="/../images/251730074203156.jpg" alt="img"></p><p>引理：一棵有n个内部节点的红黑树的高度至多为2lg(n+1)</p><p>通过这个引理可以知道，动态集合操作SEACHER、MINIMUM、MAXIMUM、SUCCESSOR、PREDECESSOR都可以在O(lgn)时间内操作。</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转的实现代码和平衡二叉树很相似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 左旋</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(RBTNode&lt;T&gt; x)</span>&#123;<br>    <span class="hljs-comment">//y指向x的右孩子，之后用来交换两个位置</span><br>    RBTNode&lt;T&gt; y=x.right;<br>    x.right=y.left;<br>    <span class="hljs-comment">//如果y的左孩子不为空，那么左孩子的父节点就是x。</span><br>    <span class="hljs-keyword">if</span>(y.left!=<span class="hljs-literal">null</span>)&#123;<br>        y.left.parent=x;<br>    &#125;<br>    y.parent=x.parent;<br>    <span class="hljs-keyword">if</span>(x.parent==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-built_in">this</span>.mRoot=y;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//通过分析x是父节点的左孩子还是右孩子来判断y应该是什么孩子。</span><br>        <span class="hljs-keyword">if</span>(x.parent.left==x)x.parent.left=y;<br>        <span class="hljs-keyword">if</span>(x.parent.right==x)x.parent.right=y;<br><br>    &#125;<br>    y.left=x;<br>    x.parent=y;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 右旋，右旋的实现和左旋差不多。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(RBTNode&lt;T&gt; y)</span>&#123;<br>    <span class="hljs-comment">//y是x的父节点</span><br>    RBTNode&lt;T&gt; x=y.left;<br>    <span class="hljs-comment">//将x的右节点变成y的左节点。</span><br>    y.left=x.right;<br>    <span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>)&#123;<br>        x.right.parent=y;<br>    &#125;<br>    x.parent=y.parent;<br>    <span class="hljs-keyword">if</span>(y.parent==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-built_in">this</span>.mRoot=x;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(y.parent.left==y)y.parent.left=x;<br>        <span class="hljs-keyword">if</span>(y.parent.right==y)y.parent.right=x;<br>    &#125;<br>    x.right=y;<br>    y.parent=x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>关于红黑树的插入，就需要考虑不同种情况了。主要就是三步：</p><p>1、将红黑树当作一棵不同的二叉查找树，将节点插入。</p><p>2、将插入的节点着色为“红色”。</p><p>3、通过一系列旋转或者着色操作，使之重新称为一棵红黑树</p><p>众所周知，红黑树的具有5条性质，我们在插入的时候就是可以通过分析将新的节点插入后并且着色为红色，让哪几条性质失效了。</p><p>以下是具体分析：</p><ul><li>  第一步：将红黑树当作一棵二叉树的节点，插入到二叉树中。</li><li>  第二步：将插入的节点着色为红色。当着色红色的时候，不会违背第5条性质。</li><li>  第三步：对于性质1，3性质都不会违背，也就只有2、4性质会违背。违背的情况就是如果插入的z是根节点，那么就违背了2，如果z的父节点是红，就违背了性质4。</li></ul><p>首先，我们先把添加节点的代码写好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 插入操作</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(RBTNode&lt;T&gt; node)</span> &#123;<br>       RBTNode&lt;T&gt; y = <span class="hljs-literal">null</span>;<br>       RBTNode&lt;T&gt; x = <span class="hljs-built_in">this</span>.mRoot;<br>       <span class="hljs-keyword">while</span> (x != <span class="hljs-literal">null</span>) &#123;<br>           y = x;<br>           <span class="hljs-keyword">if</span> (node.key.compareTo(x.key) &lt; <span class="hljs-number">0</span>) &#123;<br>               x = x.left;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               x = x.right;<br>           &#125;<br>       &#125;<br>       node.parent = y;<br>       <span class="hljs-keyword">if</span> (y == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-built_in">this</span>.mRoot = node;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">if</span> (node.key.compareTo(y.key) &lt; <span class="hljs-number">0</span>) &#123;<br>               node.left = y;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               node.right = y;<br>           &#125;<br>       &#125;<br>       node.left = <span class="hljs-literal">null</span>;<br>       node.right = <span class="hljs-literal">null</span>;<br>       node.color = RED;<br>       insertFixUp(node);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T key)</span> &#123;<br>       RBTNode&lt;T&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RBTNode</span>&lt;&gt;(key, BLACK, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>       <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>           insert(node);<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>然后这个时候红黑树会因为插入一个红节点而破坏原有的结构，我们对其进行插入修正操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 插入修正</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFixUp</span><span class="hljs-params">(RBTNode&lt;T&gt; node)</span> &#123;<br>       RBTNode&lt;T&gt; parent, gparent, uncle;<br>       <span class="hljs-keyword">while</span> (node.parent != <span class="hljs-literal">null</span> &amp;&amp; node.parent.color == RED) &#123;<br>           parent = node.parent;<br>           gparent = parent.parent;<br>           <span class="hljs-comment">//当父节点是祖父节点的左孩子</span><br>           <span class="hljs-keyword">if</span> (parent == gparent.left) &#123;<br>               uncle = gparent.right;<br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               case1:叔节点为red的时候，进行以下操作：</span><br><span class="hljs-comment">               1、将父节点变黑</span><br><span class="hljs-comment">               2、将叔叔节点变黑</span><br><span class="hljs-comment">               3、将祖父节点变红</span><br><span class="hljs-comment">               4、将祖父节点变成现在的节点</span><br><span class="hljs-comment">                */</span><br>               <span class="hljs-keyword">if</span> (uncle != <span class="hljs-literal">null</span> &amp;&amp; uncle.color == RED) &#123;<br>                   parent.color = BLACK;<br>                   uncle.color = BLACK;<br>                   gparent.color = RED;<br>                   node = gparent;<br>               &#125;<br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               case2:叔叔是黑色，且当前是右孩子。</span><br><span class="hljs-comment">               1、将父节点作为当前节点。</span><br><span class="hljs-comment">               2、以新的节点作为支点进行左旋。</span><br><span class="hljs-comment">                */</span><br>               <span class="hljs-keyword">if</span>(node==parent.right)&#123;<br>                   node=parent;<br>                   leftRotate(node);<br>               &#125;<br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               case3:叔叔是黑色，且当前是左孩子。</span><br><span class="hljs-comment">               1、将父节点变黑</span><br><span class="hljs-comment">               2、将祖父节点变为红色</span><br><span class="hljs-comment">               3、以祖父节点进行右旋</span><br><span class="hljs-comment">                */</span><br>               <span class="hljs-keyword">if</span>(node==parent.left)&#123;<br>                   parent.color=BLACK;<br>                   gparent.color=RED;<br>                   rightRotate(gparent);<br>               &#125;<br><br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               uncle = gparent.left;<br>               <span class="hljs-keyword">if</span> (uncle != <span class="hljs-literal">null</span> &amp;&amp; uncle.color == RED) &#123;<br>                   parent.color = BLACK;<br>                   uncle.color = BLACK;<br>                   gparent.color = RED;<br>                   node = gparent;<br>               &#125;<br>               <span class="hljs-keyword">if</span>(node==parent.left)&#123;<br>                   node=parent;<br>                   rightRotate(node);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(node==parent.right)&#123;<br>                   parent.color=BLACK;<br>                   gparent.color=RED;<br>                   leftRotate(gparent);<br>               &#125;<br><br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>待补充。。。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章搞懂HashMap</title>
    <link href="/2023/06/15/HashMap%E5%85%A8%E8%A7%A3/"/>
    <url>/2023/06/15/HashMap%E5%85%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="从应用到底层看破HashMap（源码精讲一）"><a href="#从应用到底层看破HashMap（源码精讲一）" class="headerlink" title="从应用到底层看破HashMap（源码精讲一）"></a>从应用到底层看破HashMap（源码精讲一）</h1><blockquote><p>  作为面试中最喜欢考察的知识点之一和在实际中最常用到的Map集合，HashMap为什么这么让人着谜，对应的数据结构是什么，有哪些具体的应用场景，底层的实现逻辑是什么？下文的分析和源码都是来自于JDK8。</p></blockquote><h2 id="HashMap是什么"><a href="#HashMap是什么" class="headerlink" title="HashMap是什么"></a>HashMap是什么</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>HashMap是Java程序员使用频率最高的键值对集合，对应着哈希表这一数据结构，在学习HashMap之前，我们需要先复习一下哈希表的一些概念。</p><p>哈希表相较于其他数据结构，得力于它的添加、删除、查找等功能的性能强大，我们常用的Redis非关系型数据库就是利用典型的键值对的数据结构存储（怪不得Redis这么好用）。在不考虑哈希冲突的情况下，只需要时间复杂度为O(1)就能够定位。</p><p>但是哈希表有一个非常窒命的问题就是哈希冲突，解决哈希冲突有两个方法，一是开放寻址法（ThreadLocal就是利用这个，先挖一个坑），另一种就是我们今天要讲的HashMap的实现方法——链地址法。</p><h3 id="Map大家族"><a href="#Map大家族" class="headerlink" title="Map大家族"></a>Map大家族</h3><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/f7fe16a2.png" alt="Map大家庭"></p><p>从上面的图中我们可以看到，在Java.util.Map接口下，有四个常用的类，分别是HashMap、HashTable、LinkedHashMap、TreeMap。</p><p>下面讲一下它们之间的区别吧：</p><ul><li>  <strong>HashMap</strong>：根据键的hashcode来存储数据，访问速度快，但是遍历顺序不确定。HashMap是线程不安全的，下文会具体的介绍为什么线程不安全，如何需要满足线程安全， 可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li>  <strong>HashTable</strong>：已经被淘汰可以不进行学习和使用。</li><li>  <strong>LinkedHashMap</strong>：是HashMap的一个子类，但是记录了插入的顺序，只要记住这一点就可以了。</li><li>  <strong>TreeMap</strong>：TreeMap实现了SortedMap接口，能将所有的记录根据key进行排序。默认升序。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ul><p>所以通过上面的介绍，大概就有了一个知识图谱，如果是需要线程安全就需要使用concurrentHashMap，如果需要记录记录顺序则使用linkedHashMap。如果需要key是有序的，则需要TreeMap。</p><h2 id="HashMap应用场景"><a href="#HashMap应用场景" class="headerlink" title="HashMap应用场景"></a>HashMap应用场景</h2><p>HashMap的使用场景就是如果你需要使用到键值对，并且需要非常高效的搜索能力的时候，例如存储用户信息、缓存、字段，但是HashMap线程不安全，这个需要注意一下。</p><h2 id="HashMap的重要方法"><a href="#HashMap的重要方法" class="headerlink" title="HashMap的重要方法"></a>HashMap的重要方法</h2><ul><li><p>创建HashMap对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String,Integer&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li><li><p>添加元素(put)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.put(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-number">123</span>);<br>hashMap.put(<span class="hljs-string">&quot;234&quot;</span>,<span class="hljs-number">234</span>);<br></code></pre></td></tr></table></figure></li><li><p>删除元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.remove(<span class="hljs-string">&quot;123&quot;</span>);<br>hashMap.remove(<span class="hljs-string">&quot;234&quot;</span>,<span class="hljs-number">234</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取元素</p><ul><li>  get()</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.get(<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>  getOrDefault()</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getOrDefault(<span class="hljs-string">&quot;123&quot;</span>,-<span class="hljs-number">1</span>);<span class="hljs-comment">//如果123不存在默认返回-1</span><br></code></pre></td></tr></table></figure></li><li><p>元素遍历(推荐写法)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator1</span> <span class="hljs-operator">=</span> hashMap.entrySet().iterator();<br>        <span class="hljs-keyword">while</span> (iterator1.hasNext())&#123;<br>            Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) iterator1.next();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (String) entry.getKey();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (Integer) entry.getValue();<br>            System.out.println(key+<span class="hljs-string">&quot;=&quot;</span>+value);<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>判断key或者value是否存在</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.containKey(<span class="hljs-string">&quot;123&quot;</span>);<br>hashMap.containValue(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure></li><li><p>替换元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.replace(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-number">34</span>);<span class="hljs-comment">//如果key不存在，则不处理。</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="HashMap底层实现（代码全解）"><a href="#HashMap底层实现（代码全解）" class="headerlink" title="HashMap底层实现（代码全解）"></a>HashMap底层实现（代码全解）</h2><p>在HashMap中，最主要的就是三个方法的实现，分别是put、get、resize。下面我就对其三个方法的源码进行深入的分析。</p><h3 id="put方法详解"><a href="#put方法详解" class="headerlink" title="put方法详解"></a>put方法详解</h3><p>首先我们先看put的实现：</p><p><img src="/../images/d669d29c.png" alt="put实现流程"></p><p>上面是完整的put实现。其中有一些重要的属性：table是哈希桶表；threshold表示扩容的阈值；loadFactor表示的是负载因子。</p><p><strong>总的逻辑过程如下：</strong></p><ol><li> 判断table是否是空，如果为空，则进行resize</li><li> 根据键值计算插入的数组索引i。</li><li> 如果table[i]是null则直接插入，如果不是null，则查询key是否已经存在，如果存在则直接覆盖。</li><li> 如果key不存在，则考虑是否是红黑树，如果是红黑树，则直接插入红黑树中。</li><li> 如果不是红黑树，则插入链表</li><li> 判断链表长度是否大于8，如果大于8，转换成红黑树。</li><li> 若不大于8，则直接插入，如果key存在，则直接覆盖。</li><li> 最后判断是否到达阈值，如果到达阈值，则进行resize。</li></ol><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<span class="hljs-comment">//tab是记录哈希表的数组</span><br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<span class="hljs-comment">//如果当前的table是null，或者数组的长度是0，则创建一个数组</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<span class="hljs-comment">//通过hash值去确定插入数组的索引i，如果该索引上为空，则直接插入值。</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<span class="hljs-comment">//如果该索引不为空</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<span class="hljs-comment">//如果key已经存在，则直接覆盖node</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<span class="hljs-comment">//如果key不存在，判断是否是红黑树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<span class="hljs-comment">//是红黑树，直接插入</span><br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果不是红黑树，而是链表，那么循环插入。</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<span class="hljs-comment">//如果下一个node为空，插入</span><br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<span class="hljs-comment">//如果链表的长度大于8，则将链表变成红黑树</span><br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<span class="hljs-comment">//如果key已经存在则直接覆盖value。</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<span class="hljs-comment">//如果超过了最大值，扩容</span><br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//resize函数就是复制旧数组到新数组。</span><br></code></pre></td></tr></table></figure><p>关于红黑树的实现我会在红黑树详解中介绍该HashMap中的红黑树实现，具体请跳转<a href="/2023/06/15/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%A7%A3%E6%9E%90/" title="红黑树解析">红黑树解析</a></p><h3 id="get方法详解"><a href="#get方法详解" class="headerlink" title="get方法详解"></a>get方法详解</h3><p>对于哈希表来说，不管是查询、增加还是删除，快速定位到元素的位置是非常重要的。前面说到了HashMap是通过数组+链表进行存储的（这里先考虑JDK1.7，因为原理是一样的）。在哈希表中，要提高查询的速度，最好数组中的每个位子都只有一个元素。但是这样子的话就会要求元素之间要足够离散。如果一个哈希表太小，算法再强也没有用；但是如果哈希表过大，造成了空间的浪费也不是好的设计。这里我们可以学习一下HashMap的设计。</p><p><strong>先看看源码（jdk1.7和jdk1.8）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;   <span class="hljs-comment">//jdk1.8 &amp; jdk1.7</span><br>     <span class="hljs-type">int</span> h;<br>     <span class="hljs-comment">// h = key.hashCode() 为第一步 取hashCode值</span><br>     <span class="hljs-comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br>     <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;  <span class="hljs-comment">//jdk1.7的源码</span><br>     <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);  <span class="hljs-comment">//第三步 取模运算</span><br>&#125;<br><br>tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]<br><span class="hljs-comment">//jdk1.8的源码，putVal中的寻址方式</span><br></code></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p><p><strong>取hashcode</strong>就是非常常规的，这里我讲一下HashMap或者所有的Map类型的数据结构是怎么进行寻址和插入以及删除操作的，其实核心就是如果一样的key，就会生成一样的hashcode，一样的hashcode就会生成一样的hash值，一样的hash值就可以找到一样的索引，然后就可以定位到元素。</p><p>在JDK1.8的实现中，优化了<strong>高位运算</strong>的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。以下是1.7中hash算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hashSeed;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>    &#125;<br>    <span class="hljs-comment">// key的hashcode会和hash seed做与运算</span><br>    h ^= k.hashCode();<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>1.7和1.8得到的值<strong>既包含了自己高位的特性又包含了自己低位的特性</strong>，从而增加了之后得到的下标的不确定性，降低了碰撞的概率。</p><p><img src="/../images/1460000022059146" alt="hash算法实现"></p><p><strong>计算下标：</strong></p><p>在这里的算法真的是惊艳，对应下面的面试题，详细见下边。</p><h3 id="resize方法详解"><a href="#resize方法详解" class="headerlink" title="resize方法详解"></a>resize方法详解</h3><p>因为在JDK1.8中，使用的是红黑树的存储方式，实现起来较为复杂，所以我们先看看在JDK1.7中是如何实现resize这个方法的。</p><p><strong>JDK1.7源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;   <span class="hljs-comment">//传入新的容量</span><br>     Entry[] oldTable = table;    <span class="hljs-comment">//引用扩容前的Entry数组</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;         <br>     <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="hljs-comment">//扩容前的数组大小如果已经达到最大(2^30)了</span><br>         threshold = Integer.MAX_VALUE; <span class="hljs-comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br>         <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>     Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];  <span class="hljs-comment">//初始化一个新的Entry数组</span><br>   transfer(newTable);                         <span class="hljs-comment">//！！将数据转移到新的Entry数组里</span><br>    table = newTable;                           <span class="hljs-comment">//HashMap的table属性引用新的Entry数组</span><br>   threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);<span class="hljs-comment">//修改阈值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable)</span> &#123;<br>    Entry[] src = table;                   <span class="hljs-comment">//src引用了旧的Entry数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123; <span class="hljs-comment">//遍历旧的Entry数组</span><br>        Entry&lt;K,V&gt; e = src[j];             <span class="hljs-comment">//取得旧Entry数组的每个元素</span><br>       <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>           src[j] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span><br>           <span class="hljs-keyword">do</span> &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity); <span class="hljs-comment">//！！重新计算每个元素在数组中的位置</span><br>               e.next = newTable[i]; <span class="hljs-comment">//标记[1]</span><br>               newTable[i] = e;      <span class="hljs-comment">//将元素放在数组上</span><br>               e = next;             <span class="hljs-comment">//访问下一个Entry链上的元素</span><br>             &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>);<br>         &#125;<br>     &#125;<br> &#125; <br></code></pre></td></tr></table></figure><p>上面就是在1.7中的关键代码，其中resize就是修改阈值和引用transfer函数，内核的交换新旧数组的函数其实是transfer，在transfer中，可以看到标记1这个地方是一个非常明显的头插入，扩容以后的数组里的链表是倒序的，这样的设计也是造成JDK1.7有严重问题的原因，当然在JDK1.8中这个问题已经解决了。在JDK1.8已经修改为了尾插入。</p><p>同样看到标记1上面的这一行代码，这里是一个重新计算每个元素在数组中的位置。下面是对于该行代码的优化。</p><p>我们先来分析扩容机制，当数组的存储量已经到达了threshold，也就是阈值以后，我们就需要扩大容量为两倍。那么对于每一个元素而言，在扩容后，根据下标计算公式，只可能会在原位置或者原位置移动2次幂的位置。</p><p><img src="/../images/4d8022db.png" alt="分析扩容后元素下标变化"></p><p>可以看到上面的这个图，其中n-1就是现在数组的容量，现在将数组扩容为2倍，可以发现其实就是对原容量进行左移1位，然后通过indexFor函数进行取模运算，也就是和length-1进行与运算。可以发现运算之后，如果原来的key高位是0，则下标不变，如果原来的key高位是1，则在原位置移动2次幂。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>        Node&lt;K,V&gt;[] oldTab = table;<span class="hljs-comment">//oldTab记录旧数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<span class="hljs-comment">//记录旧容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<span class="hljs-comment">//记录旧的阈值</span><br>        <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果旧容量大于0</span><br>            <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="hljs-comment">//如果大于2^30</span><br>                threshold = Integer.MAX_VALUE;<span class="hljs-comment">//修改阈值到2^31-1</span><br>                <span class="hljs-keyword">return</span> oldTab;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="hljs-comment">//如果新的容量小于最大值或者旧容量大于初始值</span><br>                newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 两倍的阈值</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 旧阈值大于0，赋给新容量</span><br>            newCap = oldThr;<br>        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 初始化</span><br>            newCap = DEFAULT_INITIAL_CAPACITY;<br>            newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//阈值等于0，赋值</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                      (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>        &#125;<br>        threshold = newThr;<span class="hljs-comment">//赋值新的阈值</span><br>        <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>        table = newTab;<span class="hljs-comment">//定义新的table</span><br>        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//接下去就是复制旧数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>                Node&lt;K,V&gt; e;<br>                <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果旧数组中某一索引不为空</span><br>                    oldTab[j] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//这个写法在Java中还是比较常见的，可以学习。</span><br>                    <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                        newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<span class="hljs-comment">//计算新的数组下标</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                        ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                        Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                        Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                        Node&lt;K,V&gt; next;<br>                        <span class="hljs-keyword">do</span> &#123;<br>                            next = e.next;<br>                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//原索引</span><br>                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                    loHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = e;<br>                                loTail = e;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//原索引＋oldCap</span><br>                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                    hiHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = e;<br>                                hiTail = e;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                            loTail.next = <span class="hljs-literal">null</span>;<br>                            newTab[j] = loHead;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                            hiTail.next = <span class="hljs-literal">null</span>;<br>                            newTab[j + oldCap] = hiHead;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newTab;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java编程路线</title>
    <link href="/2023/06/14/Java%E7%BC%96%E7%A8%8B%E8%B7%AF%E7%BA%BF/"/>
    <url>/2023/06/14/Java%E7%BC%96%E7%A8%8B%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Java后端技术体系"><a href="#Java后端技术体系" class="headerlink" title="Java后端技术体系"></a>Java后端技术体系</h1><h2 id="第一部分：Java基础"><a href="#第一部分：Java基础" class="headerlink" title="第一部分：Java基础"></a>第一部分：Java基础</h2><ul><li><p>变量</p></li><li><p>控制结构</p><ul><li>顺序结构</li><li>分支</li><li>循环</li></ul></li><li><p>OOP</p><ul><li>封装</li><li>继承</li><li>多态</li></ul></li><li><p>数组</p></li><li><p>Java API</p></li><li><p>异常处理</p></li><li><p>集合</p></li><li><p>泛型</p></li><li><p>反射</p></li><li><p>网络通信</p></li></ul><h2 id="第二部分：Java高级"><a href="#第二部分：Java高级" class="headerlink" title="==第二部分：Java高级=="></a>==第二部分：Java高级==</h2><h3 id="Java多线程-高并发"><a href="#Java多线程-高并发" class="headerlink" title="Java多线程/高并发"></a>Java多线程/高并发</h3><ul><li>并发基础<ul><li>互斥同步</li><li>非阻塞同步</li><li>指令重排</li><li>synchronized</li><li>volatile</li></ul></li><li>线程</li><li>锁<ul><li>自旋锁</li><li>偏向锁</li><li>可重入锁</li></ul></li><li>线程池</li><li>并发容器</li><li>JUC<ul><li>executor</li><li>collections</li><li>locks</li><li>atomic（原子类）</li><li>tools（CountDownLatch，Exchanger，ThreadLocal，CyclicBarrier）</li></ul></li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul><li>数据结构<ul><li>数组（稀疏数组）</li><li>队列</li><li>栈</li><li>链表</li><li>树</li><li>散列</li><li>堆</li><li>图</li></ul></li><li>算法<ul><li>排序算法（8种）</li><li>查找</li><li>分治算法</li><li>动态规划（背包问题）</li><li>回溯算法（骑士周游问题）</li><li>贪心算法</li><li>KMP</li><li>Prim</li><li>kruskal</li><li>弗洛伊德算法</li><li>迪杰斯特拉算法</li></ul></li></ul><h3 id="设计模式（23种）"><a href="#设计模式（23种）" class="headerlink" title="设计模式（23种）"></a>设计模式（23种）</h3><p>常用的8种：</p><ul><li>单例模式</li><li>观察者模式</li><li>工厂模式</li><li>适配器模式</li><li>装饰者模式</li><li>代理模式</li><li>模板模式</li><li>责任链模式</li><li>其他（桥接模式、原型模式、组合模式）</li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li>JVM体系</li><li>类加载过程/机制</li><li>双亲委派机制/沙箱安全机制</li><li>JMM（Java内存模式）</li><li>字节码执行的过程/机制</li><li>GC(垃圾回收机制)</li><li>JVM性能监控和故障定位</li><li>JVM调优</li></ul><h2 id="第三部分：JavaWeb"><a href="#第三部分：JavaWeb" class="headerlink" title="第三部分：JavaWeb"></a>第三部分：JavaWeb</h2><h3 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h3><ul><li>HTML</li><li>CSS</li><li>Javascript</li><li>Ajax</li><li>Jquery</li></ul><h3 id="前端框架（弱化）"><a href="#前端框架（弱化）" class="headerlink" title="前端框架（弱化）"></a>前端框架（弱化）</h3><ul><li>VUE</li><li>React</li><li>Angular</li><li>bootstrap</li><li>Node.js</li></ul><h3 id="JavaWeb后端"><a href="#JavaWeb后端" class="headerlink" title="JavaWeb后端"></a>JavaWeb后端</h3><ul><li>Tomcat</li><li>Servlet</li><li>JSP</li></ul><h2 id="第四部分：主流框架和项目管理"><a href="#第四部分：主流框架和项目管理" class="headerlink" title="第四部分：主流框架和项目管理"></a>第四部分：主流框架和项目管理</h2><ul><li>Linux</li><li>Nginx</li><li>==SSM==<ul><li>Spring</li><li>SpringMVC</li><li>MyBatis</li></ul></li><li>项目管理<ul><li>Maven</li><li>git&amp;Github</li></ul></li><li>数据库<ul><li>Redis</li><li>Mysql</li><li>Oracle</li></ul></li><li>其他框架<ul><li>WebService(SOA)</li><li>Activiti(工作流框架)</li><li>Shiro(安全框架)</li><li>Spring  Security(安全框架)</li><li>JPA(持久化)</li><li>SpringData(持久层的通用解决方案)</li></ul></li></ul><h2 id="第五部分：分布式-微服务-并行架构"><a href="#第五部分：分布式-微服务-并行架构" class="headerlink" title="第五部分：分布式|微服务|并行架构"></a>第五部分：分布式|微服务|并行架构</h2><ul><li>Netty</li><li>Dubbo（RPC框架）</li><li>FastDFS（分布式的文件系统）</li><li>Docker（应用容器引擎）</li><li>==Spring家族==<ul><li>SpringBoot</li><li>SpringCloud<ul><li>Nacos（阿里巴巴服务发现，配置，管理）</li><li>Seata（阿里巴巴，分布式事务的中间件）</li><li>Sentinel（阿里巴巴，流量控制，融断，系统负载保护）</li><li>Gateway（网关，限流，日志，监控，鉴权）</li><li>OpenFeign（服务间调用）</li></ul></li></ul></li><li>搜索引擎<ul><li>ElasticSearch</li><li>Solr</li></ul></li><li>==中间件==<ul><li>Mycat（数据库中间件，分库分表）</li><li>消息中间件<ul><li>ActiveMQ</li><li>RabbitMQ</li><li>KafKa</li></ul></li></ul></li><li>日志分析与监控（ELK）<ul><li>ElasticSearch（搜索，存储数据）</li><li>LogStash（分析日志）</li><li>Kibana（可视化）</li></ul></li><li>Zookeeper（一致性服务：比如 配置维护，域名维护，分布式同步）</li></ul><h2 id="第六部分：DevOps（开发运维一体化）自动化部分管理项目，解决CI-CD"><a href="#第六部分：DevOps（开发运维一体化）自动化部分管理项目，解决CI-CD" class="headerlink" title="第六部分：DevOps（开发运维一体化）自动化部分管理项目，解决CI/CD"></a>第六部分：DevOps（开发运维一体化）自动化部分管理项目，解决CI/CD</h2><ul><li>k8s(让部署容器化的应用简单高效)</li><li>普罗米修斯（prometheus）(系统监控和报警)</li><li>Jenkins（监控持续的工作【部署，集成，交付】）</li><li>Harbor（容器的镜像仓库）</li><li>GitLab</li><li>SonarQube(项目工程代码质量检测)</li></ul><h2 id="第七个部分：大数据技术（可以弱化）"><a href="#第七个部分：大数据技术（可以弱化）" class="headerlink" title="第七个部分：大数据技术（可以弱化）"></a>第七个部分：大数据技术（可以弱化）</h2><ul><li>Hadoop</li><li>Hive</li><li>Impals</li><li>spark</li><li>flink</li></ul><h2 id="第八个部分：项目"><a href="#第八个部分：项目" class="headerlink" title="==第八个部分：项目=="></a>==第八个部分：项目==</h2><ul><li>电商</li><li>金融</li><li>教育</li><li>直播</li><li>CRM，ERP</li></ul><h2 id="第九个部分：大厂高频面试题"><a href="#第九个部分：大厂高频面试题" class="headerlink" title="第九个部分：大厂高频面试题"></a>第九个部分：大厂高频面试题</h2><h2 id="第十个部分：底层源码-内核研究"><a href="#第十个部分：底层源码-内核研究" class="headerlink" title="第十个部分：底层源码/内核研究"></a>第十个部分：底层源码/内核研究</h2><h2 id="编程基础的扩展"><a href="#编程基础的扩展" class="headerlink" title="编程基础的扩展"></a>编程基础的扩展</h2><ul><li>计算机网络</li><li>操作系统</li><li>编译原理</li><li>离散数学</li><li>数值分析</li><li>计算机组成原理</li><li>汇编语言</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
