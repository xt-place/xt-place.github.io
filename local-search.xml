<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录24-1-22</title>
    <link href="/2024/01/21/%E8%AE%B0%E5%BD%9524-1-22/"/>
    <url>/2024/01/21/%E8%AE%B0%E5%BD%9524-1-22/</url>
    
    <content type="html"><![CDATA[<h1 id="24-1-22"><a href="#24-1-22" class="headerlink" title="24-1-22"></a>24-1-22</h1><h2 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h2><ul><li>  [ ] vue文件预览完成（1个小时）</li><li>  [ ] 工越登录界面以及增删改查完成（1个小时）</li><li>  [ ] 伙伴匹配项目3、4完成（4小时）</li><li>  [ ] 微服务框架学习（2小时）</li><li>  [ ] 计算机网络学习（1小时）</li><li>  [ ] 论文（2小时）</li><li>  [ ] Java集合、反射复习</li><li>  [ ] 代码随想录数组部分</li><li>  [ ] 算法笔记图算法</li><li>  [ ] 英语口语听力</li></ul><h2 id="accumulation"><a href="#accumulation" class="headerlink" title="accumulation"></a>accumulation</h2><ul><li></li></ul><h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>plan-24</title>
    <link href="/2024/01/21/plan-24/"/>
    <url>/2024/01/21/plan-24/</url>
    
    <content type="html"><![CDATA[<h1 id="Total"><a href="#Total" class="headerlink" title="Total"></a>Total</h1><p>今年几件大事：</p><p>1、找到Java后端的工作：#双休 #8小时 #总包15w</p><p>2、25考研985计算机11408考到430+（初试第一）</p><p>3、坚持健身，保持作息和饮食</p><p>4、做一个个人大项目，要足够新颖，并且有市场需求的</p><p>5、坚持写作，坚持在知识星球打卡，坚持看书</p><p>6、雅思7.5，CET6（600+）</p><p>7、软考中级，CSP400+，PAT甲级满分</p><h2 id="Plan-Each"><a href="#Plan-Each" class="headerlink" title="Plan-Each"></a>Plan-Each</h2><h3 id="（1）Java后端"><a href="#（1）Java后端" class="headerlink" title="（1）Java后端"></a>（1）Java后端</h3><p>首先说一下现在自身的能力和buff。</p><p>可以说无竞赛（只有一个省三）、无论文、项目正在产出，24考研失利，编码能力下降，计算机基础不好。目前想通过过年这段时间准备春招，投简历时间定为2月中旬-4月，也就是只有一个月的时间，在这一个月里我需要做到像春招简历上面的技术能力，因为时间比较紧所以很多基础不能重新学，只能以面经为主，通过面经去发现自己的不足。</p><p>大概的学习路线：</p><p><strong>基础</strong></p><ul><li>  计算机网络</li><li>  操作系统</li><li>  计算机组成原理</li><li>  设计模式</li></ul><p><strong>Java技术栈</strong></p><ul><li>  Java基础</li><li>  JVM和并发控制</li><li>  Linux+Docker+Nginx+Maven+Git</li><li>  Mysql+Redis</li><li>  SSM+SpringBoot+Mybatis-Plus</li><li>  SpringSecurity</li><li>  微服务框架</li><li>  运维相关</li></ul><p><strong>项目</strong></p><ul><li>  伙伴匹配项目</li><li>  API开放平台</li><li>  OJ判题系统</li><li>  智能促销推荐平台（注重算法调优）</li></ul><h3 id="（2）11408（430-）"><a href="#（2）11408（430-）" class="headerlink" title="（2）11408（430+）"></a>（2）11408（430+）</h3><h3 id="（3）大项目"><a href="#（3）大项目" class="headerlink" title="（3）大项目"></a>（3）大项目</h3><h3 id="（4）健身、作息"><a href="#（4）健身、作息" class="headerlink" title="（4）健身、作息"></a>（4）健身、作息</h3><h3 id="（5）写作、打卡、看书"><a href="#（5）写作、打卡、看书" class="headerlink" title="（5）写作、打卡、看书"></a>（5）写作、打卡、看书</h3><hr><h2 id="January"><a href="#January" class="headerlink" title="January"></a>January</h2><h3 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h3><p><strong>基础</strong></p><ul><li>  [ ] 计算机网络（22-28）</li><li>  [ ] 操作系统（一个小项目）（29-04）</li></ul><p><strong>Java技术栈</strong></p><ul><li>  [ ] 微服务框架（22-24）</li><li>  [ ] Java基础（空闲时间看）</li><li>  [ ] JVM和并发控制（25-28）</li></ul><p><strong>项目</strong></p><ul><li>  [ ] 伙伴匹配项目完成（要有自己的）</li><li>  [ ] 微服务项目（随便找）</li></ul><p><strong>论文</strong></p><ul><li>  [ ] 做好代码编写，方法确定</li><li>  [ ] 机器学习学习</li></ul><p><strong>书籍</strong></p><ul><li>  [ ] 《计算机网络自顶向下》</li><li>  [ ] 《图解TCPIP》</li></ul><p><strong>比赛</strong></p><ul><li>  [ ] 《算法笔记》刷一遍（从不会的开始刷）</li><li>  [ ] 代码随想录（数组、链表、哈希表、字符串、双指针）</li></ul><p><strong>英语</strong></p><ul><li>  [ ] 口语加听力</li></ul>]]></content>
    
    
    <categories>
      
      <category>plan</category>
      
    </categories>
    
    
    <tags>
      
      <tag>plan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录24-1-20-21</title>
    <link href="/2024/01/19/%E8%AE%B0%E5%BD%9524-1-20-21/"/>
    <url>/2024/01/19/%E8%AE%B0%E5%BD%9524-1-20-21/</url>
    
    <content type="html"><![CDATA[<h1 id="24-1-20-21（周末）"><a href="#24-1-20-21（周末）" class="headerlink" title="24-1-20-21（周末）"></a>24-1-20-21（周末）</h1><h2 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h2><ul><li>  [ ] 伙伴匹配项目完成</li><li>  [ ] 微服务框架完成</li><li>  [ ] 工越vue完成</li><li>  [ ] 工越王老师作业完成</li><li>  [ ] 下周计划</li></ul><h2 id="accumulation"><a href="#accumulation" class="headerlink" title="accumulation"></a>accumulation</h2><h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3实现移动端的pdf、docx、xlsx、ppt的预览</title>
    <link href="/2024/01/19/Vue3%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84pdf%E3%80%81docx%E3%80%81xlsx%E3%80%81ppt%E7%9A%84%E9%A2%84%E8%A7%88/"/>
    <url>/2024/01/19/Vue3%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84pdf%E3%80%81docx%E3%80%81xlsx%E3%80%81ppt%E7%9A%84%E9%A2%84%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h2 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h2><p>利用pdfh5实现，原链接<a href="https://gitee.com/gjTool/pdfh5">https://gitee.com/gjTool/pdfh5</a></p><p>(1)添加依赖</p><p><img src="/../images/image-20240119104238387.png" alt="image-20240119104238387"></p><p>(2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div id=&quot;app&quot;&gt;<br>      &lt;div id=&quot;pdfdemo&quot;&gt;&lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/template&gt;<br>  &lt;script&gt;<br>    import Pdfh5 from &quot;pdfh5&quot;;<br>    export default &#123;<br>      name: &#x27;FjPdf&#x27;,<br>      data() &#123;<br>        return &#123;<br>          pdfh5: null<br>        &#125;;<br>      &#125;,<br>      mounted() &#123;<br>          //实例化<br>        this.pdfh5 = new Pdfh5(&quot;#pdfdemo&quot;, &#123;<br>          pdfurl: &quot;http://115.231.196.26:8001/ZC_LGKY/UploadFiles/2024-01/DM8 Install_202411617610408.pdf&quot;,<br>        &#125;);<br>        //监听完成事件<br>        this.pdfh5.on(&quot;complete&quot;, function (status, msg, time) &#123;<br>          console.log(&quot;状态：&quot; + status + &quot;，信息：&quot; + msg + &quot;，耗时：&quot; + time + &quot;毫秒，总页数：&quot; + this.totalNum)<br>          //禁止手势缩放<br>          this.pdfh5.zoomEnable(false);<br>        &#125;)<br>      &#125;<br>    &#125;<br>  &lt;/script&gt;<br>  <br>  &lt;style&gt;<br>      @import &quot;pdfh5/css/pdfh5.css&quot;;<br>      *&#123;<br>      padding: 0;<br>      margin: 0;<br>      &#125;<br>      html,body,#app &#123;<br>      width: 100%;<br>      height: 100%;<br>      &#125;<br>  &lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="word"><a href="#word" class="headerlink" title="word"></a>word</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录24-1-19</title>
    <link href="/2024/01/19/%E8%AE%B0%E5%BD%9524-1-19/"/>
    <url>/2024/01/19/%E8%AE%B0%E5%BD%9524-1-19/</url>
    
    <content type="html"><![CDATA[<h1 id="24-1-19"><a href="#24-1-19" class="headerlink" title="24-1-19"></a>24-1-19</h1><h2 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h2><ul><li>  [x] 微服务Day5</li><li>  [ ] 工越问题解决（30min）×</li><li>  [ ] 伙伴匹配项目前端完成（1小时听课，2小时实操）</li><li>  [ ] </li></ul><h2 id="accumlation"><a href="#accumlation" class="headerlink" title="accumlation"></a>accumlation</h2><ul><li><pre><code class="hljs">  docker run -p 8848:8848 -e MODE=standalone --name nacos -d nacos/nacos-server//在启动nacos的时候要指定运行模式，否则将访问不了.</code></pre></li><li><p>  解决加密视频无法复制的问题：<strong>cmd.exe /c “echo off | clip</strong></p></li><li></li></ul><h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>春招简历</title>
    <link href="/2024/01/18/%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86/"/>
    <url>/2024/01/18/%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><p>目标是中厂，人数小于20不考虑，总包在15W+。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>  [ ] 计算机网络（面经）</li><li>  [ ] 操作系统（做一个小型的操作系统）</li><li>  [ ] 计算机组成原理（408）</li><li>  [ ] 数据结构（leetcode先和代码随想录敲一遍，争取每题都要有深度理解）</li></ul><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li>  [ ] Java基础（把之前总结的笔记看完，然后把Java的知识点补齐）</li><li>  [ ] JVM和并发控制（每天晚上花1小时学习）</li><li>  [ ] HTML+CSS+Javascript+Ajax+Jquery+VUE（主要是熟练一下VUE可以自己DIY）(Vue需要多练习)</li><li>  [ ] Linux+Docker+Nginx+Maven+Git（在实战中积累，找工作之前突击）</li><li>  [ ] Mysql+Oracle+Redis（Oracle不要求，其他需要熟练）</li><li>  [ ] SSM+SpringBoot+Mybatis-Plus（重中之重）</li><li>  [ ] SpringSecurity（亮点）</li><li>  [ ] Netty+Dubbo+SpringCloud+ElasticSearch+RabbitMQ+KafKa+Zookeeper（微服务）</li><li>  [ ] K8s</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul><li>  [ ] 伙伴匹配项目</li><li>  [ ] API开放平台</li><li>  [ ] OJ判题系统</li><li>  [x] 智能促销推荐平台（需要魔改）</li><li>  [ ] 。。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>  [ ] CET6</li><li>  [ ] 数学建模省三</li><li>  [ ] CSP400+</li><li>  [ ] PAT甲级满分</li></ul><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前已经是1月中旬了，一些企业的春招已经快开始了，目前打算每天花10h+用于冲刺offer，时间确实不太够，打算过年前就是要把这个简历完善好，然后过完年就投一下杭州或者广州的后端工程师岗位，实习期间需要做一个项目，当然还有毕业论文，那个是机器学习方向的，每天抽2个小时来写就可以了。关于技术的学习我认为现在最需要的就是性价比和速度，对于一些bug我觉得没有必要太执着，那些听过的课有个影响就可以了，把时间都放在开发项目上。现在每天需要做的事情有以下：</p><ul><li>  学习技术方向的理论——上午</li><li>  做项目——下午</li><li>  健身半小时到1小时（中午控制饮食）——下班后</li><li>  学习基础方向的知识、毕业设计——晚上</li><li>  学英语，口语（找点素材跟着读）、单词（不背单词专业八级单词）、阅读（公众号）、听力（2天精听一篇）【1雄小时】——晚上睡前</li></ul><h1 id="作息"><a href="#作息" class="headerlink" title="作息"></a>作息</h1><p>早上7点起，晚上1点前睡，保证6小时。（番茄钟严格⏲）</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>大不了送外卖，反正我觉得我可以脱下孔乙己的长衫，过渡一年，考研。</p>]]></content>
    
    
    
    <tags>
      
      <tag>春招</tag>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录24-1-18</title>
    <link href="/2024/01/18/%E8%AE%B0%E5%BD%9524-1-18/"/>
    <url>/2024/01/18/%E8%AE%B0%E5%BD%9524-1-18/</url>
    
    <content type="html"><![CDATA[<h1 id="24-1-18"><a href="#24-1-18" class="headerlink" title="24-1-18"></a>24-1-18</h1><h2 id="todo-list"><a href="#todo-list" class="headerlink" title="todo-list"></a>todo-list</h2><ul><li>  [x] Vue的bug修改好（1小时）(差点意思doc可以改进一下)</li><li>  [x] 微服务Day4-5（3小时）(完成了Day4，因为做了Day3的作业)</li><li>  [ ] 伙伴匹配项目后端完成（3小时）</li><li>  [ ] 代码随想录数组和链表（2小时）</li><li>  [ ] 论文选择方向和方法（3小时）</li><li>  [ ] Java基础复习，结合面经加上刷牛客的题目（2小时）</li></ul><h2 id="accumulation"><a href="#accumulation" class="headerlink" title="accumulation"></a>accumulation</h2><ul><li><p>```<br>  @Service<br>  @RequiredArgsConstructor<br>  public class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Order&gt; implements IOrderService {</p><pre><code class="hljs">  private final IItemService itemService;  private final IOrderDetailService detailService;  private final ICartService cartService;</code></pre>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    上面的这个例子是说如果要提供参数为itemService的构造函数，那么我们可以在类前加上@RequiredArgsConstructor，然后声明final</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span>   ![<span class="hljs-string">image-20240118085225946</span>](<span class="hljs-link">../images/image-20240118085225946.png</span>)<br><br><span class="hljs-code">    上面的模型演示了cart和item作为两个单一模块怎么进行访问，也就是cart如果要用到item模块中的接口数据，可以通过api中心的client进行通讯，@FeignClient(value = &quot;item-service&quot;,configuration = DefaultFeignConfig.class)声明在Client中，但是我们思考一个问题那就是在利用client进行传输的时候，我们需要注意到的就是我们访问的都是controller层，而不是service层</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span>   OpenFeign 是一个基于注解的声明性 HTTP 客户端，它集成了 Ribbon 负载均衡器。Ribbon 是 Netflix 开源的负载均衡器，用于在微服务架构中进行服务实例的负载均衡。<br><br><span class="hljs-bullet">-</span>   工越笔记：<br><br><span class="hljs-bullet">    -</span>   安装<br><br><span class="hljs-bullet">    -</span>   <span class="hljs-code">```</span><br><span class="hljs-code">        cnpm install </span><br></code></pre></td></tr></table></figure><ul><li></li></ul></li></ul><h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><ul><li>  事务管理机制 和应用场景</li><li>  跨域怎么传递的，微服务是怎么定位对方的接口的，微服务之间的数据传输就是访问接口吗，不可以访问对方的实体类吗</li></ul><h2 id="review"><a href="#review" class="headerlink" title="review"></a>review</h2>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未来一年的打算（2024年）</title>
    <link href="/2024/01/17/%E6%9C%AA%E6%9D%A5%E4%B8%80%E5%B9%B4%E7%9A%84%E6%89%93%E7%AE%97%EF%BC%882024%E5%B9%B4%EF%BC%89/"/>
    <url>/2024/01/17/%E6%9C%AA%E6%9D%A5%E4%B8%80%E5%B9%B4%E7%9A%84%E6%89%93%E7%AE%97%EF%BC%882024%E5%B9%B4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="2024"><a href="#2024" class="headerlink" title="2024"></a>2024</h1><p>我想通过2023年的磨练，在2024这一年中我一定会有非常巨大的变化，并且可能是有史以来的最明显的一次蜕变。那么在2024年有几件大事：</p><ul><li>  找到总包20w的工作</li><li>  985计算机类研究生初试400+</li><li>  开创一个副业（钱多少不是问题，就算亏了也没关系，重要的是养成经商的思路）</li><li>  雅思7.5、CET600+</li><li>  坚持在知识星球打卡</li><li>  坚持健身</li><li>  坚持看书（戒掉手机或者电子娱乐）</li></ul><h2 id="1月-2月（春招准备期-实验期）"><a href="#1月-2月（春招准备期-实验期）" class="headerlink" title="1月-2月（春招准备期+实验期）"></a>1月-2月（春招准备期+实验期）</h2><h3 id="春招！！！（所说的实验也就是把自己处于超高压下，迸发出无限潜力）"><a href="#春招！！！（所说的实验也就是把自己处于超高压下，迸发出无限潜力）" class="headerlink" title="春招！！！（所说的实验也就是把自己处于超高压下，迸发出无限潜力）"></a>春招！！！（所说的实验也就是把自己处于超高压下，迸发出无限潜力）</h3><p>1月份到2月中旬的主要任务，年后就要开始投简历。</p><p>把握好这一个月</p><p>基础篇（每天晚上）</p><p>项目（下午）</p><ul><li>  伙伴匹配项目</li><li>  OJ项目</li><li>  工越项目</li><li>  。。。</li></ul><p>框架篇（上午）</p>]]></content>
    
    
    <categories>
      
      <category>年度计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伙伴匹配项目笔记</title>
    <link href="/2024/01/16/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/16/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="伙伴匹配项目"><a href="#伙伴匹配项目" class="headerlink" title="伙伴匹配项目"></a>伙伴匹配项目</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h3><p><img src="/../images/image-20240116154311741.png" alt="image-20240116154311741"></p><p>###（2）</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>项目</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录</title>
    <link href="/2024/01/15/%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/01/15/%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="24-1-16"><a href="#24-1-16" class="headerlink" title="24-1-16"></a>24-1-16</h1><ul><li><p>  stream，lambda</p></li><li><p>  字符串转json，反序列化和序列化</p></li><li><p>  gson</p></li><li><p>```java<br>  StringUtils.isAnyBlank(userAccount, userPassword, checkPassword, planetCode)</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    用于判断传输过来的参数是否有缺失。</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span>   telnet ip port用于测试端口连接<br><br><span class="hljs-bullet">-</span>   netstat -ano | find &quot;8080&quot;//查询端口<br><br><span class="hljs-bullet">-</span>   taskkill /F /PID <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PID</span>&gt;</span></span> //杀端口<br><br><span class="hljs-section"># 24-1-17</span><br><br><span class="hljs-bullet">-</span>   通过tag来查找用户：情况如下：and或者or，都符合tag还是只有一个符合就可以了<br><br><span class="hljs-bullet">-</span>   <span class="hljs-strong">**`new TypeToken<span class="language-xml">&lt;Set<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span></span>&gt;() &#123;&#125;.getType()`**</span>这是gson处理泛型的技巧。<br><br><span class="hljs-bullet">-</span>   <span class="hljs-code">```</span><br><span class="hljs-code">    tempTagNameSet = Optional.ofNullable(tempTagNameSet).orElse(new HashSet&lt;&gt;());</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure><ol><li> <strong><code>Optional.ofNullable(tempTagNameSet)</code>：</strong> 将 <code>tempTagNameSet</code> 包装为一个 <code>Optional</code> 对象。这意味着，如果 <code>tempTagNameSet</code> 不为 null，将其包装在 <code>Optional</code> 中；如果为 null，<code>Optional</code> 中将包装一个空值（<code>null</code>）。</li><li><strong><code>.orElse(new HashSet&lt;&gt;())</code>：</strong> 如果 <code>Optional</code> 包含一个非空值，那么返回该值；否则，返回提供的默认值，即 <code>new HashSet&lt;&gt;()</code>。<ul><li>  如果 <code>tempTagNameSet</code> 不为 null，<code>orElse</code> 将返回原始的 <code>tempTagNameSet</code>。</li><li>  如果 <code>tempTagNameSet</code> 为 null，<code>orElse</code> 将返回一个新的空的 <code>HashSet&lt;&gt;</code>。</li></ul></li></ol><p>  这种用法可以防止 <code>tempTagNameSet</code> 为 null 时引发空指针异常，并提供一个默认值，以确保后续代码能够正常运行。</p></li><li><p><img src="/../images/image-20240117161029126.png" alt="image-20240117161029126"></p><p>  说明：上面的代码用来stream来处理，stream().fliter(user-&gt;{如果是true则保留，如果是false则删除})</p></li><li><p>  java8 parallelStream的陷阱</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud(一)——初识微服务</title>
    <link href="/2024/01/15/SpringCloud-%E4%B8%80-%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/01/15/SpringCloud-%E4%B8%80-%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>垂死挣扎——PAT备考进行时（八）</title>
    <link href="/2023/09/13/%E5%9E%82%E6%AD%BB%E6%8C%A3%E6%89%8E%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2023/09/13/%E5%9E%82%E6%AD%BB%E6%8C%A3%E6%89%8E%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="LAST-TIME"><a href="#LAST-TIME" class="headerlink" title="LAST TIME"></a>LAST TIME</h1><p>本篇文章是对23年秋季PAT的赛题进行预测，通过分析最近几年的试卷，第一题主要就是模拟题、数学问题或者字符串处理，第二三题就是经典的数据结构，最近特别喜欢考树的遍历（重点看、最喜欢考了，每年基本都有而且出现在后面两题，分值大）、链表、并查集。最后一题基本上要不就是图论（最短路径Dijkstra+DFS）、要不就是DFS、要不就是高级数据结构（最近考树的遍历很多很多一定要重视再重视）。</p><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><h2 id="Dijkstra-DFS"><a href="#Dijkstra-DFS" class="headerlink" title="Dijkstra+DFS"></a>Dijkstra+DFS</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构专题——PAT备考进行时（七）</title>
    <link href="/2023/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2023/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h2><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1032-Sharing（静态链表）（⭐）"><a href="#1032-Sharing（静态链表）（⭐）" class="headerlink" title="1032 Sharing（静态链表）（⭐）"></a><strong>1032 Sharing</strong>（静态链表）（⭐）</h2><p><strong>题目：</strong></p><blockquote><p>To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, <code>loading</code> and <code>being</code> are stored as showed in Figure 1.</p><p><img src="https://images.ptausercontent.com/ef0a1fdf-3d9f-46dc-9a27-21f989270fd4.jpg" alt="fig.jpg"></p><p>Figure 1</p><p>You are supposed to find the starting position of the common suffix (e.g. the position of <code>i</code> in Figure 1).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive <em>N</em> (≤105), where the two addresses are the addresses of the first nodes of the two words, and <em>N</em> is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by −1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><figure class="highlight purebasic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs purebasic">&gt;Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span><br></code></pre></td></tr></table></figure><p>where<code>Address</code> is the position of the node, <code>Data</code> is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output <code>-1</code> instead.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;11111 22222 9<br>&gt;67890 i 00002<br>&gt;00010 a 12345<br>&gt;00003 g -1<br>&gt;12345 D 67890<br>&gt;00002 n 00003<br>&gt;22222 B 23456<br>&gt;11111 L 00001<br>&gt;23456 e 67890<br>&gt;00001 o 00010<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;67890<br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;00001 00002 4<br>&gt;00001 a 10001<br>&gt;10001 s -1<br>&gt;00002 a 10002<br>&gt;10002 t -1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;-1<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  本题因为地址范围小利用静态链表就可以完成操作。</li><li>  步骤一：在定义结构体的时候要加上一个flag用于说明该节点在第一条链表中已经出现过。</li><li>  步骤二：从第一条链表的首个地址出发，遍历一遍链表记录flag=1；然后从第二条链表的收个地址出发，遍历一边链表，判断flag是否等于1；如果是就退出遍历，输出该节点。如果最后遍历完没有发现共同节点，就返回-1.</li><li>  注意节点遍历完的判断条件是next节点是否为-1.</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">char</span> data;<br><span class="hljs-type">int</span> next;<br><span class="hljs-type">bool</span> flag;<br>&#125;vn[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> f,s,n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;f,&amp;s,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)&#123;<br>vn[i].flag=<span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-type">int</span> address,next;<br><span class="hljs-type">char</span> data;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c %d&quot;</span>,&amp;address,&amp;data,&amp;next);<br>vn[address].data=data;<br>vn[address].next=next;<br><br>&#125;<br><span class="hljs-type">int</span> p;<br><span class="hljs-keyword">for</span>(p=f;p!=<span class="hljs-number">-1</span>;p=vn[p].next)&#123;<br>vn[p].flag=<span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(p=s;p!=<span class="hljs-number">-1</span>;p=vn[p].next)&#123;<br><span class="hljs-keyword">if</span>(vn[p].flag==<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,p);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1052-Linked-List-Sorting（链表）（⭐⭐）"><a href="#1052-Linked-List-Sorting（链表）（⭐⭐）" class="headerlink" title="1052 Linked List Sorting（链表）（⭐⭐）"></a><strong>1052 Linked List Sorting</strong>（链表）（⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer <code>key</code> and a <code>Next</code> pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each case, the first line contains a positive <em>N</em> (&lt;105) and an address of the head node, where <em>N</em> is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1.</p><p>  Then <em>N</em> lines follow, each describes a node in the format:</p>  <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Address</span> <span class="hljs-built_in">Key</span> <span class="hljs-built_in">Next</span><br></code></pre></td></tr></table></figure><p>  where <code>Address</code> is the address of the node in memory, <code>Key</code> is an integer in [−105,105], and <code>Next</code> is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, the output format is the same as that of the input, where <em>N</em> is the total number of nodes in the list and all the nodes must be sorted order.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">5 00001<br>11111 100 -1<br>00001 0 22222<br>33333 100000 11111<br>12345 -1 33333<br>22222 1000 12345<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs out">5 12345<br>12345 -1 00001<br>00001 0 11111<br>11111 100 22222<br>22222 1000 33333<br>33333 100000 -1<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  题目意思：对链表排序，然后输出升序。</li><li>  步骤一：同样的我们需要定义一个struct，然后里面需要有一个flag用于判断该节点是否在链表中，因为给的数据中会有一些节点不在链表中，所以我们需要将链表中的那些有效的值排序到数组的前面，然后将有效的值按照data进行排序。</li><li>  注意点：输出的格式需要用到%05d，但是要注意-1要进行特判。</li><li>  当数据里面全部都是无效的时候就需要进行特判处理，输出“0 -1”.</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> address;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> next;<br>    <span class="hljs-type">bool</span> flag;<span class="hljs-comment">//节点是否在链表上</span><br>&#125;node[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a,Node b)</span></span>&#123;<br>    <span class="hljs-comment">//有效的放在前面，然后按照data进行排序</span><br>    <span class="hljs-keyword">if</span>(a.flag==<span class="hljs-literal">false</span>||b.flag==<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-keyword">return</span> a.flag&gt;b.flag;<br>&#125;<br>        <br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> a.data&lt;b.data;<br>    &#125;<br><br><br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)&#123;<br>        node[i].flag=<span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> n,head;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;head);<br>    <span class="hljs-type">int</span> address,data,next;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;address,&amp;data,&amp;next);<br>        node[address].address=address;<br>        node[address].data=data;<br>        node[address].next=next;<br>    &#125;<br>    <span class="hljs-type">int</span> p=head;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-number">-1</span>)&#123;<br>        node[p].flag=<span class="hljs-literal">true</span>;<br>        count++;<br>        p=node[p].next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 -1&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sort</span>(node,node+MAXN,cmp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %05d\n&quot;</span>,count,node[<span class="hljs-number">0</span>].address);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i!=count<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,node[i].address,node[i].data,node[i+<span class="hljs-number">1</span>].address);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>,node[i].address,node[i].data);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表题的模板"><a href="#链表题的模板" class="headerlink" title="链表题的模板"></a>链表题的模板</h2><ul><li><p>首先是struct结构体的定义：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> address;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> next;<br>    XXX xxx;<span class="hljs-comment">//该位是记录该链表的特点，例如可以用来判断节点是否是在链表中，注意要初始化。</span><br>&#125;node[MAXN];<br></code></pre></td></tr></table></figure></li><li><p>对特殊变量的初始化：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)&#123;<br>       node[i].flag=<span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>对特殊变量的赋值：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(p!=<span class="hljs-number">-1</span>)&#123;<br>       node[p].flag=<span class="hljs-literal">true</span>;<br>       count++;<br>       p=node[p].next;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
      <category>数据结构专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>疯狂的刷题——PAT备考进行时（六）</title>
    <link href="/2023/09/04/%E7%96%AF%E7%8B%82%E7%9A%84%E5%88%B7%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2023/09/04/%E7%96%AF%E7%8B%82%E7%9A%84%E5%88%B7%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="打表技巧"><a href="#打表技巧" class="headerlink" title="打表技巧"></a>打表技巧</h1><h2 id="1093-Count-PAT’s（空间换时间）（⭐⭐）"><a href="#1093-Count-PAT’s（空间换时间）（⭐⭐）" class="headerlink" title="1093 Count PAT’s（空间换时间）（⭐⭐）"></a><strong>1093 Count PAT’s</strong>（空间换时间）（⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  The string <code>APPAPT</code> contains two <code>PAT</code>‘s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.</p><p>  Now given any string, you are supposed to tell the number of <code>PAT</code>‘s contained in the string.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only <code>P</code>, <code>A</code>, or <code>T</code>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, print in one line the number of <code>PAT</code>‘s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">APPAPT<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">2<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  题目要求我们统计其中按照顺序排列的PAT有几个，</li><li>  通过分析我们如果直接用暴力会超时，那么就需要利用空间换时间，利用数组记录每一个A的左边有几个P，右边有几个T，然后把P和T的数相乘得到每个位子上的A有几个组合，然后把每个A上的数据相加。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD=<span class="hljs-number">1000000007</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>string str;<br>cin&gt;&gt; str;<br><span class="hljs-type">int</span> len=str.<span class="hljs-built_in">length</span>(),ans=<span class="hljs-number">0</span>,countp=<span class="hljs-number">0</span>,countt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br><span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;T&#x27;</span>)&#123;<br>countt++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br><span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;P&#x27;</span>)countp++;<br><span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;T&#x27;</span>)countt--;<br><span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;A&#x27;</span>)ans=(ans+(countt*countp)%MOD)%MOD;<br><br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>给出的代码利用countt，countp记录该位子上的T和P有几个然后相乘。</p><h2 id="1101-Quick-Sort（打表，快速排序）（⭐⭐）"><a href="#1101-Quick-Sort（打表，快速排序）（⭐⭐）" class="headerlink" title="1101 Quick Sort（打表，快速排序）（⭐⭐）"></a><strong>1101 Quick Sort</strong>（打表，快速排序）（⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  There is a classical process named <strong>partition</strong> in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given <em>N</em> distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?</p><p>  For example, given <em>N</em>=5 and the numbers 1, 3, 2, 4, and 5. We have:</p><ul><li>  1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;</li><li>  3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;</li><li>  2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;</li><li>  and for the similar reason, 4 and 5 could also be the pivot.</li></ul><p>  Hence in total there are 3 pivot candidates.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤105). Then the next line contains <em>N</em> distinct positive integers no larger than 109. The numbers in a line are separated by spaces.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">5<br>1 3 2 4 5<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">3<br>1 4 5<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  题目要求我们找出所有的符合作为主元的元素（主元就是左边的所有小于右边所有）。</li><li>  和上面一题相似，我们可以用数组记录下该位子左边最大的数和右边最小的数，然后进行比较，如果符合就加入结果中。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-type">int</span> num[n];<br><span class="hljs-type">int</span> left[n];<br><span class="hljs-type">int</span> right[n];<br><span class="hljs-type">int</span> ans[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num[i]);<br>&#125;<br>left[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>left[i]=<span class="hljs-built_in">max</span>(left[i<span class="hljs-number">-1</span>],num[i<span class="hljs-number">-1</span>]);<br>&#125;<br>right[n<span class="hljs-number">-1</span>]=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>right[i]=<span class="hljs-built_in">min</span>(right[i+<span class="hljs-number">1</span>],num[i+<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(num[i]&gt;left[i]&amp;&amp;num[i]&lt;right[i])&#123;<br>ans[count++]=num[i];<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,count);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans[i]);<br><span class="hljs-keyword">if</span>(i!=count<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>  第一位最大值为0，最后一位最小值为INF。</li></ul><hr><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="1062-Talent-and-Virtue（重写sort-cmp）-⭐⭐⭐"><a href="#1062-Talent-and-Virtue（重写sort-cmp）-⭐⭐⭐" class="headerlink" title="1062 Talent and Virtue（重写sort-cmp）(⭐⭐⭐)"></a><strong>1062 Talent and Virtue</strong>（重写sort-cmp）(⭐⭐⭐)</h2><p><strong>题目：</strong></p><blockquote><p>  About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people’s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a “sage（圣人）”; being less excellent but with one’s virtue outweighs talent can be called a “nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man is better than a “small man（小人）” who prefers talent than virtue.</p><p>  Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang’s theory.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. Each case first gives 3 positive integers in a line: <em>N</em> (≤105), the total number of people to be ranked; <em>L</em> (≥60), the lower bound of the qualified grades – that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and <em>H</em> (&lt;100), the higher line of qualification – that is, those with both grades not below this line are considered as the “sages”, and will be ranked in non-increasing order according to their total grades. Those with talent grades below <em>H</em> but virtue grades not are considered as the “noblemen”, and are also ranked in non-increasing order according to their total grades, but they are listed after the “sages”. Those with both grades below <em>H</em>, but with virtue not lower than talent are considered as the “fool men”. They are ranked in the same way but after the “noblemen”. The rest of people whose grades both pass the <em>L</em> line are ranked after the “fool men”.</p><p>  Then <em>N</em> lines follow, each gives the information of a person in the format:</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ID_Number Virtue_Grade Talent_Grade</span><br></code></pre></td></tr></table></figure><p>  where <code>ID_Number</code> is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  The first line of output must give <em>M</em> (≤<em>N</em>), the total number of people that are actually ranked. Then <em>M</em> lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID’s.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs in">14 60 80<br>10000001 64 90<br>10000002 90 60<br>10000011 85 80<br>10000003 85 80<br>10000004 80 85<br>10000005 82 77<br>10000006 83 76<br>10000007 90 78<br>10000008 75 79<br>10000009 59 90<br>10000010 88 45<br>10000012 80 100<br>10000013 90 99<br>10000014 66 60<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs out">12<br>10000013 90 99<br>10000012 80 100<br>10000003 85 80<br>10000011 85 80<br>10000004 80 85<br>10000007 90 78<br>10000006 83 76<br>10000005 82 77<br>10000002 90 60<br>10000014 66 60<br>10000008 75 79<br>10000001 64 90<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  要求进行对一列人的排序，根据德才的分数。</li><li>  如果要排序我们可以自然而然的想到用sort函数，本题的重点也就是对sort函数进行重写。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">1、给出一行人来进行德才排序，根据她们的成绩</span><br><span class="hljs-comment">进行降序 </span><br><span class="hljs-comment">2、 sages：智商情商都高于 H；</span><br><span class="hljs-comment"> noblemen：情商高H智商低于H。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> name;<br><span class="hljs-type">int</span> v;<br><span class="hljs-type">int</span> t;<br><span class="hljs-type">int</span> sum;<br><span class="hljs-type">int</span> flag;<br>&#125;; <br>vector&lt;Node&gt; vn;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a,Node b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.flag!=b.flag)&#123;<br><span class="hljs-keyword">return</span> a.flag&lt;b.flag;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.sum!=b.sum)&#123;<br><span class="hljs-keyword">return</span> a.sum&gt;b.sum;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.v!=b.v)&#123;<br><span class="hljs-keyword">return</span> a.v&gt;b.v;<br><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.name&lt;b.name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n,l,h;<br><span class="hljs-type">int</span> zero=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;l,&amp;h);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>Node node;<br>node.flag=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;node.name,&amp;node.v,&amp;node.t);<br>node.sum=node.v+node.t;<br>vn.<span class="hljs-built_in">push_back</span>(node);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(vn[i].v&gt;=l&amp;&amp;vn[i].t&gt;=l)&#123;<br><span class="hljs-keyword">if</span>(vn[i].v&gt;=h&amp;&amp;vn[i].t&gt;=h)&#123;<br>vn[i].flag=<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vn[i].v&gt;=h&amp;&amp;vn[i].t&lt;h)&#123;<br>vn[i].flag=<span class="hljs-number">2</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vn[i].v&gt;=vn[i].t)&#123;<br>vn[i].flag=<span class="hljs-number">3</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>vn[i].flag=<span class="hljs-number">4</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>zero++;<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(vn.<span class="hljs-built_in">begin</span>(),vn.<span class="hljs-built_in">end</span>(),cmp);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-zero);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=zero;i&lt;n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,vn[i].name,vn[i].v,vn[i].t);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>  注意else if语句的书写。</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1172-1175套题——PAT备考进行时（五）</title>
    <link href="/2023/09/03/1172-1175%E5%A5%97%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2023/09/03/1172-1175%E5%A5%97%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1172-Panda-and-PP-Milk"><a href="#1172-Panda-and-PP-Milk" class="headerlink" title="1172 Panda and PP Milk"></a><strong>1172 Panda and PP Milk</strong></h1>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论——PAT备考进行时（四）</title>
    <link href="/2023/08/26/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/08/26/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><p>利用邻接矩阵或者邻接表进行实现。</p><p>对于无向图来说，邻接矩阵是对称矩阵，矩阵比较好写，但是如果定点数太大，会超出内存限制，所以一般只用于1000以下的题目。</p><p>在C++中可以利用vector实现邻接表，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; Adj[N];<br></code></pre></td></tr></table></figure><p>Adj[]数组是一个vector&lt;int&gt;数组，数组的下标代表几号顶点，vector可以看成一个链表。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li>  利用邻接表实现：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;  Adj[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>    vis[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Adj[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> v=Adj[u][i];<br>        <span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-built_in">DFS</span>(v,depth+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>广度优先搜索，每次以外扩的方式访问顶点。</p><ul><li>  用邻接矩阵实现BFS</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,G[MAXN][MAXN];<br><span class="hljs-type">bool</span> inq[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<span class="hljs-comment">//u表示所在的连通块</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    inq[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br>            <span class="hljs-keyword">if</span>(inq[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br>                q.<span class="hljs-built_in">push</span>(v);<br>                inq[v]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFSTrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br><span class="hljs-keyword">if</span>(inq[u]==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-built_in">BFS</span>(u);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  用邻接表实现BFS</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; Adj[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> inq[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    inq[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Adj[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> v=Adj[u][i];<br>            q.<span class="hljs-built_in">push</span>(v);<br>            inq[v]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1034-Head-of-a-Gang（图的深度遍历，STL）（⭐⭐⭐⭐）"><a href="#1034-Head-of-a-Gang（图的深度遍历，STL）（⭐⭐⭐⭐）" class="headerlink" title="1034 Head of a Gang（图的深度遍历，STL）（⭐⭐⭐⭐）"></a><strong>1034 Head of a Gang</strong>（图的深度遍历，STL）（⭐⭐⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between <em>A</em> and <em>B</em>, we say that <em>A</em> and <em>B</em> is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold <em>K</em>. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive numbers <em>N</em> and <em>K</em> (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then <em>N</em> lines follow, each in the following format:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&gt;<span class="hljs-symbol">Name1</span> <span class="hljs-symbol">Name2</span> Time<br></code></pre></td></tr></table></figure><p>where <code>Name1</code> and <code>Name2</code> are the names of people at the two ends of the call, and <code>Time</code> is the length of the call. A name is a string of three capital letters chosen from <code>A</code>-<code>Z</code>. A time length is a positive integer which is no more than 1000 minutes.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;8 59<br>&gt;AAA BBB 10<br>&gt;BBB AAA 20<br>&gt;AAA CCC 40<br>&gt;DDD EEE 5<br>&gt;EEE DDD 70<br>&gt;FFF GGG 30<br>&gt;GGG HHH 20<br>&gt;HHH FFF 10<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;2<br>&gt;AAA 3<br>&gt;GGG 3<br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;8 70<br>&gt;AAA BBB 10<br>&gt;BBB AAA 20<br>&gt;AAA CCC 40<br>&gt;DDD EEE 5<br>&gt;EEE DDD 70<br>&gt;FFF GGG 30<br>&gt;GGG HHH 20<br>&gt;HHH FFF 10<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;0<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  本题作为压轴题，但其实并不是很难，只要掌握了图的深度搜索遍历就可以非常轻松的做出来。</li><li>  首先题目要求我们最终输出的是犯罪团伙的头目和人数，那么我们先考虑一下要怎么样去输出，是不是可以用<code>map&lt;string,int&gt;</code>保存头目和人数信息。这题非常明显的就是图的遍历，但是如果没有定位是图的遍历，那就没话说了，自己先去学习深搜。</li><li>  如果定位了图的遍历，那就可以用图的深度搜索的代码模板了，只不过要在遍历单连通图的时候通过比较记录下谁是头目（用点权进行比较）和人数以及总权数（要&gt;k）才是犯罪团伙，输入到gang团伙map中，等待最后的输出。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">数据存储准备：</span><br><span class="hljs-comment">用于将邻接矩阵的编号和名字对应，当然需要通过名字查找编号。 </span><br><span class="hljs-comment">map&lt;int,string&gt; intToString;</span><br><span class="hljs-comment">map&lt;string,int&gt; stringToInt;</span><br><span class="hljs-comment">记录头目和人数：</span><br><span class="hljs-comment">map&lt;string,int&gt;  gang;</span><br><span class="hljs-comment">一个记录点权值的数组：</span><br><span class="hljs-comment">int weight[maxn]=&#123;0&#125;; </span><br><span class="hljs-comment">一个记录边权值的矩阵:</span><br><span class="hljs-comment">int G[maxn][maxn]=&#123;0&#125;;</span><br><span class="hljs-comment">一个用于遍历图的判断数组：</span><br><span class="hljs-comment">bool vis[max]=&#123;false&#125;;</span><br><span class="hljs-comment">int k;下限</span><br><span class="hljs-comment">int peopleNum;记录人数，在输入的时候进行记录。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">思路：主要就是先将输入的东西先进行人名和编号对应放到G矩阵中，</span><br><span class="hljs-comment">人名对应的时候要同时更新编号和人名对应。</span><br><span class="hljs-comment"> 一共有三个函数：</span><br><span class="hljs-comment"> 1、输入：屏幕中的一系列人名的对应关系，记录到两个map中，</span><br><span class="hljs-comment"> 并且要将边权值记录到 G矩阵中,记录点权值。 </span><br><span class="hljs-comment"> 2、遍历整个图，获取每个连通图的信息，如果vis为false就是未被访问则进入dfs</span><br><span class="hljs-comment"> 遍历，寻找单联通区域的头目、人数和总边权，和k进行比较。</span><br><span class="hljs-comment"> 3、遍历单连通区域，记录 头目、人数、总边权、weight数组 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br>map&lt;<span class="hljs-type">int</span>,string&gt; intToString;<br>map&lt;string,<span class="hljs-type">int</span>&gt; stringToInt;<br>map&lt;string,<span class="hljs-type">int</span>&gt;  gang;<br><span class="hljs-type">int</span> weight[maxn]=&#123;<span class="hljs-number">0</span>&#125;; <br> <span class="hljs-type">int</span> G[maxn][maxn]=&#123;<span class="hljs-number">0</span>&#125;;<br> <span class="hljs-type">bool</span> vis[maxn]=&#123;<span class="hljs-literal">false</span>&#125;;<br> <span class="hljs-type">int</span> k;<br> <span class="hljs-type">int</span> peopleNum;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> nowVisit,<span class="hljs-type">int</span>&amp; head,<span class="hljs-type">int</span>&amp; numMember,<span class="hljs-type">int</span>&amp; totalValue)</span></span>&#123;<br> numMember++;<br> vis[nowVisit]=<span class="hljs-literal">true</span>;<br> <span class="hljs-keyword">if</span>(weight[nowVisit]&gt;weight[head])&#123;<br> head=nowVisit;<br> <br> &#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;peopleNum;i++)&#123;<br><span class="hljs-keyword">if</span>(G[nowVisit][i]&gt;<span class="hljs-number">0</span>)&#123;<br>totalValue+=G[nowVisit][i];<br>G[nowVisit][i]=G[i][nowVisit]=<span class="hljs-number">0</span>;<span class="hljs-comment">//删除已经统计过的边。</span><br><span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-built_in">DFS</span>(i,head,numMember,totalValue);<br>&#125;<br>        &#125;<br>    &#125;<br>  &#125;<br> <br> <br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFSTrave</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;peopleNum;i++)&#123;<br> <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-literal">false</span>)&#123;<br> <span class="hljs-type">int</span> head=i,numMember=<span class="hljs-number">0</span>,totalValue=<span class="hljs-number">0</span>;<br> <span class="hljs-built_in">DFS</span>(i,head,numMember,totalValue);<br><span class="hljs-keyword">if</span>(numMember&gt;<span class="hljs-number">2</span> &amp;&amp; totalValue&gt;k)&#123;<br>gang[intToString[head]]=numMember;<br>&#125;<br> &#125;<br> &#125;<br> &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(string str)</span></span>&#123;<br> <span class="hljs-keyword">if</span>(stringToInt.<span class="hljs-built_in">find</span>(str)!=stringToInt.<span class="hljs-built_in">end</span>())&#123;<br> <span class="hljs-keyword">return</span> stringToInt[str];<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br> stringToInt[str] =peopleNum;<br> intToString[peopleNum]=str; <br> <span class="hljs-keyword">return</span> peopleNum++;<br> &#125; <br> &#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n&gt;&gt;k;<br>string s1,s2;<br><span class="hljs-type">int</span> temp;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;temp;<br><span class="hljs-type">int</span> l1=<span class="hljs-built_in">change</span>(s1);<br><span class="hljs-type">int</span> l2=<span class="hljs-built_in">change</span>(s2);<br>weight[l1]+=temp;<br>weight[l2]+=temp;<br>G[l1][l2]+=temp;<br>G[l2][l1]+=temp;<br><br>&#125;<br><br><span class="hljs-built_in">DFSTrave</span>();<br>cout&lt;&lt;gang.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>map&lt;string,<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it=gang.<span class="hljs-built_in">begin</span>();it!=gang.<span class="hljs-built_in">end</span>();it++)&#123;<br>cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>  需要注意的是在进行单连通遍历的时候记录totalValue时要及时对已经记录过的边权进行删除，不然会重复统计。</li><li>  最后map输出的时候利用迭代器。</li></ul><h3 id="思考：如何利用邻接表实现。"><a href="#思考：如何利用邻接表实现。" class="headerlink" title="思考：如何利用邻接表实现。"></a>思考：如何利用邻接表实现。</h3><p><strong>代码：</strong></p><h2 id="1076-Forwards-on-Weibo（图的BFS遍历）（⭐⭐⭐）"><a href="#1076-Forwards-on-Weibo（图的BFS遍历）（⭐⭐⭐）" class="headerlink" title="1076 Forwards on Weibo（图的BFS遍历）（⭐⭐⭐）"></a><strong>1076 Forwards on Weibo</strong>（图的BFS遍历）（⭐⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only <em>L</em> levels of indirect followers are counted.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers: <em>N</em> (≤1000), the number of users; and <em>L</em> (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each in the format:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;M<span class="hljs-selector-attr">[i]</span> user_list<span class="hljs-selector-attr">[i]</span><br></code></pre></td></tr></table></figure><p>where <code>M[i]</code> (≤100) is the total number of people that <code>user[i]</code> follows; and <code>user_list[i]</code> is a list of the <code>M[i]</code> users that followed by <code>user[i]</code>. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.</p><p>Then finally a positive <em>K</em> is given, followed by <em>K</em> <code>UserID</code>‘s for query.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>UserID</code>, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only <em>L</em> levels of indirect followers are counted.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;7 3<br>&gt;3 2 3 4<br>&gt;0<br>&gt;2 5 6<br>&gt;2 3 1<br>&gt;2 3 4<br>&gt;1 4<br>&gt;1 5<br>&gt;2 2 6<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;4<br>&gt;5<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  本题主要难点在于读懂题目，说实话我觉得现在我最大的问题就是不会读题目，题目中要求我们在给定N个用户和L层找到一个微博用户发送的信息最多可以被转发多少次。</li><li>  解题的关键是在于建立有向图，那么代码中我利用的是邻接表记录，注意的是如果一个图中有权值，并且需要用到邻接表进行记录，那么邻接表中可以利用定义一个struct记录节点的编号和权重。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1010</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">数据存储：</span><br><span class="hljs-comment">邻接表，记录图 </span><br><span class="hljs-comment">vector&lt;int&gt; Adj[MAXN];</span><br><span class="hljs-comment">层数：</span><br><span class="hljs-comment">int lever;</span><br><span class="hljs-comment">最大转发数：</span><br><span class="hljs-comment">int count;</span><br><span class="hljs-comment">查询列表：</span><br><span class="hljs-comment">vector&lt;int&gt; ans; </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">解题步骤：</span><br><span class="hljs-comment">1、建立图，注意箭头指向是从被关注者到关注者。</span><br><span class="hljs-comment">2、输入查询的节点，从该节点开始寻找，记录层数</span><br><span class="hljs-comment">和转发量。返回转发量，存入查询列表中。 </span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> layer;<br>&#125;;<br>vector&lt;Node&gt; Adj[MAXN];<br><span class="hljs-type">bool</span> inq[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> L)</span></span>&#123;<br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>queue&lt;Node&gt; q;<br>Node start;<br>start.id=u;<br>start.layer=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(start);<br>inq[start.id]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>Node node=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> s=node.id;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Adj[s].<span class="hljs-built_in">size</span>();i++)&#123;<br>Node next=Adj[s][i];<br>next.layer=node.layer+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(inq[next.id]==<span class="hljs-literal">false</span>&amp;&amp;next.layer&lt;=L)&#123;<br>q.<span class="hljs-built_in">push</span>(next);<br>inq[next.id]=<span class="hljs-literal">true</span>;<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> N,L;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;N,&amp;L);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br><span class="hljs-type">int</span> nums;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums;j++)&#123;<br><span class="hljs-type">int</span> num;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>Node newNode;<br>newNode.id=i;<br>newNode.layer=<span class="hljs-number">0</span>;<br>Adj[num].<span class="hljs-built_in">push_back</span>(newNode);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> searchNum;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;searchNum);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;searchNum;i++)&#123;<br><span class="hljs-built_in">memset</span>(inq,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(inq));<span class="hljs-comment">//为何要这句？？？ </span><br><span class="hljs-type">int</span> start;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;start);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">BFS</span>(start,L));<br>&#125;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>  因为每次进入BFS之前inq数组可能已经有上一次遍历的信息所以可以在进入BFS之前先对inq进行一个重置。</li></ul><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h2 id="1003-Emergency（Dijkstra）（⭐⭐⭐⭐）"><a href="#1003-Emergency（Dijkstra）（⭐⭐⭐⭐）" class="headerlink" title="1003 Emergency（Dijkstra）（⭐⭐⭐⭐）"></a><strong>1003 Emergency</strong>（Dijkstra）（⭐⭐⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to <em>N</em>−1), <em>M</em> - the number of roads, <em>C</em>1 and <em>C</em>2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers <em>c</em>1, <em>c</em>2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <em>C</em>1 to <em>C</em>2.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, print in one line two numbers: the number of different shortest paths between <em>C</em>1 and <em>C</em>2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs in">5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">2 4<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  本题我个人感觉难度还是比较大的，首先是题目的理解，主要是要把题目中的城市中的救援队抽象成点权，把路抽象成边权，所以我们应该是在找最短路的同时将点权之和进行记录，也就是更新每个点的点权值之和，具体的内容就是在Dijkstra算法中修改，其实这么分析下来就不难了，最后输出的时候是输出条数而不是权值，这是一个小陷阱，以后得认真读题。</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">数据存储：</span><br><span class="hljs-comment">用于记录城市的数量n,路的条数m,开始的城市c1</span><br><span class="hljs-comment">结束的城市c2.</span><br><span class="hljs-comment">int n,m,c1,c2;</span><br><span class="hljs-comment">记录图信息，</span><br><span class="hljs-comment">int G[MAXN][MAXN];</span><br><span class="hljs-comment">记录点权：</span><br><span class="hljs-comment">int weigh[MAXN]; </span><br><span class="hljs-comment">记录每点到起始点的边权值。</span><br><span class="hljs-comment">int d[MAXN];</span><br><span class="hljs-comment">记录点权之和</span><br><span class="hljs-comment">int w[MAXN]; </span><br><span class="hljs-comment">记录是否访问</span><br><span class="hljs-comment">bool vis[MAXN]=&#123;false&#125;; </span><br><span class="hljs-comment">记录最短路径的条数 </span><br><span class="hljs-comment">int num[MAXN]; </span><br><span class="hljs-comment">解题思路：</span><br><span class="hljs-comment">1、处理图利用邻接矩阵存储。weight记录点权 </span><br><span class="hljs-comment">2、利用Dijkstra算法计算d数组、在更新d数组</span><br><span class="hljs-comment">的时候更新w数组、num数组、.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> n,m,c1,c2;<br><span class="hljs-type">int</span> G[MAXN][MAXN];<br><span class="hljs-type">int</span> weight[MAXN]; <br><span class="hljs-type">int</span> d[MAXN];<br><span class="hljs-type">int</span> w[MAXN]; <br><span class="hljs-type">int</span> num[MAXN];<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br><span class="hljs-built_in">fill</span>(w,w+MAXN,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">fill</span>(num,num+MAXN,<span class="hljs-number">0</span>);<br>d[s]=<span class="hljs-number">0</span>;<br>w[s]=weight[s];<br>num[s]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">-1</span>,MIN=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br><span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;<br>u=j;<br>MIN=d[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(u==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ;<br>vis[u]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br><span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br><span class="hljs-keyword">if</span>(d[u]+G[u][v]&lt;d[v])&#123;<br>d[v]=d[u]+G[u][v];<br>w[v]=w[u]+weight[v];<br>num[v]=num[u];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+G[u][v]==d[v])&#123;<br><span class="hljs-keyword">if</span>(w[u]+weight[v]&gt;w[v])&#123;<br>w[v]=w[u]+weight[v];<br><br>&#125;<br>num[v]+=num[u];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;m,&amp;c1,&amp;c2);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;weight[i]);<br>&#125;<br><span class="hljs-built_in">fill</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>G[a][b]=c;<br>G[b][a]=c;<br>&#125;<br><span class="hljs-built_in">Dijkstra</span>(c1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,num[c2],w[c2]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意点</strong>：</p><ul><li>  对二维数组进行fill()操作的时候需要<code>fill(G[0],G[0]+MAXN*MAXN,INF);</code>。</li><li>  记住Dijkstra算法可以同时维护多个标尺。</li></ul><h2 id="利用DFS改进1003"><a href="#利用DFS改进1003" class="headerlink" title="利用DFS改进1003"></a>利用DFS改进1003</h2><p>上面的题目只是给出了简单的计算权值的方法，要是稍微复杂一点可能就无法得到正确的结果，因为不一定满足最优子结构。所以我们可以利用DFS加持。</p><p>上面我们的思路是用pre数组记录下最短路，这需要在进行Dijkstra算法的时候进行严密的逻辑。其实有一个更加简单的方式：<strong>先在Dijkstra算法中记录下所有最短路经（只考虑距离），然后从这些最短路径中选出一条第二标尺最优的路径。</strong></p><p>①使用Dijkstra算法记录下所有的最短路径。</p><p>之前我们是使用pre数组进行记录，但是记录下所有路径，使用<code>vector&lt;int&gt; pre[MAXN]</code>，（如果需要查询某个顶点u是否在顶点v的前驱中，可以使用<code>set&lt;int&gt;</code>，此时使用<code>pre[v].count()</code>查询比较方便）</p><ul><li>  Pre数组的求解代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br>    d[s]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">-1</span>;MIN=INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;<br>                u=j;<br>                MIN=d[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(u==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ;<br>        vis[u]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br><span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br>                <span class="hljs-keyword">if</span>(d[u]+G[u][v]&lt;d[v])&#123;<br>                    d[v]=d[u]+G[u][v];<br>                    pre[v].<span class="hljs-built_in">clear</span>();<br>                    pre[v].<span class="hljs-built_in">push_back</span>(u);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+G[u][v]==d[v])&#123;<br>                    pre[v].<span class="hljs-built_in">push_back</span>(u);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②遍历所有最短路径，找出一条第二标尺最优的路径</p><p>现在我们已经pre数组，记录了每个节点中所有的最短路径的前驱节点，在每个pre[]中记录的是所有前前驱，故需要用到DFS进行求解。</p><p>必须要有的是：</p><ul><li>  作为全局变量的第二标尺最优值optValue。</li><li>  记录最优路径的数组path（使用vector记录）</li><li>  临时记录DFS遍历到叶子节点的路径tempPath（使用vector数组存储）</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> optValue;<br>vector&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; path,tempPath;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">if</span>(v==st)&#123;<br>        tempPath.<span class="hljs-built_in">push_back</span>(v);<br>        <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">if</span>(value优于optValue)&#123;<br>            optValue=value;<br>            path=tempPath;<br>        &#125;<br>        tempPath.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    tempPath.<span class="hljs-built_in">push_back</span>(v);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pre[v].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-built_in">DFS</span>(pre[v][i]);<br>    &#125;<br>    tempPath.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>  题目中的第二标尺比较简单的情况下使用第一种题解比较方便。</li></ul><h2 id="1030-Travel-Plan（Dijkstra）（⭐⭐⭐⭐）"><a href="#1030-Travel-Plan（Dijkstra）（⭐⭐⭐⭐）" class="headerlink" title="1030 Travel Plan（Dijkstra）（⭐⭐⭐⭐）"></a><strong>1030 Travel Plan</strong>（Dijkstra）（⭐⭐⭐⭐）</h2><p><strong>题目：</strong></p><blockquote><p>  A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</p><h3 id="Input-Specification-3"><a href="#Input-Specification-3" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. Each case starts with a line containing 4 positive integers <em>N</em>, <em>M</em>, <em>S</em>, and <em>D</em>, where <em>N</em> (≤500) is the number of cities (and hence the cities are numbered from 0 to <em>N</em>−1); <em>M</em> is the number of highways; <em>S</em> and <em>D</em> are the starting and the destination cities, respectively. Then <em>M</em> lines follow, each provides the information of a highway, in the format:</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">City1 City2 <span class="hljs-built_in">Distance</span> Cost<br></code></pre></td></tr></table></figure><p>  where the numbers are all integers no more than 500, and are separated by a space.</p><h3 id="Output-Specification-3"><a href="#Output-Specification-3" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">4 5 0 3<br>0 1 1 20<br>1 3 2 30<br>0 3 4 10<br>0 2 2 20<br>2 3 1 20<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">0 2 3 3 40<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><p>本题就是一个规规矩矩的利用Dijkstra算法进行求解，如果不熟练Dijkstra，没有办法在10分钟内写出完整的DK算法的话本题具有一定难度，Dijksta算法的模板较为单一，同时如果遇到多个标尺可以使用DFS进行求解，总之如果不懂，就背下来。</p><p><strong>代码：</strong>（利用DFS求解）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">数据存储：</span><br><span class="hljs-comment">用于存储城市、路、起点和重点。</span><br><span class="hljs-comment">int n,m,s,e;</span><br><span class="hljs-comment">用于存储图结构</span><br><span class="hljs-comment">int G[MAXN][MAXN];</span><br><span class="hljs-comment">用于记录最优路径节点的前驱。</span><br><span class="hljs-comment">vector&lt;int&gt; pre;</span><br><span class="hljs-comment">用于存储 </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> m,n,st,e;<br><span class="hljs-type">int</span> G[MAXN][MAXN],cost[MAXN][MAXN];<br><span class="hljs-type">int</span> d[MAXN];<br><br><span class="hljs-type">int</span> minCost=INF;<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; path,tempPath;<br>vector&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br>d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">-1</span>,MIN=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br><span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;<br>MIN=d[j];<br>u=j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(u==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;<br>vis[u]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br><span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br><span class="hljs-keyword">if</span>(d[u]+G[u][v]&lt;d[v])&#123;<br>d[v]=d[u]+G[u][v];<br>pre[v].<span class="hljs-built_in">clear</span>();<br>pre[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+G[u][v]==d[v])&#123;<br>pre[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">if</span>(v==st)&#123;<br>tempPath.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-type">int</span> tempCost=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=tempPath.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-type">int</span> id=tempPath[i],idNext=tempPath[i<span class="hljs-number">-1</span>];<br>tempCost+=cost[id][idNext];<br>&#125;<br><span class="hljs-keyword">if</span>(tempCost&lt;minCost)&#123;<br>minCost=tempCost;<br>path=tempPath;<br>&#125;<br>tempPath.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>tempPath.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pre[v].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-built_in">DFS</span>(pre[v][i]);<br>&#125;<br>tempPath.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;m,&amp;st,&amp;e);<br><span class="hljs-type">int</span> u,v;<br><span class="hljs-built_in">fill</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-built_in">fill</span>(cost[<span class="hljs-number">0</span>],cost[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;G[u][v],&amp;cost[u][v]);<br>G[v][u]=G[u][v];<br>cost[v][u]=cost[u][v];<br>&#125;<br><span class="hljs-built_in">Dijkstra</span>(st);<br><span class="hljs-built_in">DFS</span>(e);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,path[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,d[e],minCost);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="1018-Public-Bike-Management（Dijkstra）-⭐⭐⭐⭐⭐"><a href="#1018-Public-Bike-Management（Dijkstra）-⭐⭐⭐⭐⭐" class="headerlink" title="1018 Public Bike Management（Dijkstra）(⭐⭐⭐⭐⭐)"></a><strong>1018 Public Bike Management</strong>（Dijkstra）(⭐⭐⭐⭐⭐)</h2><p><strong>题目：（原题看官网）</strong></p><blockquote><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">10 3 3 5<br>6 7 0<br>0 1 1<br>0 2 1<br>0 3 3<br>1 3 1<br>2 3 1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">3 0-&gt;2-&gt;3 0<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><ul><li>  利用Dijkstra算法加上DFS进行求解会方便一些。</li><li>  首先利用Dijkstra算法先把pre数组和最短路进行求解，然后利用</li></ul><p><strong>代码：</strong>(不是满分·)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><br><span class="hljs-type">int</span> G[MAXN][MAXN];<br><span class="hljs-type">int</span> d[MAXN];<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-type">int</span> weight[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; path,tempPath;<br><br><span class="hljs-type">int</span> c_max,n,sp,m;<br><span class="hljs-type">int</span> minNeed=INF,minRemain=INF;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br>d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">-1</span>,min=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br><span class="hljs-keyword">if</span>(d[j]&lt;min&amp;&amp;vis[j]==<span class="hljs-literal">false</span>)&#123;<br>min=d[j];<br>u=j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(u==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ;<br>vis[u]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;=n;v++)&#123;<br><span class="hljs-keyword">if</span>(vis[v]==<span class="hljs-literal">false</span>&amp;&amp;G[u][v]!=INF)&#123;<br><span class="hljs-keyword">if</span>(d[u]+G[u][v]&lt;d[v])&#123;<br>d[v]=d[u]+G[u][v];<br>pre[v].<span class="hljs-built_in">clear</span>();<br>pre[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+G[u][v]==d[v])&#123;<br>pre[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">if</span>(v==<span class="hljs-number">0</span>)&#123;<br>tempPath.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-type">int</span> need=<span class="hljs-number">0</span>,remain=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=tempPath.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-type">int</span> id=tempPath[i];<br><span class="hljs-keyword">if</span>(weight[id]&gt;<span class="hljs-number">0</span>)&#123;<br>remain+=weight[id];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(remain&gt;<span class="hljs-built_in">abs</span>(weight[id]))&#123;<br>remain-=<span class="hljs-built_in">abs</span>(weight[id]);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>need+=(<span class="hljs-built_in">abs</span>(weight[i])-remain);<br>remain=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(need&lt;minNeed)&#123;<br>minNeed=need;<br>minRemain=remain;<br>path=tempPath; <br>&#125; <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(need==minNeed&amp;&amp;remain&lt;minRemain)&#123;<br>minRemain=remain;<br>path=tempPath;<br>&#125;<br>tempPath.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>tempPath.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pre[v].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-built_in">DFS</span>(pre[v][i]);<br>&#125;<br>tempPath.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;c_max,&amp;n,&amp;sp,&amp;m);<br><span class="hljs-type">int</span> u,v;<br><span class="hljs-built_in">fill</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;weight[i]);<br>weight[i]-=c_max/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;G[u][v]);<br>G[v][u]=G[u][v]; <br>&#125;<br><span class="hljs-built_in">Dijkstra</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">DFS</span>(sp);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,minNeed);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,path[i]);<br><span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,minRemain);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Bellman-ford算法"><a href="#Bellman-ford算法" class="headerlink" title="Bellman-ford算法"></a>Bellman-ford算法</h2><p>Dijkstra算法可以很好的解决无负权的最短路问题，但是对于有负权边，就需要使用Bellman算法。</p><p>Bellman算法需要设置一个数组d用来记录源点到达各个顶点的最短距离。并且将Bellman算法返回一个bool值，如果存在从源点可达的负环，那么函数将返回false。松弛操作不超过V-1次。</p><p><strong>代码：（利用邻接表实现）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> v,dis;<br>&#125;<br>vector&lt;Node&gt; Adj[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> d[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Bellman</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(d,d+MAXN,INf);<br>    d[s]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Adj[u].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> v=Adj[u][j].v;<br>                <span class="hljs-type">int</span> dis=Adj[u][j].dis;<br>                <span class="hljs-keyword">if</span>(d[u]+dis&lt;d[v])&#123;<br>                    d[v]=d[u]+dis;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Adj[u].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-type">int</span> v=Adj[u][j].v;<br>            <span class="hljs-type">int</span> dis=Adj[u][j].dis;<br>            <span class="hljs-keyword">if</span>(d[u]+dis&lt;d[v])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用Bellman-Ford编写A1003"><a href="#利用Bellman-Ford编写A1003" class="headerlink" title="利用Bellman-Ford编写A1003"></a>利用Bellman-Ford编写A1003</h2><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1000000000</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> v,dis;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _v,<span class="hljs-type">int</span> _dis) :<span class="hljs-built_in">v</span>(_v),<span class="hljs-built_in">dis</span>(_dis)&#123;&#125;<br>&#125;<br><span class="hljs-type">int</span> n,m,c1,c2;<br>vector&lt;Node&gt; Adj[MAXN];<br><span class="hljs-type">int</span> weight[MAXN]; <br><span class="hljs-type">int</span> d[MAXN];<br><span class="hljs-type">int</span> w[MAXN]; <br><span class="hljs-type">int</span> num[MAXN];<br><span class="hljs-type">bool</span> vis[MAXN]=&#123;<span class="hljs-literal">false</span>&#125;; <br>set&lt;<span class="hljs-type">int</span>&gt; pre[MAXN];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bellman</span> <span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(d,d+MAXN.INF);<br>    <span class="hljs-built_in">fill</span>(num,num+MAXN,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">fill</span>(w,w+MAXN,<span class="hljs-number">0</span>);<br>    d[s]=<span class="hljs-number">0</span>;<br>    w[s]=weight[s];<br>    num[s]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Adj[u].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> v=Adj[u][j].v;<br>                <span class="hljs-type">int</span> dis=Adj[u][j].dis;<br>                <span class="hljs-keyword">if</span>(d[u]+dis&lt;d[v])&#123;<br>                    d[v]=d[u]+dis;<br>                    w[v]=w[u]+weight[v];<br>                    num[v]=num[u];<br>                    pre[v].<span class="hljs-built_in">clear</span>();<br>                    pre[v].<span class="hljs-built_in">insert</span>(u);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[u]+dis==d[v])&#123;<br>                    <span class="hljs-keyword">if</span>(w[u]+weight[v]&gt;w[v])&#123;<br>                        w[v]=w[u]+weight[v];<br>                    &#125;<br>                    pre[v].<span class="hljs-built_in">insert</span>(u);<br>                    num[v]=<span class="hljs-number">0</span>;<br>                    set&lt;<span class="hljs-type">int</span>&gt;::isterator it;<br>                    <span class="hljs-keyword">for</span>(it=pre[v].<span class="hljs-built_in">begin</span>();it!=pre[v].<span class="hljs-built_in">end</span>();it++)&#123;<br>                        num[v]+=num[*it];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br><br><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;m,&amp;c1,&amp;c2);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;weight[i]);<br>&#125;<br><span class="hljs-built_in">fill</span>(G[<span class="hljs-number">0</span>],G[<span class="hljs-number">0</span>]+MAXN*MAXN,INF);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>Adj[a].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Node</span>(b,c));<br>        Adj[b].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Node</span>(a,c));<br>&#125;<br><span class="hljs-built_in">Bellman</span>(c1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,num[c2],w[c2]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>通过上面的作答发现只有当某个点的d[u]值发生变化的时候，从它出发的边的邻接点v的d[v]值才可能变化，所以可以建立一个队列，每次将队头u取出，然后对u出发的所有u-v边进行松弛处理，如果松弛处理后，也就是d[v]获得了更优的值，但是此时v不在队列中，就把v加入队列，这样操作直到队列为空或者某个顶点的入队次数超过了V-1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;Node&gt; Adj[MAXN];<br><span class="hljs-type">int</span> n,d[MAXN],num[MAXN];<br><span class="hljs-type">bool</span> inq[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(inq,inq+MAXN,<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">fill</span>(num,num+MAXN,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">fill</span>(d,d+MAXN,INF);<br>    queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>    Q.<span class="hljs-built_in">push</span>(s);<br>    inq[s]=<span class="hljs-literal">true</span>;<br>    num[s]++;<br>    d[s]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u=Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        inq[u]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Adj[u].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-type">int</span> v=Adj[u][j].v;<br>            <span class="hljs-type">int</span> dis=Adj[u][j].dis;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>客观评价模型——数学建模（四）</title>
    <link href="/2023/08/26/%E5%AE%A2%E8%A7%82%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/08/26/%E5%AE%A2%E8%A7%82%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="客观评价"><a href="#客观评价" class="headerlink" title="客观评价"></a>客观评价</h1><p>在数学建模中，经常会遇到评价类问题，在评价类模型的选择中要尽量规避主观模型，如层次分析法、模糊综合评价法、灰色关联分析法。潜台词是如果用这三种，评委老师是绝对不会给你高分。</p><p>那么在客观评价方面，我们也有许多模型可以使用，如主成分分析法、因子分析法、Topsis分析法、神经网络分析法等，接下去我将一一进行介绍和实际案例。</p><h2 id="主成分分析法"><a href="#主成分分析法" class="headerlink" title="主成分分析法"></a>主成分分析法</h2><p>**主成分分析（PCA)**是一种比较基础的数据降维方法，也是多元统计中的重要部分，在数据分析、机器学习等方面具有广泛应用。主成分分析目的是用较少的变量来代替原来较多的变量，并可以反映原来多个变量的大部分信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>评价类赛题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>竞赛C++使用——PAT备考进行时（二）</title>
    <link href="/2023/08/26/%E7%AB%9E%E8%B5%9BC-%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/08/26/%E7%AB%9E%E8%B5%9BC-%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C-使用指南"><a href="#C-C-使用指南" class="headerlink" title="C/C++使用指南"></a>C/C++使用指南</h1><ul><li>  基本数据类型</li></ul><table><thead><tr><th>类型</th><th>大致范围</th></tr></thead><tbody><tr><td>int</td><td>$-2<em>10^9$~$2</em>10^9$</td></tr><tr><td>longlong</td><td>$-9<em>10^{18}$~$9</em>10^{18}$</td></tr><tr><td>float</td><td>实际精度在6~7位</td></tr><tr><td>double</td><td>实际精度在15~16位</td></tr><tr><td>char</td><td>-128~+127</td></tr><tr><td>bool</td><td>0 or 1</td></tr></tbody></table><ul><li><p><strong>注：</strong></p><ul><li>  绝对值在$10^9$之内的整数都可以定义为int。</li><li>  不要用float，浮点数都用double。</li><li>  字符常量要用‘’括起来。</li></ul></li><li><p>  强制类型转换</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">（新类型）变量名<br></code></pre></td></tr></table></figure><ul><li><p>  getchar和putchar用来输入输出单个字符。</p></li><li><p>  数组的大小在$10^6$数量级的时候需要定义在主函数外面。</p></li><li><p>  memset用法：对数组中的每一个元素赋相同的值。memset需要加上cstring。使用memset赋值0或者-1，如果要赋值其他数字用fill函数。</p></li><li><p>  cstring和string不是同一个。</p></li><li><p>  gets和puts用来输入输出一行字符串。</p></li><li><p>cstring中的函数：</p><table><thead><tr><th>函数名</th><th>用法</th></tr></thead><tbody><tr><td>strlen()</td><td>得到字符串数组中第一个’\0’前的字符个数。</td></tr><tr><td>strcmp(s1,s2)</td><td>比较两个字符串</td></tr><tr><td>strcpy(s1,s2)</td><td>2复制到1</td></tr><tr><td>strcat(s1,s2)</td><td>2接到1后</td></tr></tbody></table></li><li><p>  sscanf和sprintf，sscanf是把字符数组中的内容传到n中，sprintf就是将值传入数组中。</p></li><li><p>  只有在string和vector中可以用vi.begin()+i这种迭代器加上整数的写法。</p></li><li><p>  除了vector和string之外的STL容器都不支持*(it+i)的访问方式。</p></li><li><p>  除了string的迭代器可以不写内部的容器，其他都要写：string ::iterator ,vector&lt;int&gt;::iterator。</p></li><li><p>  输入输出整个字符串，只能用cin,cout</p></li><li><p>  但是printf可以用c_str()函数将string类型转换为字符数组进行输出。</p></li><li><p>  map的键值对是唯一对应的，如果要一键对应多个值可以使用multimap。unorder_map速度比map速度要块。</p></li><li><p>priority_queue优先队列的用法：</p><ul><li><p>```c++<br>  priority_queue<int> q;<br>  priority_queue&lt;int ,vector<int>,less<int> &gt; q;//&gt;&gt;要分开</p><p>  默认优先级是数字大优先级越高，less<int>表示数字大的优先级的大，greater<int>表示数字小的优先级越大。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>-   对于结构体的优先级：<br><br>    ```c++<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">fruit</span>&#123;<br>        string name;<br>        <span class="hljs-type">int</span> price;<br>        <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;<br>            <span class="hljs-keyword">return</span> f1.price&lt;f2.price;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>  重载&lt;，不可以重载&gt;，return里和cmp函数相反，也就是&lt;表示价格高优先级高，&gt;表示价格高度优先级低。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学问题——PAT备考进行时（三）</title>
    <link href="/2023/08/22/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/08/22/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h1><h2 id="1069"><a href="#1069" class="headerlink" title="1069"></a>1069</h2><p><strong>题目：</strong></p><blockquote><p>  For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number <code>6174</code> – the <strong>black hole</strong> of 4-digit numbers. This number is named Kaprekar Constant.</p><p>  For example, start from <code>6767</code>, we’ll get:</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">7766</span> <span class="hljs-bullet">-</span> <span class="hljs-number">6677</span> <span class="hljs-string">=</span> <span class="hljs-number">1089</span><br><span class="hljs-number">9810</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0189</span> <span class="hljs-string">=</span> <span class="hljs-number">9621</span><br><span class="hljs-number">9621</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1269</span> <span class="hljs-string">=</span> <span class="hljs-number">8352</span><br><span class="hljs-number">8532</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2358</span> <span class="hljs-string">=</span> <span class="hljs-number">6174</span><br><span class="hljs-number">7641</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1467</span> <span class="hljs-string">=</span> <span class="hljs-number">6174</span><br><span class="hljs-string">...</span> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>  Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case which gives a positive integer <em>N</em> in the range (0,104).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  If all the 4 digits of <em>N</em> are the same, print in one line the equation <code>N - N = 0000</code>. Else print each step of calculation in a line until <code>6174</code> comes out as the difference. All the numbers must be printed as 4-digit numbers.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">6767<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">7766 - 6677 = 1089<br>9810 - 0189 = 9621<br>9621 - 1269 = 8352<br>8532 - 2358 = 6174<br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">2222<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">2222 - 2222 = 0000<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><p>这是一个简单题，但是坑还是挺多的，对于我这种菜鸡用了半小时，首先直接看到例子，都不用看题目，给出一个4位数，然后要求将其排序，要求一个将该数递增-该数递减，求出的数字用于作为下一个数字。</p><p>首先看到要用到排序，但是现在没法排序，因为也就是要把int转换为int[]，但是int[]又没法进行比较。所以还要转换成int进行比较。那么这样一来就需要先写两个函数，一个用于整数转整形数组，一个将数组转换成整数。</p><p>第二步，用一个循环判断number数是否是7641或者0，如果不是就一直循环下去。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">to_number</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span></span>&#123;<br><span class="hljs-type">int</span> number=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>number=number*<span class="hljs-number">10</span>+array[i];<br>&#125;<br><span class="hljs-keyword">return</span> number;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">to_array</span><span class="hljs-params">(<span class="hljs-type">int</span> number,<span class="hljs-type">int</span> array[])</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>array[i]=number%<span class="hljs-number">10</span>;<br>number/=<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> number,max,min;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;number);<br><span class="hljs-type">int</span> array[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">to_array</span>(number,array);<br><span class="hljs-built_in">sort</span>(array,array+<span class="hljs-number">4</span>,cmp);<span class="hljs-comment">//指向数组首地址 </span><br> max=<span class="hljs-built_in">to_number</span>(array);<br> <span class="hljs-built_in">sort</span>(array,array+<span class="hljs-number">4</span>);<br> min=<span class="hljs-built_in">to_number</span>(array);<br> number=max-min;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d - %04d = %04d\n&quot;</span>,max,min,number);<br> <span class="hljs-keyword">if</span>(number==<span class="hljs-number">6174</span>||number==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>  将数组传入函数体时，只需要传入数组首地址就可以，用数组形式接收。</li><li>  注意输出形式，如果要求4位，并且补全0，即为<code>%04d</code></li></ul><hr><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><p>记住以下结论和代码就可以了：</p><ul><li>  <strong>最大公约数：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> !b?a:<span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  <strong>最小公倍数</strong>就是<code>ab/d</code>（d为最大公约数）</li></ul><hr><h2 id="分数的表示和简化"><a href="#分数的表示和简化" class="headerlink" title="分数的表示和简化"></a>分数的表示和简化</h2><p>用一个结构体存储分数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fraction</span>&#123;<br>    <span class="hljs-type">int</span> up,down;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>规则如下：</strong></p><ul><li>  down为非负数，如果分数为负数，令up为负数。</li><li>  如果该分数为0，那么规定分子为0，分母为1。</li><li>  分子和分母没有除了1以外的公约数。</li></ul><p><strong>分母简化的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Fraction <span class="hljs-title">reduction</span><span class="hljs-params">(Fraction result)</span></span>&#123;<br><span class="hljs-keyword">if</span>(result.down&lt;<span class="hljs-number">0</span>)&#123;<br>result.up=-result.up;<br>result.down=-result.down;<br>&#125;<br><span class="hljs-keyword">if</span>(result.up=<span class="hljs-number">0</span>)&#123;<br>result.down=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> d=<span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(result.up),<span class="hljs-built_in">abs</span>(result.down));<br>result.up/=d;<br>result.down/=d;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分数加法：</strong><br>$$<br>result=\frac{f1.up<em>f2.down+f2.up</em>f1.down}{f1.down*f2.down}<br>$$<br><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//分数加法</span><br><span class="hljs-function">Fraction <span class="hljs-title">add</span><span class="hljs-params">(Fraction f1,Fraction f2)</span></span>&#123;<br>Fraction result;<br>result.up=f1.up*f2.down+f2.up*f1.down;<br>result.down=f1.down*f2.down;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">reduction</span>(result);<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>分数的输出：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showResult</span><span class="hljs-params">(Fraction r)</span></span>&#123;<br>r=<span class="hljs-built_in">reduction</span>(r);<br><span class="hljs-keyword">if</span>(r.down==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,r.up);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(r.up)&gt;r.down)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d/%d&quot;</span>,r.up /r.down,<span class="hljs-built_in">abs</span>(r.up)%r.down,r.down);<br><br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/%d&quot;</span>,r.up,r.down);<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注意：分子分母最好用longlong存储。</strong></p><hr><h2 id="素数和质因子"><a href="#素数和质因子" class="headerlink" title="素数和质因子"></a>素数和质因子</h2><p><strong>素数：</strong></p><ul><li>  素数的判断到$\sqrt{n}$即可。</li><li>  如果是用<code>i*i</code>作为上界判断，注意用longlong。</li><li>  利用筛法进行求解素数。</li></ul><p><strong>质因子：</strong></p><ul><li><p>  1不是素数，没有质因子。</p></li><li><p>fac数组只需要开到10</p><ul><li><p>fac数组的结构体：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">factor</span>&#123;<br>    <span class="hljs-type">int</span> x,cnt;<br>&#125;fac[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure></li></ul></li><li><p>  如果存在1和本身之外的因子，一定实在sqrt(n)的左右成对出现。</p></li><li><p>解题思路：</p><ul><li>  枚举1-sqrt(n)的所有质因子p，判断p是否是n的因子。</li><li>  如果p是n的因子，就给fac数组增加质因子p，并且初始化个数为0，然后，只要p还是n的因子，就让n不断的除以p，每次操作p 的个数+1，知道p不再是n的因子。</li><li>  如果p不是n的因子，就直接跳过。</li><li>  如果上面步骤结束以后n还是&gt;1,说明n有且仅有一个大于sqrt(n)的质因子，这时候把这个质因子加入fac数组，并且令其个数为1。</li></ul></li></ul><h2 id="1059"><a href="#1059" class="headerlink" title="1059"></a>1059</h2><p><strong>题目：</strong></p><blockquote><p>  Given any positive integer <em>N</em>, you are supposed to find all of its prime factors, and write them in the format <em>N</em> = $p1^{k1}<em>p2^{k2}</em>…*pm^{km}$</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case which gives a positive integer <em>N</em> in the range of <strong>long int</strong>.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  Factor <em>N</em> in the format <em>N</em> <code>=</code> <em>p</em>1<code>^</code><em>k</em>1<code>*</code><em>p</em>2<code>^</code><em>k</em>2<code>*</code>…<code>*</code><em>p**m</em><code>^</code><em>k**m</em>, where <em>p**i</em>‘s are prime factors of <em>N</em> in increasing order, and the exponent <em>k**i</em> is the number of <em>p**i</em> – hence when there is only one <em>p**i</em>, <em>k**i</em> is 1 and must <strong>NOT</strong> be printed out.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">97532468<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">97532468=2^2*11*17*101*1291<br></code></pre></td></tr></table></figure></blockquote><p><strong>单词积累：</strong></p><p>prime factors——素因子</p><p><strong>分析：</strong></p><ul><li>  题目中给的素数的范围是int范围，所以素数表只需要$10^5$就可以。</li><li>  当n==1的时候，需要特判。</li><li>   在处理完质因子后要判断n是否是1，如果不是1，则需要处理大于sqrt(n)的部分。</li></ul><p><strong>步骤：</strong></p><p>（1）生成素数表。</p><p>（2）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">//判断是否是素数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> sqr=(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>*n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=sqr;i++)&#123;<br><br><span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br><br><span class="hljs-comment">//素数表</span><br><span class="hljs-type">int</span> prime[maxn],pNum=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Prime</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;maxn;i++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(i)==<span class="hljs-literal">true</span>)&#123;<br>prime[pNum++]=i;<br>&#125;<br>&#125;<br>&#125; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">factor</span>&#123;<br><span class="hljs-type">int</span> x,cnt;<br>&#125;fac[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">Find_Prime</span>();<br><span class="hljs-type">int</span> n , num =<span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1=1&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d=&quot;</span>,n);<br><span class="hljs-type">int</span> sqr=(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>*n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pNum&amp;&amp;prime[i]&lt;=sqr;i++)&#123;<br><span class="hljs-keyword">if</span>(n%prime[i]==<span class="hljs-number">0</span>)&#123;<br>fac[num].x=prime[i];<br>fac[num].cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n%prime[i]==<span class="hljs-number">0</span>)&#123;<br>fac[num].cnt++;<br>n/=prime[i];<br>&#125;<br>num++;<br>&#125;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br><br>&#125;<br><span class="hljs-keyword">if</span>(n!=<span class="hljs-number">1</span>)&#123;<br>fac[num].x=n;<br>fac[num++].cnt=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br><span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,fac[i].x);<br><span class="hljs-keyword">if</span>(fac[i].cnt&gt;<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;^%d&quot;</span>,fac[i].cnt);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>  <code>int sqr=(int)sqrt(1.0*n);</code>平方根的时候要这么写，记住就好。</li></ul><hr><h2 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h2><ul><li>  大整数使用数组进行记录即可。整数的高位存储在数组的高位，整数的低位存储在数组的低位。但是在读入的时候需要进行反转。</li></ul><p><strong>代码：（A+B）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bignum</span>&#123;<br><span class="hljs-type">int</span> nums[<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-built_in">bignum</span>()&#123;<br><span class="hljs-built_in">memset</span>(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(nums));<br>len=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function">bignum <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>&#123;<br>bignum a;<br>a.len=<span class="hljs-built_in">strlen</span>(str);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.len;i++)&#123;<br>a.nums[i]=str[a.len-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function">bignum <span class="hljs-title">add</span><span class="hljs-params">(bignum a,bignum b)</span></span>&#123;<br>bignum c;<br><span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;<br><span class="hljs-type">int</span> temp=a.nums[i]+b.nums[i]+carry;<br>c.nums[c.len++]=temp%<span class="hljs-number">10</span>;<br>carry=temp/<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(carry!=<span class="hljs-number">0</span>)&#123;<br>c.nums[c.len++]=carry;<br><br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(bignum a)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a.nums[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">char</span> str1[<span class="hljs-number">1000</span>],str2[<span class="hljs-number">1000</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s&quot;</span>,str1,str2);<br>bignum a=<span class="hljs-built_in">change</span>(str1);<br>bignum b=<span class="hljs-built_in">change</span>(str2);<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">add</span>(a,b));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据预处理——数学建模（三）</title>
    <link href="/2023/08/17/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/08/17/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="数据归一化处理"><a href="#数据归一化处理" class="headerlink" title="数据归一化处理"></a>数据归一化处理</h2><p>数据归一化是为了使得不同量纲通过归一化调整到同一量纲，寻求最优解的过程会变得平缓，可以更快速的收敛到最优解。</p><h3 id="归一化方法"><a href="#归一化方法" class="headerlink" title="归一化方法"></a>归一化方法</h3><p>1、<em>Min-max normalization</em> (Rescaling)：<br>$$<br>x’=\frac{x-min(x)}{max(x)-min(x)}<br>$$<br>归一化后的数据范围为 [0, 1]，其中 min(x)、max(x)分别求样本数据的最小值和最大值。</p><p>2、Mean normalization：<br>$$<br>x’=\frac{x-mean(x)}{max(x)-min(x)}<br>$$<br>归一化后的数据范围为 [-1, 1]，其中 mean(x)为样本数据的平均值。</p><p>3、Z-score normalization (Standardization)：<br>$$<br>x’=\frac{x-\mu}{\sigma}<br>$$<br>归一化后的数据范围为实数集，其中 μ、σ 分别为样本数据的均值和标准差。</p><ol><li><p>非线性归一化：</p><ul><li>  对数归一化：</li></ul><p> $$<br>x’=\frac{\lg x}{\lg max(x)}<br> $$</p><ul><li>  反正切函数归一化：</li></ul><p> $$<br> x’=\arctan(x)*\frac{2}{\pi}<br> $$</p><p> 归一化后的数据范围为 [-1, 1]。</p><ul><li>  小数定标标准化:</li></ul><p> $$<br> x’=\frac{x}{10^j}<br> $$</p><p> 归一化后的数据范围为 [-1, 1]，j为使max(|x′|)&lt;1的最小整数。</p></li></ol><h3 id="归一化和标准化总结"><a href="#归一化和标准化总结" class="headerlink" title="归一化和标准化总结"></a>归一化和标准化总结</h3><ul><li><p>  Min-max归一化和mean归一化适合在<strong>最大最小值明确不变</strong>的情况下使用。如果有过大或过小的异常值存在，min-max归一化和mean归一化的效果也不会很好。</p></li><li><p>  Z-score归一化也可称为标准化，经过处理的数据呈均值为0，标准差为1的分布。在数据存在异常值、最大最小值不固定的情况下，可以使用标准化。</p></li><li><p>  standardization其实就是z-score normalization，所以标准化就是归一化的一种。</p></li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/normalization/basic_normalization.html">https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/normalization/basic_normalization.html</a></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>数据预处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>数据预处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相关性分析方法——数学建模（二）</title>
    <link href="/2023/08/17/%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/08/17/%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="相关性分析"><a href="#相关性分析" class="headerlink" title="相关性分析"></a>相关性分析</h1><p>相关分析是统计学和数据分析领域中常用的方法，用于确定两个或多个变量之间的关系以及它们之间的相互影响程度。以下是一些常见的相关分析方法：</p><ol><li> <strong>皮尔逊相关系数：</strong> 皮尔逊相关系数衡量了两个连续变量之间的线性关系强度和方向。它的取值范围在 -1 到 1 之间，其中 -1 表示完全负相关，1 表示完全正相关，0 表示无相关性。</li><li> <strong>斯皮尔曼等级相关系数：</strong> 斯皮尔曼相关系数是一种用于衡量两个变量之间的单调关系的方法，而不仅仅是线性关系。它基于变量的等级而不是具体的数值，因此对于非线性关系也适用。</li><li> <strong>判定系数（R²）：</strong> 判定系数是用于衡量一个回归模型对观测数据的拟合程度。它的取值范围在0到1之间，越接近1表示模型拟合得越好。</li><li> <strong>卡方检验：</strong> 卡方检验主要用于分析分类变量之间的关系，特别是在两个或多个分类变量之间是否存在统计显著的关联。</li><li> <strong>ANOVA（方差分析）：</strong> 方差分析用于比较多个组之间的均值差异是否显著，适用于一个因变量和一个或多个分类变量的情况。</li><li> <strong>回归分析：</strong> 回归分析用于建立一个或多个自变量与因变量之间的关系模型，可以帮助预测因变量的值。</li><li> <strong>因子分析：</strong> 因子分析用于确定隐藏在观测数据背后的潜在因子，从而帮助简化数据集并揭示变量之间的模式。</li><li> <strong>主成分分析：</strong> 主成分分析旨在将高维数据降维到较低维度，同时保留尽可能多的原始数据变异性。</li></ol><h2 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h2><p>Pearson相关系数公式如下：</p><p><img src="/../images/95c7b4484dc46f28390c4de96c83b915_1440w.webp" alt="img"></p><p>协方差是一个反映两个<strong>随机变量</strong>相关程度的指标：<br><img src="https://picx.zhimg.com/80/0dfac74fd0cc7e4670fc04e15a5d79e2_1440w.webp?source=1940ef5c" alt="img"></p><p>pearson是一个介于-1和1之间的值，当两个变量的线性关系增强时，相关系数趋于1或-1；当一个变量增大，另一个变量也增大时，表明它们之间是正相关的，相关系数大于0；如果一个变量增大，另一个变量却减小，表明它们之间是负相关的，相关系数小于0；如果相关系数等于0，表明它们之间不存在线性相关关系。</p><p>pearson系数通常同于两个连续性变量之间的相关性。</p><h2 id="斯皮尔曼等级相关系数"><a href="#斯皮尔曼等级相关系数" class="headerlink" title="斯皮尔曼等级相关系数"></a>斯皮尔曼等级相关系数</h2><p>若两变量中包含等级变量，或变量不符合正态分布，或变量分布类型未知时，可以采用另一种相关性分析方法——Spearman等级相关性分析。</p><p><strong>适用条件</strong></p><ul><li>  变量包含等级变量、或变量不服从正态分布或分布类型未知。</li><li>  两变量之间存在单调关系。</li></ul><p><strong>统计量计算</strong></p><p>计算Spearman相关系数$r_{s}$的过程为:</p><ul><li>  先将变量<em>X</em>、<em>Y</em>分别从小到大排序编秩，用秩次<em>RX</em>和<em>RY</em>表示。</li></ul><p><img src="/../images/image-20230824103217446.png" alt="image-20230824103217446"></p><ul><li>  与Pearson相关系数的计算公式对比， Spearman相关系数的计算公式只是将Pearson相关系数公式中的<em>X</em>、<em>Y</em>替换为了<em>R**X</em>、<em>R**Y</em>.</li></ul><p><strong>假设检验</strong></p><p>样本含量<em>n</em>的大小有两种方法,查表法和t检验。</p><p><strong>参考文献：</strong></p><p><a href="https://mengte.online/archives/1879">https://mengte.online/archives/1879</a></p><h2 id="决定系数（R²）"><a href="#决定系数（R²）" class="headerlink" title="决定系数（R²）"></a>决定系数（R²）</h2><p>对于简单线性回归而言，决定系数为样本相关系数的平方。当加入其他回归自变量后，决定系数相应地变为多重相关系数的平方。</p><p><img src="/../images/image-20230824104619549.png" alt="image-20230824104619549"></p><h2 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h2><p><strong>什么是独立性卡方检验？</strong></p><p>独立性卡方检验是一种统计学上的假设检验，用于确定两个分类型或名义型变量是否可能相关。</p><p><strong>何时可以使用该检验？</strong></p><p>当您有两个分类型变量的值计数时，您可以使用独立性卡方检验。</p><p><strong>如果有一个频数计数表格，是否可以使用该检验？</strong></p><p>是的。如果您只有一个表格，其中的值显示频数计数，您可以使用独立性卡方检验。</p><p><strong>参考文献：</strong></p><p><a href="https://www.jmp.com/zh_cn/statistics-knowledge-portal/chi-square-test/chi-square-test-of-independence.html">https://www.jmp.com/zh_cn/statistics-knowledge-portal/chi-square-test/chi-square-test-of-independence.html</a></p><h2 id="ANOVA（方差分析）"><a href="#ANOVA（方差分析）" class="headerlink" title="ANOVA（方差分析）"></a>ANOVA（方差分析）</h2><h3 id="单因素方差分析（one-way-ANOVA"><a href="#单因素方差分析（one-way-ANOVA" class="headerlink" title="单因素方差分析（one-way ANOVA)"></a>单因素方差分析（one-way ANOVA)</h3>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>相关性分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>相关性分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>层次分析法——数学建模（一）</title>
    <link href="/2023/08/13/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/08/13/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h1><p><img src="/../images/fb4a24c19b1bb68aab3ccea101551815.png" alt="img"></p><h2 id="AHP层次分析法过程"><a href="#AHP层次分析法过程" class="headerlink" title="AHP层次分析法过程"></a>AHP层次分析法过程</h2><p>层次分析法就是将一个决策事件分解为<em>目标层</em>（例如选择旅游地），<em>准则层</em>（影响决策的因素，例如景色、交通、费用等）以及<em>方案层</em>（指的是方案，例如去广州、桂林等地旅游）。</p><p><img src="/../images/30dd8e4cdafed2d56d337794fa610dcb.png" alt="img"></p><p><strong>建立步骤：</strong></p><ol><li> 层次结构模型的构建。</li><li> 构造判断矩阵</li><li> 层次单排序及其一致性检验</li><li> <em>层次总排序</em>及其一致性检验</li></ol><p><strong>PS:</strong></p><p>一致性检验的含义用于确定构建的判断矩阵是否存在逻辑问题。</p><h3 id="1-层次结构模型的构建。"><a href="#1-层次结构模型的构建。" class="headerlink" title="1.层次结构模型的构建。"></a>1.层次结构模型的构建。</h3><p>确认整个决策事件的<em>目标层、准则层、方案层</em></p><p><img src="/../images/6e02b047d20c941c29e57c4a356f7571.png" alt="img"></p><p>目标层：最优旅游地选择</p><p>准则层：景色、费用、居住、饮食、旅途</p><p>方案层：西安、云南、西藏、青海</p><p>如果有多层：</p><p><img src="/../images/d476b972c13221d3e1223b1fd5d6782b.png" alt="img"></p><h3 id="2-构造判断矩阵"><a href="#2-构造判断矩阵" class="headerlink" title="2.构造判断矩阵"></a>2.构造判断矩阵</h3><p>通过各要素之间相互两两比较，并确定各准则层对目标层的权重。</p><p><img src="/../images/ea5d74f7b48afd3f446c78866c212d09.png" alt="img"></p><p>建立一个矩阵：</p><p><img src="/../images/25047e173e25a3d231b007b305247000.png" alt="img"></p><p>A中元素满足：</p><img src="../images/f92cd151513ab425201d920e35c56b98.png" alt="img" style="zoom: 50%;" /><h3 id="3-层次单排序与一致性检验"><a href="#3-层次单排序与一致性检验" class="headerlink" title="3.层次单排序与一致性检验"></a>3.层次单排序与一致性检验</h3><ul><li>  <strong>step1：层次单排序</strong></li></ul><p>指针对上一层某元素将本层中所有元素两两评比，并开展层次排序， 进行重要顺序的排列。</p><p>具体计算可依据判断矩阵 A 进行，计算中确保其能够符合 <strong>AW=𝜆𝑚𝑎𝑥𝑊</strong>的特征根和特征向量条件。在此，A 的最大特征根为<strong>λmax</strong>，对应λmax的正规化的特征向量为 <strong>W</strong>，𝑤𝑖为 W 的分量，其指的是权值，与其相应元素单排序对应。 利用判断矩阵计算各因素𝑎𝑖𝑗对目标层的权重（权系数）。</p><p><img src="/../images/f8b7627588f5b4c005b46c91ddcc5762.png" alt="img"></p><ul><li>  step2：求解最大特征根与CI值</li></ul><p><img src="/../images/8f9edf32bb6445d16b6c8009929d4868.png" alt="img"></p><p>C.I.=0 表示判断矩阵完全一致，C.I.越大，判断矩阵的不一致性程度越严重。</p><ul><li>  step3：根据CI、RI值求解CR值，判断其一致性是否通过</li></ul><p> 模拟 1000 次得到的随机一致性指标 R.I.取值表：</p><p><img src="/../images/ea5f4db7cb5744c1fc697ee8ca95c4f2.png" alt="img"></p><p>当 C.R.&lt;0.1 时，表明判断矩阵 A 的一致性程度被认为在容许的范围内，此时可 用 A 的特征向量开展权向量计算；若 C.R.≥0.1, 则应考虑对判断矩阵 A 进行修正。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>层次分析法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒杀模拟题——PAT备考进行时（一）</title>
    <link href="/2023/08/11/%E7%A7%92%E6%9D%80%E6%A8%A1%E6%8B%9F%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/08/11/%E7%A7%92%E6%9D%80%E6%A8%A1%E6%8B%9F%E9%A2%98%E2%80%94%E2%80%94PAT%E5%A4%87%E8%80%83%E8%BF%9B%E8%A1%8C%E6%97%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟题不简单"><a href="#模拟题不简单" class="headerlink" title="模拟题不简单"></a>模拟题不简单</h1><h2 id="1042-Shuffling-Machine"><a href="#1042-Shuffling-Machine" class="headerlink" title="1042 Shuffling Machine"></a><strong>1042 Shuffling Machine</strong></h2><p><strong>题目：</strong></p><blockquote><p>  Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ <strong>automatic shuffling machines</strong>. Your task is to simulate a shuffling machine.</p><p>  The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p>  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">S1</span></span>, S2, ..., S13, <br><span class="hljs-function"><span class="hljs-title">H1</span></span>, H2, ..., H13, <br><span class="hljs-function"><span class="hljs-title">C1</span></span>, C2, ..., C13, <br><span class="hljs-function"><span class="hljs-title">D1</span></span>, D2, ..., D13, <br>J1, J2<br></code></pre></td></tr></table></figure><p>  where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the <em>i</em>-th position is <em>j</em>, it means to move the card from position <em>i</em> to position <em>j</em>. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>  Each input file contains one test case. For each case, the first line contains a positive integer <em>K</em> (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>  For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">2<br>36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><p>首先是英语的阅读，会造成一定的困扰，所以一开始读题目就可以去看给的例子，然后代入题目去理解，注意所有细节，包括但是不限于数据格式，大小。</p><p>这题的难度其实不大，就是一个简单的模拟题，但是，找准next和end数组非常关键。要注意花色和编号的对应关系，，并且注意格式输出，包括空格。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> size=<span class="hljs-number">54</span>;<br><span class="hljs-type">char</span> flower[<span class="hljs-number">5</span>]=&#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;H&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;J&#x27;</span>&#125;;<br><span class="hljs-type">int</span> start[size+<span class="hljs-number">1</span>],next[size+<span class="hljs-number">1</span>],end[size+<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>        start[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;next[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>        end[next[i]]=start[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>            start[i]=end[i];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        start[i]--;<span class="hljs-comment">//看这里</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%d&quot;</span>,flower[start[i]/<span class="hljs-number">13</span>],start[i]%<span class="hljs-number">13</span>+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中主要注意标记处，为什么要start[i]–;因为举个例子，标号为13的对应是S13,但是如果进行start[i]/13,就会得到1。不过也可以进行下面的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%d&quot;</span>,flower[(start[i]<span class="hljs-number">-1</span>)/<span class="hljs-number">13</span>],(start[i]<span class="hljs-number">-1</span>)%<span class="hljs-number">13</span>+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="1046-Shortest-Distance"><a href="#1046-Shortest-Distance" class="headerlink" title="1046 Shortest Distance"></a><strong>1046 Shortest Distance</strong></h2><p><strong>题目：</strong></p><blockquote><p>The task is really simple: given <em>N</em> exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <em>N</em> (in [3,105]), followed by <em>N</em> integer distances <em>D</em>1 <em>D</em>2 ⋯ <em>D**N</em>, where <em>D**i</em> is the distance between the <em>i</em>-th and the (<em>i</em>+1)-st exits, and <em>D**N</em> is between the <em>N</em>-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer <em>M</em> (≤104), with <em>M</em> lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to <em>N</em>. It is guaranteed that the total round trip distance is no more than 107.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print your results in <em>M</em> lines, each contains the shortest distance between the corresponding given pair of exits.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">&gt;5 1 2 4 14 9<br>&gt;3<br>&gt;1 3<br>&gt;2 5<br>&gt;4 1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">&gt;3<br>&gt;10<br>&gt;7<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析：</strong></p><p>一个圆中要找到两个点之间最近的路无非是两个路径看看谁的长，但是本题中数据较大，所以需要对数据进行预处理，否则拿不了最后一个测试点。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> dis[MAXN],A[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,query,n,left,right;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;A[i]);<br>        sum+=A[i];<br>        dis[i]=sum;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;query);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;query;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;left,&amp;right);<br>        <span class="hljs-keyword">if</span>(left&gt;right)<span class="hljs-built_in">swap</span>(left,right);<br>        <span class="hljs-type">int</span> temp=dis[right<span class="hljs-number">-1</span>]-dis[left<span class="hljs-number">-1</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">min</span>(temp,sum-temp));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="1001-A-B-Format"><a href="#1001-A-B-Format" class="headerlink" title="1001 A+B Format"></a>1001 <strong>A+B Format</strong></h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学模型与常用算法汇总</title>
    <link href="/2023/07/03/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/2023/07/03/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>数学建模常用算法汇总</p><h2 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h2><p><img src="https://img-blog.csdnimg.cn/ff05f94f8a7d4f3790dac84aa43b2b3a.png" alt="ff05f94f8a7d4f3790dac84aa43b2b3a.png"></p><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p><img src="https://img-blog.csdnimg.cn/20200831100037916.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200831100112161.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模2023--知耻而后勇</title>
    <link href="/2023/06/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A12023-%E7%9F%A5%E8%80%BB%E8%80%8C%E5%90%8E%E5%8B%87/"/>
    <url>/2023/06/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A12023-%E7%9F%A5%E8%80%BB%E8%80%8C%E5%90%8E%E5%8B%87/</url>
    
    <content type="html"><![CDATA[<h1 id="2023数学建模国赛预备"><a href="#2023数学建模国赛预备" class="headerlink" title="2023数学建模国赛预备"></a>2023数学建模国赛预备</h1><h2 id="总结失败"><a href="#总结失败" class="headerlink" title="总结失败"></a>总结失败</h2><p>从上一年的比赛中，看出了非常多的问题，首先是队友配合不默契，加上前期的准备不充分，造成了从开始比赛到结束的整一个过程中都非常的混乱。最后只有一个小奖。下面就是我对上一年的失败总结。</p><p>关于团队，如果一个团队没有一个好的领导能力的人进行统筹兼顾，那将会造成一个非常严重的问题，那就是做事没有节奏和秩序。关于队员的分工，按照论文手、建模手、编程手来分会造成严重的错误，那就是各自不知道对方在说什么，同时也会造成论文表达的错误，在之前一次的数学建模比赛中我们就出现了这样类似的严重的错误。所以本次比赛，我想的是最好采用各分其职，但是互相交互。也就是论文手也需要准备算法的了解，但是可以不必深入，只是需要知道这个算法是干什么的。当然，这里我们不详细讨论分工，下文会详细说明。</p><p>还有就是在比赛的时候的时间分配以及题目的选择，关于题目，最好选自己最熟悉的或者有思路的题目，一旦开始解题就不要轻易改变，绝对一点，别改题目，会出大事。这就需要前期的大量练习来得知自己最熟练哪些题目。</p><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><p>既然是一个团队比赛，那就必须要进行一个合理的分工，前面我讲到不能够分而治之，而是要互相交互。同样的，总的来说来说还是要进行明确的分工，也就是建模手、编程手、论文手。接下去我就讲讲我认为每个职位对应的职责。</p><h3 id="论文手"><a href="#论文手" class="headerlink" title="论文手"></a>论文手</h3><p>虽然我没有当过论文手，但是我足以知道一个好的论文手需要具备哪些能力。论文其实大家都没怎么写过，当然佬除外。先说说数学建模中一篇好论文意味着什么？</p><p>好吧，意味着一切。因为评分就是看论文（手动狗头）。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>大学比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>还分不清Session、Cookie、Token？进来看</title>
    <link href="/2023/06/27/%E8%BF%98%E5%88%86%E4%B8%8D%E6%B8%85Session%E3%80%81Cookie%E3%80%81Token%EF%BC%9F%E8%BF%9B%E6%9D%A5%E7%9C%8B/"/>
    <url>/2023/06/27/%E8%BF%98%E5%88%86%E4%B8%8D%E6%B8%85Session%E3%80%81Cookie%E3%80%81Token%EF%BC%9F%E8%BF%9B%E6%9D%A5%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如果给你每天一个小时学技术，怎么学最高效</title>
    <link href="/2023/06/24/%E5%A6%82%E6%9E%9C%E7%BB%99%E4%BD%A0%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%AD%A6%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AD%A6%E6%9C%80%E9%AB%98%E6%95%88/"/>
    <url>/2023/06/24/%E5%A6%82%E6%9E%9C%E7%BB%99%E4%BD%A0%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%AD%A6%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AD%A6%E6%9C%80%E9%AB%98%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h1 id="怎么学技术最快"><a href="#怎么学技术最快" class="headerlink" title="怎么学技术最快"></a>怎么学技术最快</h1><p>今天我们来聊一聊怎么学习一门技术，从只有听说过或者了解到到快速入门、精通原理。</p><p>说实话，其实我的学习能力真的太弱了，学习一个基础知识或者语言框架都太慢了，甚至会出现拖沓的现象，特别是最近在准备研究生考试，感觉每天根本抽不出时间来学习，每次都是打开idea，打开虚拟机，打开官方文档，然后就半小时过去了，既没有学习到东西又浪费了时间。而且有时候可能一个bug就会消耗几个小时，这些问题对于现在的我都是致命的，所以我们就来讨论一下怎么可以及快速又准确的学会知识。</p><h2 id="一切服务于代码"><a href="#一切服务于代码" class="headerlink" title="一切服务于代码"></a>一切服务于代码</h2><p>为什么我们学东西慢，要追究这个问题，我认为还得是中国的教育问题，因为我们就好像已经适应了先去学习理论，一定要等到理论满分才开始实践，这重学习方法在编程领域绝对是100%的错误，因为没有一个人能够从那些晦涩难懂的厚重的教材中快速的找到应该掌握的知识，当然，现在非常多的教育机构和视频课程手把手的教学编程，可是你扪心自问，那些课听了以后有收获吗？我这里说的是只听课，把听课当作是刷剧的那些人，真的能够学到知识吗，当然几个月之前的我就是这样子的。</p><p>编程的核心是什么？是数据结构与算法。哈哈哈哈，但是这里说的是学习新的框架技术。学习框架技术这些最最最需要的是什么，是实践，是实打实的敲代码。</p><h2 id="如果快速入门一门编程技术"><a href="#如果快速入门一门编程技术" class="headerlink" title="如果快速入门一门编程技术"></a>如果快速入门一门编程技术</h2><p>当然我口头说的大家会觉得没有用，我接下来会在每天的9点到10点进行编程的学习，就是学习我之前没有接触过的技术，并且每天都会更新学习动态。其实我一直都想深入的学习一下Redis，但是每次都是浅浅的学习和使用，可以说我还是停留在应用阶段，所以接下去的一个星期我会进行Redis的系统学习，一下就是我的计划：</p><ul><li>  Day1：以黑马点评项目入手，看懂Redis在这个项目中的应用，并且对关键的代码进行复刻和总结。</li><li>  Day2：重复Day1的工作，并且完成重点和难点分析，追踪源码进行大概分析如何实现。</li><li>  Day3：对照项目和官方文档，进行系统的基础梳理和归纳（目标是快速编写总结博客），基础入门结束。</li><li>  Day4-Day6：Redis官方进阶文档并且查找实际项目案例。</li><li>  Day7：Redis面试题进行查漏补缺，并且进行总结性文档编写。</li></ul>]]></content>
    
    
    <categories>
      
      <category>聊一聊技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闲聊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一周学完Redis——Day1</title>
    <link href="/2023/06/18/%E4%B8%80%E5%91%A8%E5%AD%A6%E5%AE%8CRedis%E2%80%94%E2%80%94Day1/"/>
    <url>/2023/06/18/%E4%B8%80%E5%91%A8%E5%AD%A6%E5%AE%8CRedis%E2%80%94%E2%80%94Day1/</url>
    
    <content type="html"><![CDATA[<h1 id="一周学完Redis（一）"><a href="#一周学完Redis（一）" class="headerlink" title="一周学完Redis（一）"></a>一周学完Redis（一）</h1><h2 id="Redis的命令"><a href="#Redis的命令" class="headerlink" title="Redis的命令"></a>Redis的命令</h2><ul><li>  客户端的基础命令</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">redis-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ul><li>  如果是远程Redis服务上执行命令</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">redis-cli -h host -<span class="hljs-selector-tag">p</span> port -<span class="hljs-selector-tag">a</span> password<br></code></pre></td></tr></table></figure><p><a href="https://redis.com.cn/commands.html">Redis命令大全</a></p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>众所周知，Redis是一个键值对的数据结构存储的数据库。</p><p>其中有几个key的关键命令：</p><ul><li><p>  DEL KEY_NAME //删除key</p></li><li><pre><code class="hljs">  EXISTS KEY_NAME</code></pre><p>  检查给定 key 是否存在<br>  1 key存在<br>  0 key不存在<br>时间复杂度: O(1)</p></li><li><p>EXPIRE key seconds<br>  命令设置 key 的过期时间</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>一周学完Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>一周学完Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaIO机制全解——Java基础篇（七）</title>
    <link href="/2023/06/18/JavaIO%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2023/06/18/JavaIO%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java接口和内部类全解——Java基础篇（六）</title>
    <link href="/2023/06/18/Java%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2023/06/18/Java%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><ul><li>接口是由全局常量和公共抽象方法组成，接口中集合了抽象方法，在java8之前，我们可以把接口理解为100%的抽象类，即接口中的方法都是抽象方法，Java设计接口的目的在于解决Java无法多继承，但是接口在实际的使用中常常是用来制定标准的。</li><li>一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。</li><li>接口不能被实例，但是可以被实现，实现类需要100%实现一个接口中所有的方法。</li><li>如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：<strong>抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类</strong>）</li><li>接口被用来实现抽象，而抽象类也被用来实现抽象，为什么一定要用接口呢？接口和抽象类之间又有什么区别呢？原因是抽象类内部可能包含非final的变量，但是在接口中存在的变量一定是final，public,static的。</li><li>一个类可以实现多个接口。</li><li>一个接口可以继承另一个接口，或者另一些接口，也就是可以多继承。</li><li>接口也可以用来实现解耦。</li></ul><h2 id="接口中的多态"><a href="#接口中的多态" class="headerlink" title="接口中的多态"></a>接口中的多态</h2><p>举一个小例子：</p><p>​    现在我们要对空调进行接口统一的管理，有一个“节能”的功能，或者说”节能”就是一个接口，这个接口中有一个方法叫做”变频方法“，任何节能空调，都需要实现这个接口，并且要实现”变频方法“这个方法。当某个空调实现了这样一个”节能“接口后，该空调就具有节能的功能。这时候，我们不需要用空调类引用指向空调对象，而是可以用“节能接口”引用的遥控器去指向空调对象。也就是多态，通过向上转型，我们去通过操作遥控器的“变频方法”去命令空调调用“变频”方法。</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类顾名思义就是在类里的类。</p><h2 id="为什么使用内部类"><a href="#为什么使用内部类" class="headerlink" title="为什么使用内部类"></a>为什么使用内部类</h2><ul><li>内部类方法可以访问该类定义所在的作用域的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码的时候，使用匿名内部类比较便捷。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java继承全解——Java基础篇（五）</title>
    <link href="/2023/06/18/Java%E7%BB%A7%E6%89%BF%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2023/06/18/Java%E7%BB%A7%E6%89%BF%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是面向对象编程的三大特性之一。继承主要就是子类从父类继承特性与行为使得子类对象拥有父类的实例方法和属性。</p><h2 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h2><p>通过继承可以快速创建新的类，实现代码的重用，提高程序的可维护性，节省大量创建新类的时间，提高开发效率和开发质量。</p><h2 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h2><ul><li>子类不能选择性继承父类，子类会继承父类的所有方法和属性。</li><li>Java没有C++的多继承，但是Java中可以进行多级继承，并且Java提供了接口用于克服单继承的缺点，一个类的可以实现多个接口。</li><li>构造方法不会被继承，但是子类可以调用父类的构造方法。</li><li>final类或者方法不可以被继承或者重写。将类或者方法名定义为final的目的是确保他们不会在子类中改变语义。例如Calendar类中的getTime和setTime都声明为final。这表明Calendar类不允许子类处理和Date类之间的转换。</li><li>将一个子类的引用赋给一个父类变量，编译器是允许的。但是把一个父类的引用赋给一个子类变量，必须进行类型转换。</li><li>在进行类型转换前，需要进行instanceof检验看看能否成功转换，不然会产生一个ClassCastException异常。一般情况下，应该少用类型转换和instanceof运算符。</li><li>子类不能访问父类的私有域或者私有方法。</li><li>父类受保护的域或者方法可以直接被子类调用，详见Object类中的clone方法。</li></ul><h2 id="Object类：所有类的超类"><a href="#Object类：所有类的超类" class="headerlink" title="Object类：所有类的超类"></a>Object类：所有类的超类</h2><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p> 简单来说，equals方法是用来判断两个对象是否相等。Object类提供的判断依据是两个对象的引用地址是否相同。所以一般引用类型的比较都是用equals()方法。</p><p>equals方法具有以下几个特点(在自行编写的类中如果要覆盖Object类的equals方法，要求都符合以下特征)：</p><p>1、自反性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>2、对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(y) == y.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>3、传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))<br>    x.equals(z); <span class="hljs-comment">// true;</span><br></code></pre></td></tr></table></figure><p>4、一致性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(y) == x.equals(y); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>5、对于任意非空引用x，x.equals(null)应该返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(<span class="hljs-literal">null</span>); <span class="hljs-comment">// false;</span><br></code></pre></td></tr></table></figure><p>注意：TimeStamp类继承java.utils.Date，但是后者的equals方法使用一个instanceof测试，这样使得无法覆盖equals使之同时做到对称性。也就是不能用TimeStamp类中的equals方法去和Date比较。</p><p><strong>如何编写equals</strong>：</p><p>1、检查this和otherObject是否引用同一个对象。</p><p>2、检查otherObject是否为null，如果为null返回false。</p><p>3、比较this和otherObject是否属于同一个类。如果equals的语义在每个子类中有所改动则用getClass检测，如果所有的子类都拥有统一的语义就用instanceof检测。</p><p>4、将otherObject转换为相应的类变量。</p><p>5、对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。如果匹配就返回true，否则返回false。</p><p><strong>提示</strong>：对于数组类型的域，可以利用静态的Arrays.equals方法进行检测。</p><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object otherObject)</span> &#123;<br>      <span class="hljs-comment">//1、检查this和otherObject是否引用同一个对象。</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == otherObject) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">//2、检查otherObject是否为null，如果为null返回false。</span><br>      <span class="hljs-keyword">if</span> (otherObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">//3、比较this和otherObject是否属于同一个类。</span><br>     <span class="hljs-keyword">if</span> (getClass() != otherObject.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//每个子类中有所改动</span><br>     <span class="hljs-keyword">if</span> (!(otherObject <span class="hljs-keyword">instanceof</span> EqualExample)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//所有的子类都拥有统一的语义</span><br>      <span class="hljs-comment">//4、将otherObject转换为相应的类变量。</span><br>      <span class="hljs-type">EqualExample</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (EqualExample) otherObject;<br>      <span class="hljs-comment">//5、对所有需要比较的域进行比较。</span><br><span class="hljs-keyword">return</span> x=other.x &amp;&amp; Objects.equals(y,other.y);<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>默认输出ClassName@散列码的无符号十六进制表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><p>clone() 是 Object 的 protected 方法，如果要调用该类实例的clone()方法，必须要去显示的重写。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h4><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h4><p>拷贝对象和原始对象的引用类型引用不同对象。需要将对象里所有的元素全部克隆到新的空间。</p><h4 id="clone-的替代方案"><a href="#clone-的替代方案" class="headerlink" title="clone() 的替代方案"></a><strong>clone() 的替代方案</strong></h4><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><h2 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h2><p>将int，long，float，double等基础类型转换成类的手段叫做<strong>对象包装器</strong>。对象包装器是不可变的，对象包装器类是final。</p><p>有一个对象数组列表ArrayList&lt;&gt;，因为尖括号中不能有基础类型，所以这里就用到了Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">//Java SE 5.0改进了添加元素的操作，下面的调用</span><br>list.add(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//将自动变换为</span><br>list.add(Integer.valueOf(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>这种变换叫<strong>自动装箱</strong>，自动装箱那就有自动拆箱。</p><p>注意：自动装箱和自动拆箱是编译器认可的，而不是JVM。</p><h2 id="参数数量可变"><a href="#参数数量可变" class="headerlink" title="参数数量可变"></a>参数数量可变</h2><ul><li>一个方法只能有一个可变的参数,并且这个参数必须是该方法的最后一个参数</li><li>如果重载了可变参数的方法, 优先调用匹配定长参数的方法,不定参数的那个重载方法是最后被选中的。</li><li>对于可变参数的方法,既可以接受多个形式参数类型的参数,也可以接受形式参数类型的数组; 但是方法参数为数组只能接受数组.</li><li>方法调用时,同时满足两个方法,编译器将会产生错误</li><li>对于继承,子类将父类方法的参数列表数组形式改为可变参数数量属于重写,但是指向子类的父类调用该方法是形参列表由父类决定.</li><li>如果向可变长参数的方法传入空参的话,将会new一个对应类型的数组,且长度为0.</li></ul><h2 id="枚举类-需要补充进阶枚举"><a href="#枚举类-需要补充进阶枚举" class="headerlink" title="枚举类(需要补充进阶枚举)"></a>枚举类(需要补充进阶枚举)</h2><p>枚举类主要是为了进行信息分类，枚举是一种特殊类。枚举是有固定实例个数的类型，我们可以把枚举理解成有固定个数实例的多例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//枚举类型，使用关键字enum</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    MONDAY, TUESDAY, WEDNESDAY,<br>    THURSDAY, FRIDAY, SATURDAY, SUNDAY<br>&#125;<br><span class="hljs-keyword">enum</span> 枚举名 &#123;<br>    第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常处理全解——Java基础篇（四）</title>
    <link href="/2023/06/18/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/06/18/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Java异常是Java提供的一种识别及响应错误的一致性机制，保证程序的健壮性。</p><h2 id="异常是什么？"><a href="#异常是什么？" class="headerlink" title="异常是什么？"></a>异常是什么？</h2><p>异常在Java中是以类的形式存在的，每一个异常类都可以创建异常对象，并且也可以自定义异常类。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p><img src="https://img-blog.csdnimg.cn/20210503143543377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>从异常的结构图中可以看出，所有异常都是由Throwable继承而来，但是在下一层分为了<strong>Error</strong>和<strong>Exception</strong>。</p><h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>Error类层次结构范畴描述的是Java在运行时系统内部错误和资源消耗，遇到Error，除了通告用户，并且尽力使程序安全地终止外，在没有办法，但是这种情况出现的概率很低。</p><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>我们作为程序员就关注Exception层次结构就可以了，这个层次分为两个分支：<strong>RuntimeException</strong>和<strong>其他异常</strong>。这两个分支对应的异常种类就是<strong>运行时异常</strong>和<strong>编译时异常</strong>。</p><ul><li><p><strong>运行时异常</strong></p><p>  如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。如果出现这类异常，那一定是程序员的问题。</p></li><li><p><strong>编译时异常</strong></p><p>  从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p></li></ul><p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为<strong>未检查异常</strong>，所有其他的异常成为<strong>已检查异常</strong>。</p><h4 id="已检查异常"><a href="#已检查异常" class="headerlink" title="已检查异常"></a>已检查异常</h4><p>一个方法必须声明所有可能抛出的已检查异常，而未检查异常要么不可控（Error），要么就应该避免发生（RuntimeException），如果方法没有声明所有可能发生的已检验异常，编译器就会给出一个错误信息，在IDE中就是直接报错提醒。</p><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h2><ul><li><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><strong>throw</strong> – 用于抛出异常。</li><li><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h3 id="异常的声明"><a href="#异常的声明" class="headerlink" title="异常的声明"></a>异常的声明</h3><p>异常的声明是当程序运行时，如果方法存在异常，但是在方法并没有对其进行捕获，那必须在方法头中显示声明该异常，以便告知方法调用者此方法有问题。具体的操作就是在方法头使用关键字throws，后面加上要声明的异常。若声明多个异常，则使用逗号分割。通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, FileNotFoundException&#123;<br>    <span class="hljs-comment">//something statements</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Throws抛出异常的规则：</p><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h3><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>(<span class="hljs-string">&quot;参数不能为0&quot;</span>); <span class="hljs-comment">//抛出一个运行时异常</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5.0</span> / value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span>&#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-built_in">super</span>(msg);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><p>异常捕获处理的方法通常有：</p><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h4><ul><li>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</li><li>同一个 catch 也可以捕获多种类型异常，用 | 隔开</li></ul><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p><img src="https://www.pdai.tech/images/java/java-basic-exception-2.jpg" alt="img"></p><h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h4><p>try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。</p><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h4 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h4><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryWithResourceTest</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;c:/abc&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>))&#123;<br>        <span class="hljs-comment">// code</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        <span class="hljs-comment">// handle exception</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>看下Scanner</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;String&gt;, Closeable &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Closeable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p><h2 id="常用的异常"><a href="#常用的异常" class="headerlink" title="常用的异常"></a>常用的异常</h2><ul><li><strong>RuntimeException</strong><ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li><strong>IOException</strong><ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li><strong>其他</strong><ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul><h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><h3 id="只针对不正常的情况才使用异常"><a href="#只针对不正常的情况才使用异常" class="headerlink" title="只针对不正常的情况才使用异常"></a>只针对不正常的情况才使用异常</h3><p>《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p><p>主要原因有三点：</p><ul><li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。</li><li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。</li><li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li></ul><h3 id="在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="在 finally 块中清理资源或者使用 try-with-resource 语句"></a>在 finally 块中清理资源或者使用 try-with-resource 语句</h3><ul><li>方法一：使用 finally 代码块</li></ul><p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeResourceInFinally</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>        inputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        log.error(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                inputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法二：Java 7 的 try-with-resource 语法</li></ul><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">automaticallyCloseResource</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);) &#123;<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        log.error(e);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        log.error(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="尽量使用标准的异常"><a href="#尽量使用标准的异常" class="headerlink" title="尽量使用标准的异常"></a>尽量使用标准的异常</h3><p>Java标准异常中有几个是经常被使用的异常。如下表格：</p><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table><h3 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h3><blockquote><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p></blockquote><h3 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h3><p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p><p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p><p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p><h3 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h3><p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p><h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><p>现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p><p>合理的做法是至少要记录异常的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAnException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        log.error(<span class="hljs-string">&quot;This should never happen: &quot;</span> + e); <span class="hljs-comment">// see this line</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h3><p>仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p><h3 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="包装异常时不要抛弃原始的异常"></a>包装异常时不要抛弃原始的异常</h3><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrapException</span><span class="hljs-params">(String input)</span> <span class="hljs-keyword">throws</span> MyBusinessException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBusinessException</span>(<span class="hljs-string">&quot;A message that describes the error.&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h3><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h3 id="不要在finally块中使用return。"><a href="#不要在finally块中使用return。" class="headerlink" title="不要在finally块中使用return。"></a>不要在finally块中使用return。</h3><p>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。</p><p>如下是一个反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkReturn</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// x等于1，此处不返回</span><br>        <span class="hljs-keyword">return</span> ++x;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 返回的结果是2</span><br>        <span class="hljs-keyword">return</span> ++x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射全解——Java基础篇（三）</title>
    <link href="/2023/06/18/Java%E5%8F%8D%E5%B0%84%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/06/18/Java%E5%8F%8D%E5%B0%84%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射就是把java类中的各种成分映射成一个个的Java对象。在了解反射机制之前我们需要先明白Class类这个概念。</p><h2 id="反射优点和缺点"><a href="#反射优点和缺点" class="headerlink" title="反射优点和缺点"></a>反射优点和缺点</h2><p>优点：可以动态的创建和使用对象，使用灵活，反射机制是框架的灵魂。</p><p>缺点：使用反射基本上是解释执行，对执行速度有影响。</p><h2 id="反射调优"><a href="#反射调优" class="headerlink" title="反射调优"></a>反射调优</h2><p>反射调用优化-关闭访问检查</p><p>Method和Field、Constructor对象都有setAccessible()方法，通过设置访问安全检查的开关实现关闭访问检查，参数值为true是关闭访问检查。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><ul><li>Class类是一个实实在在的类，存在于JDK的java.lang包中。</li><li>Class对象表示某个类加载在堆中的对象。</li><li>Class类对象不是new出来的，而是系统创建出来的。</li><li>对于某个类的Class类对象，在内存中只有一份，因为类加载只发生一次。</li><li>每个Java类实例都会记得自己是由哪一个Class实例生成。</li><li>通过Class对象可以完整的得到一个类的完整结构，也就是通过Class类对象去创建对象、Method、Constructor、Field类对象，通过一系列API来操作类。</li><li>类的字节码二进制数据是存放在方法区的，</li><li>Class类对象创建和new对象是一样的都是通过ClassLoader类加载。</li></ul><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><ol><li><p><strong>前提</strong>：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获得，可能会抛出<code>ClassNotFoundException</code>。</p><p> <strong>实例</strong>：<code>Class cls=Class.forName(&quot;java.lang.Cat&quot;);</code></p><p> <strong>应用场景</strong>：多用于配置文件，读取类全路径，加载类。</p></li><li><p><strong>前提</strong>：若已知具体的类，通过类的class获得，该方式最为安全可靠，程序性能最高。</p><p> <strong>实例</strong>：<code>Class cls2=Cat.class;</code></p><p> <strong>应用场景</strong>：对用于参数传递，比如通过反射得到对应构造器对象。</p></li><li><p><strong>前提</strong>：已知某个类的实例，调用该类的getClass()方法获取Class对象。</p><p> <strong>实例</strong>：Class cls3=对象。getClass();</p><p> <strong>应用场景</strong>：通过创建好的对象，获取Class对象。</p></li><li><p><strong>其他方法</strong>：</p><p> ClassLoader cl=对象.getClass().getClassLoader();</p><p> Class cls=cl.loadClass(“类的全类名”)；</p></li></ol><p><img src="/../images/image-20230111225922995-1687074638374.png" alt="image-20230111225922995"></p><p>如下类型有Class对象：</p><p><img src="/../images/image-20230111230013149-1687074638374.png" alt="image-20230111230013149"></p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。</p><ul><li><p>静态加载：编译时加载相关的类，如果则报错，依赖性太强。</p></li><li><p>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性。</p>  <img src="../../../../../相册/typora/image-20230111231713708.png" alt="image-20230111231713708" style="zoom: 67%;" /></li></ul><p>类加载过程图：</p><p><img src="/../images/image-20230111231015989-1687074638374.png" alt="image-20230111231015989"></p><p><img src="/../images/image-20230111231901886-1687074638375.png" alt="image-20230111231901886"></p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>JVM在该阶段的主要目的时将字节码从不同的数据源（可能是class文件、jar包、网络文件）转化成二进制字节流加载到内存中，并生成一个代表该类的Class对象。</p><h3 id="连接阶段-验证"><a href="#连接阶段-验证" class="headerlink" title="连接阶段-验证"></a>连接阶段-验证</h3><ul><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。</li><li>验证包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证、字节码验证和符号引用验证。</li><li><strong>注意</strong>：可以用-Xverify：none参数来关闭大部分的类验证措施，缩短虚拟机加载时间。</li></ul><h3 id="连接阶段-准备"><a href="#连接阶段-准备" class="headerlink" title="连接阶段-准备"></a>连接阶段-准备</h3><p>JVM会在该阶段对静态变量，分配内存并且默认初始化（如：0，0L，null，false等）。这些变量所使用的内存都将在方法区中进行分配。</p><p><strong>注意</strong>：实例变量在这个阶段不会分配内存，静态变量会分配内存并且默认初始值（这个初始化不是给静态变量赋值，真正的赋值是在初始化阶段），static final静态常量在这个阶段会初始化，也就是赋值就不变了。</p><h3 id="连接阶段-解析"><a href="#连接阶段-解析" class="headerlink" title="连接阶段-解析"></a>连接阶段-解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>此阶段才是真正的执行类中定义的Java程序代码，此阶段是执行&lt;clinit&gt;方法的过程。</li><li>&lt;clinit&gt;方法是由编译器按语句出现的顺序，依次将类中的所有静态变量的赋值和静态代码块的合并。</li><li>JVM会保证一个类的&lt;clinit&gt;方法在多线程的环境下被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个方法，其他线程需要阻塞等待，直到线程执行完毕。</li></ul><h2 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a>通过反射获取类的结构信息</h2><h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>forName()</td><td>(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。</td></tr><tr><td></td><td>(2)为了产生Class引用，forName()立即就进行了初始化。</td></tr><tr><td>Object-getClass()</td><td>获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td></tr><tr><td>getName()</td><td>得到<strong>全类名</strong>，即类的完整名字。</td></tr><tr><td>getSimpleName()</td><td>获取类名(<strong>不包括包名</strong>)</td></tr><tr><td>getCanonicalName()</td><td>获取全限定的类名(包括包名)</td></tr><tr><td>isInterface()</td><td>判断Class对象是否是表示一个接口</td></tr><tr><td>getInterfaces()</td><td>返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td></tr><tr><td>getSupercalss()</td><td>返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td></tr><tr><td>newInstance()</td><td>返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td></tr><tr><td>getFields()</td><td>获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。</td></tr><tr><td>getDeclaredFields</td><td>获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。</td></tr></tbody></table><p><strong>getName、getCanonicalName与getSimpleName的区别</strong>：</p><ul><li><code>getSimpleName</code>：只获取类名</li><li><code>getName</code>：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如<code>Class.forName</code>。</li><li><code>getCanonicalName</code>：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。</li></ul><h3 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h3><p>Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。</p><p>获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>static Class&lt;?&gt;</td><td>forName(String className)</td><td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td></tr><tr><td>Constructor</td><td>getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、具有public访问权限的构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getConstructors()</td><td>返回所有具有public访问权限的构造函数的Constructor对象数组</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、所有声明的（包括private）构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getDeclaredConstructors()</td><td>返回所有声明的（包括private）构造函数对象</td></tr><tr><td>T</td><td>newInstance()</td><td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td></tr></tbody></table><p><strong>Constructor类本身一些常用方法</strong>如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Class</td><td>getDeclaringClass()</td><td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td></tr><tr><td>String</td><td>getName()</td><td>以字符串形式返回此构造方法的名称。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td></tr><tr><td>T</td><td>newInstance(Object… initargs)</td><td>使用此 Constructor对象表示的构造函数来创建新实例</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Constructor 的字符串，其中包括类型参数。</td></tr></tbody></table><h3 id="Field类及其用法"><a href="#Field类及其用法" class="headerlink" title="Field类及其用法"></a>Field类及其用法</h3><p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p><p>Class类与Field对象相关方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Field</td><td>getDeclaredField(String name)</td><td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td></tr><tr><td>Field[]</td><td>getDeclaredFields()</td><td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td></tr><tr><td>Field</td><td>getField(String name)</td><td>获取指定name名称、具有public修饰的字段，包含继承字段</td></tr><tr><td>Field[]</td><td>getFields()</td><td>获取修饰符为public的字段，包含继承字段</td></tr></tbody></table><p><strong>注意</strong>：如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField/getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField/getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。</p><p>Field类还有其他常用的方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>void</td><td>set(Object obj, Object value)</td><td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td></tr><tr><td>Object</td><td>get(Object obj)</td><td>返回指定对象上此 Field 表示的字段的值</td></tr><tr><td>Class&lt;?&gt;</td><td>getType()</td><td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td></tr><tr><td>boolean</td><td>isEnumConstant()</td><td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回一个描述此 Field（包括其一般类型）的字符串</td></tr><tr><td>String</td><td>getName()</td><td>返回此 Field 对象表示的字段的名称</td></tr><tr><td>Class&lt;?&gt;</td><td>getDeclaringClass()</td><td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td></tr><tr><td>void</td><td>setAccessible(boolean flag)</td><td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td></tr></tbody></table><p>上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如<code>setInt()/getInt()</code>、<code>setBoolean()/getBoolean</code>、<code>setChar()/getChar()</code>等等方法。</p><h3 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h3><p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。</p><p>Class类获取Method对象相关的方法：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>Method[]</td><td>getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td>Method</td><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>Method[]</td><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr></tbody></table><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Object</td><td>invoke(Object obj, Object… args)</td><td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td></tr><tr><td>Class&lt;?&gt;</td><td>getReturnType()</td><td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td></tr><tr><td>Type</td><td>getGenericReturnType()</td><td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td></tr><tr><td>String</td><td>getName()</td><td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td></tr><tr><td>boolean</td><td>isVarArgs()</td><td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Method 的字符串，包括类型参数。</td></tr></tbody></table><p><code>getReturnType方法/getGenericReturnType方法</code>都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Type</span> &#123;<br>    <span class="hljs-comment">//1.8新增</span><br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">getTypeName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>getParameterTypes/getGenericParameterTypes</code>也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。</p><h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h2><ol><li>调用类中public无参构造器</li><li>调用类中指定构造器</li><li>Class类的相关方法<ul><li>newInstance：调用类中无参构造器，获取对应类的对象。</li><li>getConstructor(Class cls)：根据参数列表，获取对应的public构造器对象。</li><li>getDecalaredConstructor(Class cls)：根据参数列表，获取对应的所有构造器。</li></ul></li><li>Constructor类相关方法<ul><li>setAccessible：暴破</li><li>newInstance(Object obj)：调用构造器</li></ul></li></ol><p><strong>使用例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 先获取到 User 类的 Class 对象</span><br>Class&lt;?&gt; userClass = Class.forName(<span class="hljs-string">&quot;com.hspedu.reflection.User&quot;</span>);<br><span class="hljs-comment">//2. 通过 public 的无参构造器创建实例</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> userClass.newInstance();<br>System.out.println(o);<br><span class="hljs-comment">//3. 通过 public 的有参构造器创建实例</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">constructor 对象就是</span><br><span class="hljs-comment">public User(String name) &#123;//public 的有参构造器</span><br><span class="hljs-comment">this.name = name;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//3.1 先得到对应构造器</span><br>Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);<br><span class="hljs-comment">//3.2 创建实例，并传入实参</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">hsp</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;hsp&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;hsp=&quot;</span> + hsp);<br><span class="hljs-comment">//4. 通过非 public 的有参构造器创建实例</span><br><span class="hljs-comment">//4.1 得到 private 的构造器对象</span><br>Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="hljs-type">int</span>.class, String.class);<br><span class="hljs-comment">//4.2 创建实例</span><br><span class="hljs-comment">//暴破【暴力破解】 , 使用反射可以访问 private 构造器/方法/属性, 反射面前，都是纸老虎</span><br>constructor1.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> constructor1.newInstance(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;张三丰&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;user2=&quot;</span> + user2);<br></code></pre></td></tr></table></figure><h3 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h3><p><img src="/../images/image-20230112002408993-1687074638375.png" alt="image-20230112002408993"></p><p><img src="/../images/image-20230112002419569-1687074638375.png" alt="image-20230112002419569"></p><h2 id="反射调用流程（具体内容看java全栈知识体系，待补充学习）"><a href="#反射调用流程（具体内容看java全栈知识体系，待补充学习）" class="headerlink" title="反射调用流程（具体内容看java全栈知识体系，待补充学习）"></a>反射调用流程（具体内容看java全栈知识体系，待补充学习）</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型全解——Java基础篇（二）</title>
    <link href="/2023/06/18/Java%E6%B3%9B%E5%9E%8B%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/06/18/Java%E6%B3%9B%E5%9E%8B%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的用处"><a href="#泛型的用处" class="headerlink" title="泛型的用处"></a>泛型的用处</h2><p>意义：适用于多种数据类型执行相同的代码。泛型主要的用途就是代码复用。</p><p>本质：泛型的本质是为了参数化类型，也就是通过泛型指定不同的类型来控制形参具体限制的类型。在使用中，操作的类型被指定为一个具体的参数，可以用在类、接口、方法中，被称为泛型类、泛型接口、泛型方法。</p><h3 id="用处一：减少代码的复用"><a href="#用处一：减少代码的复用" class="headerlink" title="用处一：减少代码的复用"></a>用处一：减少代码的复用</h3><p>减少代码的复用就是对于不同的数据类型，我们可以通过泛型的方式来复合的定义一个方法。</p><h3 id="用处二：不需要强制转换"><a href="#用处二：不需要强制转换" class="headerlink" title="用处二：不需要强制转换"></a>用处二：不需要强制转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>list.add(<span class="hljs-string">&quot;xxString&quot;</span>);<br>list.add(<span class="hljs-number">100d</span>);<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<br></code></pre></td></tr></table></figure><p>如上的代码，如果按照这样的写法，会出现list元素的对象都是Object对象，所以当我们需要取其中的某一个元素时，我们需要将其强制转化为对应的类型，就会出现java.lang.ClassCastException的异常。</p><h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&lt;T&gt;&#123;         <span class="hljs-comment">// 此处可以随便写标识符号，T是type的简称  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;     <span class="hljs-comment">// var的类型由T指定，即：由外部指定  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 返回值的类型由外部决定  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <span class="hljs-comment">// 设置的类型也由外部决定  </span><br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="多元泛型"><a href="#多元泛型" class="headerlink" title="多元泛型"></a>多元泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="hljs-comment">// 此处指定了两个泛型类型  </span><br>    <span class="hljs-keyword">private</span> K key ;     <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">private</span> V value ;   <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(K key)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.key = key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.value = value ;  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;        <span class="hljs-comment">// 在接口上定义泛型  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span> ; <span class="hljs-comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>  定义泛型方法</li></ul><p><img src="https://www.pdai.tech/images/java/java-basic-generic-4.png" alt="img"></p><ul><li>  方法调用</li></ul><p><img src="https://www.pdai.tech/images/java/java-basic-generic-5.png" alt="img"></p><p><strong>为什么要用变量c来创建对象呢？</strong></p><p>既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p><h3 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h3><p>为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<code>&lt;? extends A&gt;</code>表示该类型参数可以是A(上边界)或者A的子类类型。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>  <?> 无限制通配符 </li><li>  <? extends E>extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类 。</li><li>  <? super E>super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类 </li></ul><p> <strong>使用原则《Effictive Java》：</strong></p><ul><li>  为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</li><li>  如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;</li><li>  如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;； </li><li>  如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</li></ul><h4 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span>  &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> E&gt;&gt; E <span class="hljs-title function_">max</span><span class="hljs-params">(List&lt;? extends E&gt; e1)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e1 == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//迭代器返回的元素属于 E 的某个子类型</span><br>    Iterator&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">E</span>&gt; iterator = e1.iterator();<br>    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iterator.next();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>        <span class="hljs-keyword">if</span> (next.compareTo(result) &gt; <span class="hljs-number">0</span>)&#123;<br>            result = next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中E的参数范围是<code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code>。以下进行分析：</p><ul><li><p>  首先E是可以进行比较的类所以需要 <code>extends Comparable&lt;…&gt;</code></p></li><li><p>  <code>Comparable&lt; ? super E&gt;</code> 要对 E 进行比较，即 E 的消费者，所以需要用 super</p></li><li><p>  而参数 <code>List&lt; ? extends E&gt;</code> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大</p></li></ul><h4 id="多个限制"><a href="#多个限制" class="headerlink" title="多个限制"></a>多个限制</h4><p>多个限制只用&amp;符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Staff</span>&amp;Passenger&gt;<br></code></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] list11 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误，非法创建 </span><br>List&lt;String&gt;[] list12 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误，需要强转类型 </span><br>List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK，但是会有警告 </span><br>List&lt;?&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误，非法创建 </span><br>List&lt;?&gt;[] list15 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK </span><br>List&lt;String&gt;[] list6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK，但是会有警告</span><br></code></pre></td></tr></table></figure><h4 id="合理使用"><a href="#合理使用" class="headerlink" title="合理使用"></a>合理使用</h4>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多态全解——Java基础篇（一）</title>
    <link href="/2023/06/18/Java%E5%A4%9A%E6%80%81%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/06/18/Java%E5%A4%9A%E6%80%81%E5%85%A8%E8%A7%A3%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态分为编译时多态和运行时多态:</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>在这里我们只要讲的是运行时多态。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>继承</li><li>要有方法的重写</li><li>父类引用指向子类对象：Animal a=new Cat();（向上转型）</li><li>多态中，编译看左，运行看右</li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.tedu.oop2;<br><span class="hljs-comment">/*本类用作多态的入门案例*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//Cat类对象的地址值交给父类型变量a2来保存</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//Dog类对象的地址值交给父类型变量a3来保存</span><br>        <span class="hljs-comment">//8.测试多态对象</span><br>        <span class="hljs-comment">/*4.口诀2：编译看左边，运行看右边</span><br><span class="hljs-comment">        * 解释：必须要在父类定义这个方法，才能通过编译，把多态对象看作是父类类型</span><br><span class="hljs-comment">        *      必须要在子类重写这个方法，才能满足多态，实际干活的是子类*/</span><br>        a2.eat();<span class="hljs-comment">//小猫爱吃小鱼干~，多态对象使用的是父类的定义，子类的方法体</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*1.多态的前提：继承+重写*/</span><br><span class="hljs-comment">//1.创建父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//3.创建父类的普通方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小动物Animal吃啥都行~&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//2.1创建子类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//4.1添加重写的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小猫爱吃小鱼干~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5.1添加子类的特有功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jump</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小猫Cat跳的老高啦~&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//2.2创建子类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-comment">//4.2添加重写的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小狗爱吃肉骨头~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5.2添加子类的特有功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小狗Dog跑的老快啦~&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><ol><li>多态可以让我们不用关心某个对象到底具体是什么类型,就可以使用该对象的某些方法，也就是不用关心子类的具体方法，而是把子类看成父类进行使用。</li><li>提高了程序的可扩展性和可维护性</li><li>多态可以统一调用标准</li></ol><h2 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h2><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p><strong>本质</strong>：父类的引用指向子类对象。</p><p><strong>语法</strong>：父类类型 引用名 = new 子类类型()；</p><p><strong>特点</strong>：编译类型看左边，运行类型看右边。可以调用父类中的所有成员（须遵守访问权限），不能调用子类中特有成员，最终运行效果看子类的具体实现。</p><h3 id="向下转型（很少）"><a href="#向下转型（很少）" class="headerlink" title="向下转型（很少）"></a>向下转型（很少）</h3><p>语法：子类类型 引用名 = (子类类型) 父类引用；</p><p>特点：只能强转父类的引用，不能强转父类对象；要求父类的引用必须指向的是当前目标类型的对象；当向下转型后，可以调用子类类型中的所欲成员。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树解析</title>
    <link href="/2023/06/15/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/06/15/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>红黑树是平衡二叉树的一种，可以保证在最坏的情况下基本动态集合操作的时间复杂度为O(lgn)。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>红黑树的每个节点包含有5个属性，color、key、left、right、parent。</p><p>红黑树满足的性质：</p><p>（1）每个节点或者是黑色，或者是红色。</p><p>（2）根节点是黑色。</p><p>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p><p>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</p><p>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><p><img src="/../images/251730074203156.jpg" alt="img"></p><p>引理：一棵有n个内部节点的红黑树的高度至多为2lg(n+1)</p><p>通过这个引理可以知道，动态集合操作SEACHER、MINIMUM、MAXIMUM、SUCCESSOR、PREDECESSOR都可以在O(lgn)时间内操作。</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转的实现代码和平衡二叉树很相似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 左旋</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(RBTNode&lt;T&gt; x)</span>&#123;<br>    <span class="hljs-comment">//y指向x的右孩子，之后用来交换两个位置</span><br>    RBTNode&lt;T&gt; y=x.right;<br>    x.right=y.left;<br>    <span class="hljs-comment">//如果y的左孩子不为空，那么左孩子的父节点就是x。</span><br>    <span class="hljs-keyword">if</span>(y.left!=<span class="hljs-literal">null</span>)&#123;<br>        y.left.parent=x;<br>    &#125;<br>    y.parent=x.parent;<br>    <span class="hljs-keyword">if</span>(x.parent==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-built_in">this</span>.mRoot=y;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//通过分析x是父节点的左孩子还是右孩子来判断y应该是什么孩子。</span><br>        <span class="hljs-keyword">if</span>(x.parent.left==x)x.parent.left=y;<br>        <span class="hljs-keyword">if</span>(x.parent.right==x)x.parent.right=y;<br><br>    &#125;<br>    y.left=x;<br>    x.parent=y;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 右旋，右旋的实现和左旋差不多。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(RBTNode&lt;T&gt; y)</span>&#123;<br>    <span class="hljs-comment">//y是x的父节点</span><br>    RBTNode&lt;T&gt; x=y.left;<br>    <span class="hljs-comment">//将x的右节点变成y的左节点。</span><br>    y.left=x.right;<br>    <span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>)&#123;<br>        x.right.parent=y;<br>    &#125;<br>    x.parent=y.parent;<br>    <span class="hljs-keyword">if</span>(y.parent==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-built_in">this</span>.mRoot=x;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(y.parent.left==y)y.parent.left=x;<br>        <span class="hljs-keyword">if</span>(y.parent.right==y)y.parent.right=x;<br>    &#125;<br>    x.right=y;<br>    y.parent=x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>关于红黑树的插入，就需要考虑不同种情况了。主要就是三步：</p><p>1、将红黑树当作一棵不同的二叉查找树，将节点插入。</p><p>2、将插入的节点着色为“红色”。</p><p>3、通过一系列旋转或者着色操作，使之重新称为一棵红黑树</p><p>众所周知，红黑树的具有5条性质，我们在插入的时候就是可以通过分析将新的节点插入后并且着色为红色，让哪几条性质失效了。</p><p>以下是具体分析：</p><ul><li>  第一步：将红黑树当作一棵二叉树的节点，插入到二叉树中。</li><li>  第二步：将插入的节点着色为红色。当着色红色的时候，不会违背第5条性质。</li><li>  第三步：对于性质1，3性质都不会违背，也就只有2、4性质会违背。违背的情况就是如果插入的z是根节点，那么就违背了2，如果z的父节点是红，就违背了性质4。</li></ul><p>首先，我们先把添加节点的代码写好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 插入操作</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(RBTNode&lt;T&gt; node)</span> &#123;<br>       RBTNode&lt;T&gt; y = <span class="hljs-literal">null</span>;<br>       RBTNode&lt;T&gt; x = <span class="hljs-built_in">this</span>.mRoot;<br>       <span class="hljs-keyword">while</span> (x != <span class="hljs-literal">null</span>) &#123;<br>           y = x;<br>           <span class="hljs-keyword">if</span> (node.key.compareTo(x.key) &lt; <span class="hljs-number">0</span>) &#123;<br>               x = x.left;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               x = x.right;<br>           &#125;<br>       &#125;<br>       node.parent = y;<br>       <span class="hljs-keyword">if</span> (y == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-built_in">this</span>.mRoot = node;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">if</span> (node.key.compareTo(y.key) &lt; <span class="hljs-number">0</span>) &#123;<br>               node.left = y;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               node.right = y;<br>           &#125;<br>       &#125;<br>       node.left = <span class="hljs-literal">null</span>;<br>       node.right = <span class="hljs-literal">null</span>;<br>       node.color = RED;<br>       insertFixUp(node);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T key)</span> &#123;<br>       RBTNode&lt;T&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RBTNode</span>&lt;&gt;(key, BLACK, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>       <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>           insert(node);<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>然后这个时候红黑树会因为插入一个红节点而破坏原有的结构，我们对其进行插入修正操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 插入修正</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFixUp</span><span class="hljs-params">(RBTNode&lt;T&gt; node)</span> &#123;<br>       RBTNode&lt;T&gt; parent, gparent, uncle;<br>       <span class="hljs-keyword">while</span> (node.parent != <span class="hljs-literal">null</span> &amp;&amp; node.parent.color == RED) &#123;<br>           parent = node.parent;<br>           gparent = parent.parent;<br>           <span class="hljs-comment">//当父节点是祖父节点的左孩子</span><br>           <span class="hljs-keyword">if</span> (parent == gparent.left) &#123;<br>               uncle = gparent.right;<br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               case1:叔节点为red的时候，进行以下操作：</span><br><span class="hljs-comment">               1、将父节点变黑</span><br><span class="hljs-comment">               2、将叔叔节点变黑</span><br><span class="hljs-comment">               3、将祖父节点变红</span><br><span class="hljs-comment">               4、将祖父节点变成现在的节点</span><br><span class="hljs-comment">                */</span><br>               <span class="hljs-keyword">if</span> (uncle != <span class="hljs-literal">null</span> &amp;&amp; uncle.color == RED) &#123;<br>                   parent.color = BLACK;<br>                   uncle.color = BLACK;<br>                   gparent.color = RED;<br>                   node = gparent;<br>               &#125;<br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               case2:叔叔是黑色，且当前是右孩子。</span><br><span class="hljs-comment">               1、将父节点作为当前节点。</span><br><span class="hljs-comment">               2、以新的节点作为支点进行左旋。</span><br><span class="hljs-comment">                */</span><br>               <span class="hljs-keyword">if</span>(node==parent.right)&#123;<br>                   node=parent;<br>                   leftRotate(node);<br>               &#125;<br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               case3:叔叔是黑色，且当前是左孩子。</span><br><span class="hljs-comment">               1、将父节点变黑</span><br><span class="hljs-comment">               2、将祖父节点变为红色</span><br><span class="hljs-comment">               3、以祖父节点进行右旋</span><br><span class="hljs-comment">                */</span><br>               <span class="hljs-keyword">if</span>(node==parent.left)&#123;<br>                   parent.color=BLACK;<br>                   gparent.color=RED;<br>                   rightRotate(gparent);<br>               &#125;<br><br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               uncle = gparent.left;<br>               <span class="hljs-keyword">if</span> (uncle != <span class="hljs-literal">null</span> &amp;&amp; uncle.color == RED) &#123;<br>                   parent.color = BLACK;<br>                   uncle.color = BLACK;<br>                   gparent.color = RED;<br>                   node = gparent;<br>               &#125;<br>               <span class="hljs-keyword">if</span>(node==parent.left)&#123;<br>                   node=parent;<br>                   rightRotate(node);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(node==parent.right)&#123;<br>                   parent.color=BLACK;<br>                   gparent.color=RED;<br>                   leftRotate(gparent);<br>               &#125;<br><br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>待补充。。。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章搞懂HashMap</title>
    <link href="/2023/06/15/HashMap%E5%85%A8%E8%A7%A3/"/>
    <url>/2023/06/15/HashMap%E5%85%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="从应用到底层看破HashMap（源码精讲一）"><a href="#从应用到底层看破HashMap（源码精讲一）" class="headerlink" title="从应用到底层看破HashMap（源码精讲一）"></a>从应用到底层看破HashMap（源码精讲一）</h1><blockquote><p>  作为面试中最喜欢考察的知识点之一和在实际中最常用到的Map集合，HashMap为什么这么让人着谜，对应的数据结构是什么，有哪些具体的应用场景，底层的实现逻辑是什么？下文的分析和源码都是来自于JDK8。</p></blockquote><h2 id="HashMap是什么"><a href="#HashMap是什么" class="headerlink" title="HashMap是什么"></a>HashMap是什么</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>HashMap是Java程序员使用频率最高的键值对集合，对应着哈希表这一数据结构，在学习HashMap之前，我们需要先复习一下哈希表的一些概念。</p><p>哈希表相较于其他数据结构，得力于它的添加、删除、查找等功能的性能强大，我们常用的Redis非关系型数据库就是利用典型的键值对的数据结构存储（怪不得Redis这么好用）。在不考虑哈希冲突的情况下，只需要时间复杂度为O(1)就能够定位。</p><p>但是哈希表有一个非常窒命的问题就是哈希冲突，解决哈希冲突有两个方法，一是开放寻址法（ThreadLocal就是利用这个，先挖一个坑），另一种就是我们今天要讲的HashMap的实现方法——链地址法。</p><h3 id="Map大家族"><a href="#Map大家族" class="headerlink" title="Map大家族"></a>Map大家族</h3><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/f7fe16a2.png" alt="Map大家庭"></p><p>从上面的图中我们可以看到，在Java.util.Map接口下，有四个常用的类，分别是HashMap、HashTable、LinkedHashMap、TreeMap。</p><p>下面讲一下它们之间的区别吧：</p><ul><li>  <strong>HashMap</strong>：根据键的hashcode来存储数据，访问速度快，但是遍历顺序不确定。HashMap是线程不安全的，下文会具体的介绍为什么线程不安全，如何需要满足线程安全， 可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li>  <strong>HashTable</strong>：已经被淘汰可以不进行学习和使用。</li><li>  <strong>LinkedHashMap</strong>：是HashMap的一个子类，但是记录了插入的顺序，只要记住这一点就可以了。</li><li>  <strong>TreeMap</strong>：TreeMap实现了SortedMap接口，能将所有的记录根据key进行排序。默认升序。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ul><p>所以通过上面的介绍，大概就有了一个知识图谱，如果是需要线程安全就需要使用concurrentHashMap，如果需要记录记录顺序则使用linkedHashMap。如果需要key是有序的，则需要TreeMap。</p><h2 id="HashMap应用场景"><a href="#HashMap应用场景" class="headerlink" title="HashMap应用场景"></a>HashMap应用场景</h2><p>HashMap的使用场景就是如果你需要使用到键值对，并且需要非常高效的搜索能力的时候，例如存储用户信息、缓存、字段，但是HashMap线程不安全，这个需要注意一下。</p><h2 id="HashMap的重要方法"><a href="#HashMap的重要方法" class="headerlink" title="HashMap的重要方法"></a>HashMap的重要方法</h2><ul><li><p>创建HashMap对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String,Integer&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li><li><p>添加元素(put)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.put(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-number">123</span>);<br>hashMap.put(<span class="hljs-string">&quot;234&quot;</span>,<span class="hljs-number">234</span>);<br></code></pre></td></tr></table></figure></li><li><p>删除元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.remove(<span class="hljs-string">&quot;123&quot;</span>);<br>hashMap.remove(<span class="hljs-string">&quot;234&quot;</span>,<span class="hljs-number">234</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取元素</p><ul><li>  get()</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.get(<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>  getOrDefault()</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getOrDefault(<span class="hljs-string">&quot;123&quot;</span>,-<span class="hljs-number">1</span>);<span class="hljs-comment">//如果123不存在默认返回-1</span><br></code></pre></td></tr></table></figure></li><li><p>元素遍历(推荐写法)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator1</span> <span class="hljs-operator">=</span> hashMap.entrySet().iterator();<br>        <span class="hljs-keyword">while</span> (iterator1.hasNext())&#123;<br>            Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) iterator1.next();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (String) entry.getKey();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (Integer) entry.getValue();<br>            System.out.println(key+<span class="hljs-string">&quot;=&quot;</span>+value);<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>判断key或者value是否存在</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.containKey(<span class="hljs-string">&quot;123&quot;</span>);<br>hashMap.containValue(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure></li><li><p>替换元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hashMap.replace(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-number">34</span>);<span class="hljs-comment">//如果key不存在，则不处理。</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="HashMap底层实现（代码全解）"><a href="#HashMap底层实现（代码全解）" class="headerlink" title="HashMap底层实现（代码全解）"></a>HashMap底层实现（代码全解）</h2><p>在HashMap中，最主要的就是三个方法的实现，分别是put、get、resize。下面我就对其三个方法的源码进行深入的分析。</p><h3 id="put方法详解"><a href="#put方法详解" class="headerlink" title="put方法详解"></a>put方法详解</h3><p>首先我们先看put的实现：</p><p><img src="/../images/d669d29c.png" alt="put实现流程"></p><p>上面是完整的put实现。其中有一些重要的属性：table是哈希桶表；threshold表示扩容的阈值；loadFactor表示的是负载因子。</p><p><strong>总的逻辑过程如下：</strong></p><ol><li> 判断table是否是空，如果为空，则进行resize</li><li> 根据键值计算插入的数组索引i。</li><li> 如果table[i]是null则直接插入，如果不是null，则查询key是否已经存在，如果存在则直接覆盖。</li><li> 如果key不存在，则考虑是否是红黑树，如果是红黑树，则直接插入红黑树中。</li><li> 如果不是红黑树，则插入链表</li><li> 判断链表长度是否大于8，如果大于8，转换成红黑树。</li><li> 若不大于8，则直接插入，如果key存在，则直接覆盖。</li><li> 最后判断是否到达阈值，如果到达阈值，则进行resize。</li></ol><p><strong>源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<span class="hljs-comment">//tab是记录哈希表的数组</span><br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<span class="hljs-comment">//如果当前的table是null，或者数组的长度是0，则创建一个数组</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<span class="hljs-comment">//通过hash值去确定插入数组的索引i，如果该索引上为空，则直接插入值。</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<span class="hljs-comment">//如果该索引不为空</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<span class="hljs-comment">//如果key已经存在，则直接覆盖node</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<span class="hljs-comment">//如果key不存在，判断是否是红黑树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<span class="hljs-comment">//是红黑树，直接插入</span><br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果不是红黑树，而是链表，那么循环插入。</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<span class="hljs-comment">//如果下一个node为空，插入</span><br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<span class="hljs-comment">//如果链表的长度大于8，则将链表变成红黑树</span><br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<span class="hljs-comment">//如果key已经存在则直接覆盖value。</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<span class="hljs-comment">//如果超过了最大值，扩容</span><br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//resize函数就是复制旧数组到新数组。</span><br></code></pre></td></tr></table></figure><p>关于红黑树的实现我会在红黑树详解中介绍该HashMap中的红黑树实现，具体请跳转<a href="/2023/06/15/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%A7%A3%E6%9E%90/" title="红黑树解析">红黑树解析</a></p><h3 id="get方法详解"><a href="#get方法详解" class="headerlink" title="get方法详解"></a>get方法详解</h3><p>对于哈希表来说，不管是查询、增加还是删除，快速定位到元素的位置是非常重要的。前面说到了HashMap是通过数组+链表进行存储的（这里先考虑JDK1.7，因为原理是一样的）。在哈希表中，要提高查询的速度，最好数组中的每个位子都只有一个元素。但是这样子的话就会要求元素之间要足够离散。如果一个哈希表太小，算法再强也没有用；但是如果哈希表过大，造成了空间的浪费也不是好的设计。这里我们可以学习一下HashMap的设计。</p><p><strong>先看看源码（jdk1.7和jdk1.8）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;   <span class="hljs-comment">//jdk1.8 &amp; jdk1.7</span><br>     <span class="hljs-type">int</span> h;<br>     <span class="hljs-comment">// h = key.hashCode() 为第一步 取hashCode值</span><br>     <span class="hljs-comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br>     <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;  <span class="hljs-comment">//jdk1.7的源码</span><br>     <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);  <span class="hljs-comment">//第三步 取模运算</span><br>&#125;<br><br>tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]<br><span class="hljs-comment">//jdk1.8的源码，putVal中的寻址方式</span><br></code></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p><p><strong>取hashcode</strong>就是非常常规的，这里我讲一下HashMap或者所有的Map类型的数据结构是怎么进行寻址和插入以及删除操作的，其实核心就是如果一样的key，就会生成一样的hashcode，一样的hashcode就会生成一样的hash值，一样的hash值就可以找到一样的索引，然后就可以定位到元素。</p><p>在JDK1.8的实现中，优化了<strong>高位运算</strong>的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。以下是1.7中hash算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hashSeed;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>    &#125;<br>    <span class="hljs-comment">// key的hashcode会和hash seed做与运算</span><br>    h ^= k.hashCode();<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>1.7和1.8得到的值<strong>既包含了自己高位的特性又包含了自己低位的特性</strong>，从而增加了之后得到的下标的不确定性，降低了碰撞的概率。</p><p><img src="/../images/1460000022059146" alt="hash算法实现"></p><p><strong>计算下标：</strong></p><p>在这里的算法真的是惊艳，对应下面的面试题，详细见下边。</p><h3 id="resize方法详解"><a href="#resize方法详解" class="headerlink" title="resize方法详解"></a>resize方法详解</h3><p>因为在JDK1.8中，使用的是红黑树的存储方式，实现起来较为复杂，所以我们先看看在JDK1.7中是如何实现resize这个方法的。</p><p><strong>JDK1.7源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;   <span class="hljs-comment">//传入新的容量</span><br>     Entry[] oldTable = table;    <span class="hljs-comment">//引用扩容前的Entry数组</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;         <br>     <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="hljs-comment">//扩容前的数组大小如果已经达到最大(2^30)了</span><br>         threshold = Integer.MAX_VALUE; <span class="hljs-comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br>         <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>     Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];  <span class="hljs-comment">//初始化一个新的Entry数组</span><br>   transfer(newTable);                         <span class="hljs-comment">//！！将数据转移到新的Entry数组里</span><br>    table = newTable;                           <span class="hljs-comment">//HashMap的table属性引用新的Entry数组</span><br>   threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);<span class="hljs-comment">//修改阈值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable)</span> &#123;<br>    Entry[] src = table;                   <span class="hljs-comment">//src引用了旧的Entry数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123; <span class="hljs-comment">//遍历旧的Entry数组</span><br>        Entry&lt;K,V&gt; e = src[j];             <span class="hljs-comment">//取得旧Entry数组的每个元素</span><br>       <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>           src[j] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span><br>           <span class="hljs-keyword">do</span> &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity); <span class="hljs-comment">//！！重新计算每个元素在数组中的位置</span><br>               e.next = newTable[i]; <span class="hljs-comment">//标记[1]</span><br>               newTable[i] = e;      <span class="hljs-comment">//将元素放在数组上</span><br>               e = next;             <span class="hljs-comment">//访问下一个Entry链上的元素</span><br>             &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>);<br>         &#125;<br>     &#125;<br> &#125; <br></code></pre></td></tr></table></figure><p>上面就是在1.7中的关键代码，其中resize就是修改阈值和引用transfer函数，内核的交换新旧数组的函数其实是transfer，在transfer中，可以看到标记1这个地方是一个非常明显的头插入，扩容以后的数组里的链表是倒序的，这样的设计也是造成JDK1.7有严重问题的原因，当然在JDK1.8中这个问题已经解决了。在JDK1.8已经修改为了尾插入。</p><p>同样看到标记1上面的这一行代码，这里是一个重新计算每个元素在数组中的位置。下面是对于该行代码的优化。</p><p>我们先来分析扩容机制，当数组的存储量已经到达了threshold，也就是阈值以后，我们就需要扩大容量为两倍。那么对于每一个元素而言，在扩容后，根据下标计算公式，只可能会在原位置或者原位置移动2次幂的位置。</p><p><img src="/../images/4d8022db.png" alt="分析扩容后元素下标变化"></p><p>可以看到上面的这个图，其中n-1就是现在数组的容量，现在将数组扩容为2倍，可以发现其实就是对原容量进行左移1位，然后通过indexFor函数进行取模运算，也就是和length-1进行与运算。可以发现运算之后，如果原来的key高位是0，则下标不变，如果原来的key高位是1，则在原位置移动2次幂。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>        Node&lt;K,V&gt;[] oldTab = table;<span class="hljs-comment">//oldTab记录旧数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<span class="hljs-comment">//记录旧容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<span class="hljs-comment">//记录旧的阈值</span><br>        <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果旧容量大于0</span><br>            <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="hljs-comment">//如果大于2^30</span><br>                threshold = Integer.MAX_VALUE;<span class="hljs-comment">//修改阈值到2^31-1</span><br>                <span class="hljs-keyword">return</span> oldTab;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="hljs-comment">//如果新的容量小于最大值或者旧容量大于初始值</span><br>                newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 两倍的阈值</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 旧阈值大于0，赋给新容量</span><br>            newCap = oldThr;<br>        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 初始化</span><br>            newCap = DEFAULT_INITIAL_CAPACITY;<br>            newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//阈值等于0，赋值</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                      (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>        &#125;<br>        threshold = newThr;<span class="hljs-comment">//赋值新的阈值</span><br>        <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>        table = newTab;<span class="hljs-comment">//定义新的table</span><br>        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//接下去就是复制旧数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>                Node&lt;K,V&gt; e;<br>                <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果旧数组中某一索引不为空</span><br>                    oldTab[j] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//这个写法在Java中还是比较常见的，可以学习。</span><br>                    <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                        newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<span class="hljs-comment">//计算新的数组下标</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                        ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                        Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                        Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                        Node&lt;K,V&gt; next;<br>                        <span class="hljs-keyword">do</span> &#123;<br>                            next = e.next;<br>                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//原索引</span><br>                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                    loHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = e;<br>                                loTail = e;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//原索引＋oldCap</span><br>                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                    hiHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = e;<br>                                hiTail = e;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                            loTail.next = <span class="hljs-literal">null</span>;<br>                            newTab[j] = loHead;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                            hiTail.next = <span class="hljs-literal">null</span>;<br>                            newTab[j + oldCap] = hiHead;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newTab;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java编程路线</title>
    <link href="/2023/06/14/Java%E7%BC%96%E7%A8%8B%E8%B7%AF%E7%BA%BF/"/>
    <url>/2023/06/14/Java%E7%BC%96%E7%A8%8B%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Java后端技术体系"><a href="#Java后端技术体系" class="headerlink" title="Java后端技术体系"></a>Java后端技术体系</h1><h2 id="第一部分：Java基础"><a href="#第一部分：Java基础" class="headerlink" title="第一部分：Java基础"></a>第一部分：Java基础</h2><ul><li><p>变量</p></li><li><p>控制结构</p><ul><li>顺序结构</li><li>分支</li><li>循环</li></ul></li><li><p>OOP</p><ul><li>封装</li><li>继承</li><li>多态</li></ul></li><li><p>数组</p></li><li><p>Java API</p></li><li><p>异常处理</p></li><li><p>集合</p></li><li><p>泛型</p></li><li><p>反射</p></li><li><p>网络通信</p></li></ul><h2 id="第二部分：Java高级"><a href="#第二部分：Java高级" class="headerlink" title="==第二部分：Java高级=="></a>==第二部分：Java高级==</h2><h3 id="Java多线程-高并发"><a href="#Java多线程-高并发" class="headerlink" title="Java多线程/高并发"></a>Java多线程/高并发</h3><ul><li>并发基础<ul><li>互斥同步</li><li>非阻塞同步</li><li>指令重排</li><li>synchronized</li><li>volatile</li></ul></li><li>线程</li><li>锁<ul><li>自旋锁</li><li>偏向锁</li><li>可重入锁</li></ul></li><li>线程池</li><li>并发容器</li><li>JUC<ul><li>executor</li><li>collections</li><li>locks</li><li>atomic（原子类）</li><li>tools（CountDownLatch，Exchanger，ThreadLocal，CyclicBarrier）</li></ul></li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul><li>数据结构<ul><li>数组（稀疏数组）</li><li>队列</li><li>栈</li><li>链表</li><li>树</li><li>散列</li><li>堆</li><li>图</li></ul></li><li>算法<ul><li>排序算法（8种）</li><li>查找</li><li>分治算法</li><li>动态规划（背包问题）</li><li>回溯算法（骑士周游问题）</li><li>贪心算法</li><li>KMP</li><li>Prim</li><li>kruskal</li><li>弗洛伊德算法</li><li>迪杰斯特拉算法</li></ul></li></ul><h3 id="设计模式（23种）"><a href="#设计模式（23种）" class="headerlink" title="设计模式（23种）"></a>设计模式（23种）</h3><p>常用的8种：</p><ul><li>单例模式</li><li>观察者模式</li><li>工厂模式</li><li>适配器模式</li><li>装饰者模式</li><li>代理模式</li><li>模板模式</li><li>责任链模式</li><li>其他（桥接模式、原型模式、组合模式）</li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li>JVM体系</li><li>类加载过程/机制</li><li>双亲委派机制/沙箱安全机制</li><li>JMM（Java内存模式）</li><li>字节码执行的过程/机制</li><li>GC(垃圾回收机制)</li><li>JVM性能监控和故障定位</li><li>JVM调优</li></ul><h2 id="第三部分：JavaWeb"><a href="#第三部分：JavaWeb" class="headerlink" title="第三部分：JavaWeb"></a>第三部分：JavaWeb</h2><h3 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h3><ul><li>HTML</li><li>CSS</li><li>Javascript</li><li>Ajax</li><li>Jquery</li></ul><h3 id="前端框架（弱化）"><a href="#前端框架（弱化）" class="headerlink" title="前端框架（弱化）"></a>前端框架（弱化）</h3><ul><li>VUE</li><li>React</li><li>Angular</li><li>bootstrap</li><li>Node.js</li></ul><h3 id="JavaWeb后端"><a href="#JavaWeb后端" class="headerlink" title="JavaWeb后端"></a>JavaWeb后端</h3><ul><li>Tomcat</li><li>Servlet</li><li>JSP</li></ul><h2 id="第四部分：主流框架和项目管理"><a href="#第四部分：主流框架和项目管理" class="headerlink" title="第四部分：主流框架和项目管理"></a>第四部分：主流框架和项目管理</h2><ul><li>Linux</li><li>Nginx</li><li>==SSM==<ul><li>Spring</li><li>SpringMVC</li><li>MyBatis</li></ul></li><li>项目管理<ul><li>Maven</li><li>git&amp;Github</li></ul></li><li>数据库<ul><li>Redis</li><li>Mysql</li><li>Oracle</li></ul></li><li>其他框架<ul><li>WebService(SOA)</li><li>Activiti(工作流框架)</li><li>Shiro(安全框架)</li><li>Spring  Security(安全框架)</li><li>JPA(持久化)</li><li>SpringData(持久层的通用解决方案)</li></ul></li></ul><h2 id="第五部分：分布式-微服务-并行架构"><a href="#第五部分：分布式-微服务-并行架构" class="headerlink" title="第五部分：分布式|微服务|并行架构"></a>第五部分：分布式|微服务|并行架构</h2><ul><li>Netty</li><li>Dubbo（RPC框架）</li><li>FastDFS（分布式的文件系统）</li><li>Docker（应用容器引擎）</li><li>==Spring家族==<ul><li>SpringBoot</li><li>SpringCloud<ul><li>Nacos（阿里巴巴服务发现，配置，管理）</li><li>Seata（阿里巴巴，分布式事务的中间件）</li><li>Sentinel（阿里巴巴，流量控制，融断，系统负载保护）</li><li>Gateway（网关，限流，日志，监控，鉴权）</li><li>OpenFeign（服务间调用）</li></ul></li></ul></li><li>搜索引擎<ul><li>ElasticSearch</li><li>Solr</li></ul></li><li>==中间件==<ul><li>Mycat（数据库中间件，分库分表）</li><li>消息中间件<ul><li>ActiveMQ</li><li>RabbitMQ</li><li>KafKa</li></ul></li></ul></li><li>日志分析与监控（ELK）<ul><li>ElasticSearch（搜索，存储数据）</li><li>LogStash（分析日志）</li><li>Kibana（可视化）</li></ul></li><li>Zookeeper（一致性服务：比如 配置维护，域名维护，分布式同步）</li></ul><h2 id="第六部分：DevOps（开发运维一体化）自动化部分管理项目，解决CI-CD"><a href="#第六部分：DevOps（开发运维一体化）自动化部分管理项目，解决CI-CD" class="headerlink" title="第六部分：DevOps（开发运维一体化）自动化部分管理项目，解决CI/CD"></a>第六部分：DevOps（开发运维一体化）自动化部分管理项目，解决CI/CD</h2><ul><li>k8s(让部署容器化的应用简单高效)</li><li>普罗米修斯（prometheus）(系统监控和报警)</li><li>Jenkins（监控持续的工作【部署，集成，交付】）</li><li>Harbor（容器的镜像仓库）</li><li>GitLab</li><li>SonarQube(项目工程代码质量检测)</li></ul><h2 id="第七个部分：大数据技术（可以弱化）"><a href="#第七个部分：大数据技术（可以弱化）" class="headerlink" title="第七个部分：大数据技术（可以弱化）"></a>第七个部分：大数据技术（可以弱化）</h2><ul><li>Hadoop</li><li>Hive</li><li>Impals</li><li>spark</li><li>flink</li></ul><h2 id="第八个部分：项目"><a href="#第八个部分：项目" class="headerlink" title="==第八个部分：项目=="></a>==第八个部分：项目==</h2><ul><li>电商</li><li>金融</li><li>教育</li><li>直播</li><li>CRM，ERP</li></ul><h2 id="第九个部分：大厂高频面试题"><a href="#第九个部分：大厂高频面试题" class="headerlink" title="第九个部分：大厂高频面试题"></a>第九个部分：大厂高频面试题</h2><h2 id="第十个部分：底层源码-内核研究"><a href="#第十个部分：底层源码-内核研究" class="headerlink" title="第十个部分：底层源码/内核研究"></a>第十个部分：底层源码/内核研究</h2><h2 id="编程基础的扩展"><a href="#编程基础的扩展" class="headerlink" title="编程基础的扩展"></a>编程基础的扩展</h2><ul><li>计算机网络</li><li>操作系统</li><li>编译原理</li><li>离散数学</li><li>数值分析</li><li>计算机组成原理</li><li>汇编语言</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
